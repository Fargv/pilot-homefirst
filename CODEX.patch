diff --git a/backend/package.json b/backend/package.json
index 820f5782b5a047727f6831e00e09166154b1368c..626898680e0e345532bc0ec76b0079e60466119c 100644
--- a/backend/package.json
+++ b/backend/package.json
@@ -1,23 +1,24 @@
 {
   "name": "pilot-backend",
   "version": "1.0.0",
   "type": "module",
   "main": "src/index.js",
   "scripts": {
     "start": "node src/index.js",
     "dev": "node --watch src/index.js",
     "migrate:households": "node scripts/migrate-households.js",
     "create:diod": "node scripts/create-diod.js",
-    "test:connection": "node scripts/test-connection.js",
-    "migrate:householdId": "node scripts/migrate-add-householdId.js"
+    "test:connection": "node scripts/test-connection.js",
+    "migrate:householdId": "node scripts/migrate-add-householdId.js",
+    "migrate:ingredientCategoryId": "node scripts/migrate-ingredient-category-id.js"
   },
   "dependencies": {
     "bcryptjs": "^2.4.3",
     "cors": "^2.8.5",
     "dotenv": "^16.4.5",
     "express": "^4.19.2",
     "jsonwebtoken": "^9.0.2",
     "mongoose": "^8.6.1",
     "nodemailer": "^6.9.14"
   }
 }
diff --git a/backend/src/kitchen/routes/categories.js b/backend/src/kitchen/routes/categories.js
index eccd3e1914ee3b03f5c3f4dd925acb1a5470fb26..0fc486563ecf6990f9d2454224af07994a8e9e9d 100644
--- a/backend/src/kitchen/routes/categories.js
+++ b/backend/src/kitchen/routes/categories.js
@@ -1,53 +1,45 @@
 import express from "express";
 import { Category } from "../models/Category.js";
 import { requireAuth } from "../middleware.js";
 import { getEffectiveHouseholdId, handleHouseholdError } from "../householdScope.js";
-import {
-  CATALOG_SCOPES,
-  clearHiddenMasterForHousehold,
-  hideMasterForHousehold,
-  isDiodUser,
-  resolveCatalogForHousehold
-} from "../utils/catalogScopes.js";
+import {
+  CATALOG_SCOPES,
+  clearHiddenMasterForHousehold,
+  hideMasterForHousehold,
+  isDiodUser,
+  resolveCatalogForHousehold
+} from "../utils/catalogScopes.js";
+import { slugifyCategory } from "../utils/categoryMatching.js";
 
 const router = express.Router();
 
 const DEFAULT_COLOR_BG = "#E8F1FF";
 const DEFAULT_COLOR_TEXT = "#1D4ED8";
 
 const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
 
-const slugifyCategory = (value = "") => {
-  const trimmed = value.trim().toLowerCase();
-  if (!trimmed) return "";
-
-  const noAccents = trimmed.normalize("NFD").replace(/\p{Diacritic}/gu, "");
-  const noPunctuation = noAccents.replace(/[^\w\s-]/g, "");
-  return noPunctuation.replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
-};
-
 router.get("/", requireAuth, async (req, res) => {
   try {
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const categories = await resolveCatalogForHousehold({
       Model: Category,
       householdId: effectiveHouseholdId,
       type: "category",
       masterFilter: { active: true },
       householdFilter: { active: true },
       overrideFilter: { active: true },
       sort: { order: 1, name: 1 }
     });
 
     return res.json({ ok: true, categories });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudieron cargar las categorías." });
   }
 });
 
 router.post("/", requireAuth, async (req, res) => {
   try {
     const { name, colorBg, colorText, scope } = req.body;
     if (!name) return res.status(400).json({ ok: false, error: "El nombre de la categoría es obligatorio." });
diff --git a/backend/src/kitchen/routes/dishes.js b/backend/src/kitchen/routes/dishes.js
index 2880e4bb040d15f841d7f2dd7a6ccec4152df096..6bacea4931cd11379b8e30bdaba9137e877f4ced 100644
--- a/backend/src/kitchen/routes/dishes.js
+++ b/backend/src/kitchen/routes/dishes.js
@@ -1,177 +1,233 @@
 import express from "express";
 import { KitchenDish } from "../models/KitchenDish.js";
 import { normalizeIngredientList } from "../utils/normalize.js";
-import { requireAuth } from "../middleware.js";
-import { buildScopedFilter, getEffectiveHouseholdId, handleHouseholdError } from "../householdScope.js";
-import {
-  CATALOG_SCOPES,
-  clearHiddenMasterForHousehold,
-  hideMasterForHousehold,
-  isDiodUser,
-  resolveCatalogForHousehold
-} from "../utils/catalogScopes.js";
+import { combineDayIngredients } from "../utils/ingredients.js";
+import { KitchenWeekPlan } from "../models/KitchenWeekPlan.js";
+import { KitchenShoppingList } from "../models/KitchenShoppingList.js";
+import { getWeekStart } from "../utils/dates.js";
+import { requireAuth } from "../middleware.js";
+import { buildScopedFilter, getEffectiveHouseholdId, handleHouseholdError } from "../householdScope.js";
+import {
+  CATALOG_SCOPES,
+  clearHiddenMasterForHousehold,
+  hideMasterForHousehold,
+  isDiodUser,
+  resolveCatalogForHousehold
+} from "../utils/catalogScopes.js";
 
 const router = express.Router();
 
+
+async function rebuildFutureShoppingLists({ householdId, dishId }) {
+  if (!householdId || !dishId) return;
+
+  const currentWeekStart = getWeekStart(new Date());
+  const plans = await KitchenWeekPlan.find({
+    householdId,
+    weekStart: { $gte: currentWeekStart },
+    $or: [{ "days.mainDishId": dishId }, { "days.sideDishId": dishId }]
+  });
+
+  for (const plan of plans) {
+    const dishIds = plan.days.flatMap((day) => [day.mainDishId, day.sideDishId]).filter(Boolean);
+    const dishes = await KitchenDish.find(buildScopedFilter(householdId, { _id: { $in: dishIds } }));
+    const dishMap = new Map(dishes.map((entry) => [String(entry._id), entry]));
+
+    const merged = new Map();
+    plan.days.forEach((day) => {
+      const ingredients = combineDayIngredients({
+        mainDish: day.mainDishId ? dishMap.get(String(day.mainDishId)) : null,
+        sideDish: day.sideDishId ? dishMap.get(String(day.sideDishId)) : null,
+        overrides: day.ingredientOverrides
+      });
+
+      ingredients.forEach((item) => {
+        if (!item.canonicalName || merged.has(item.canonicalName)) return;
+        merged.set(item.canonicalName, {
+          displayName: item.displayName,
+          canonicalName: item.canonicalName,
+          status: "need"
+        });
+      });
+    });
+
+    const list = await KitchenShoppingList.findOneAndUpdate(
+      { householdId, weekStart: plan.weekStart },
+      { $setOnInsert: { householdId, weekStart: plan.weekStart, items: [] } },
+      { new: true, upsert: true }
+    );
+
+    const previousByCanonical = new Map((list.items || []).map((item) => [item.canonicalName, item.status]));
+    list.items = Array.from(merged.values()).map((item) => ({
+      ...item,
+      status: previousByCanonical.get(item.canonicalName) || "need"
+    }));
+    await list.save();
+  }
+}
+
 router.get("/", requireAuth, async (req, res) => {
-  try {
-    const { sidedish } = req.query;
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-
-    if (sidedish === "true") {
-      const dishes = await resolveCatalogForHousehold({
-        Model: KitchenDish,
-        householdId: effectiveHouseholdId,
-        type: "side",
-        baseFilter: { sidedish: true },
-        sort: { createdAt: -1 }
-      });
-      return res.json({ ok: true, dishes });
-    }
-
-    const dishes = await KitchenDish.find(buildScopedFilter(effectiveHouseholdId, { sidedish: { $ne: true } })).sort({
-      createdAt: -1
-    });
-
-    res.json({ ok: true, dishes });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudieron cargar los platos." });
-  }
+  try {
+    const { sidedish } = req.query;
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+
+    if (sidedish === "true") {
+      const dishes = await resolveCatalogForHousehold({
+        Model: KitchenDish,
+        householdId: effectiveHouseholdId,
+        type: "side",
+        baseFilter: { sidedish: true },
+        sort: { createdAt: -1 }
+      });
+      return res.json({ ok: true, dishes });
+    }
+
+    const dishes = await KitchenDish.find(buildScopedFilter(effectiveHouseholdId, { sidedish: { $ne: true } })).sort({
+      createdAt: -1
+    });
+
+    res.json({ ok: true, dishes });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudieron cargar los platos." });
+  }
 });
 
 router.post("/", requireAuth, async (req, res) => {
   try {
-    const { name, ingredients, sidedish, scope } = req.body;
+    const { name, ingredients, sidedish, scope } = req.body;
     if (!name) return res.status(400).json({ ok: false, error: "El nombre del plato es obligatorio." });
 
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const normalizedIngredients = normalizeIngredientList(ingredients || []);
-    const isSideDish = Boolean(sidedish);
-    const isDiod = isDiodUser(req.kitchenUser);
-    const isMasterWrite = isSideDish && scope === CATALOG_SCOPES.MASTER;
-
-    if (isMasterWrite && !isDiod) {
-      return res.status(403).json({ ok: false, error: "Solo DIOD puede crear guarniciones master." });
-    }
-
+    const isSideDish = Boolean(sidedish);
+    const isDiod = isDiodUser(req.kitchenUser);
+    const isMasterWrite = isSideDish && scope === CATALOG_SCOPES.MASTER;
+
+    if (isMasterWrite && !isDiod) {
+      return res.status(403).json({ ok: false, error: "Solo DIOD puede crear guarniciones master." });
+    }
+
     const dish = await KitchenDish.create({
       name: String(name).trim(),
       ingredients: normalizedIngredients,
-      sidedish: isSideDish,
-      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
-      createdBy: req.kitchenUser._id,
-      householdId: isMasterWrite ? undefined : effectiveHouseholdId
+      sidedish: isSideDish,
+      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
+      createdBy: req.kitchenUser._id,
+      householdId: isMasterWrite ? undefined : effectiveHouseholdId
     });
 
-    if (isSideDish && !isMasterWrite) {
-      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "side", masterId: dish._id });
-    }
-
+    if (isSideDish && !isMasterWrite) {
+      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "side", masterId: dish._id });
+    }
+
     return res.status(201).json({ ok: true, dish });
   } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo guardar el plato." });
   }
 });
 
 router.put("/:id", requireAuth, async (req, res) => {
   try {
-    const { name, ingredients, sidedish } = req.body;
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const isDiod = isDiodUser(req.kitchenUser);
-    const dish = await KitchenDish.findById(req.params.id);
-    if (!dish || dish.isArchived) return res.status(404).json({ ok: false, error: "Plato no encontrado." });
-
-    const nextData = {};
-    if (name) nextData.name = String(name).trim();
-    if (Array.isArray(ingredients)) nextData.ingredients = normalizeIngredientList(ingredients);
-    if (typeof sidedish === "boolean") nextData.sidedish = sidedish;
-
-    if (dish.sidedish && dish.scope === CATALOG_SCOPES.MASTER) {
-      if (isDiod) {
-        Object.assign(dish, nextData);
-        await dish.save();
-        return res.json({ ok: true, dish });
-      }
-
-      const override = await KitchenDish.findOneAndUpdate(
-        {
-          householdId: effectiveHouseholdId,
-          scope: CATALOG_SCOPES.OVERRIDE,
-          masterId: dish._id
-        },
-        {
-          ...nextData,
-          scope: CATALOG_SCOPES.OVERRIDE,
-          masterId: dish._id,
-          householdId: effectiveHouseholdId,
-          sidedish: true,
-          isArchived: false
-        },
-        { upsert: true, new: true, setDefaultsOnInsert: true }
-      );
-      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "side", masterId: dish._id });
-      return res.json({ ok: true, dish: override, overridden: true });
-    }
-
-    if (!dish.householdId || String(dish.householdId) !== String(effectiveHouseholdId)) {
-      return res.status(403).json({ ok: false, error: "No tienes permisos para modificar este plato." });
-    }
-
-    Object.assign(dish, nextData);
+    const { name, ingredients, sidedish } = req.body;
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const isDiod = isDiodUser(req.kitchenUser);
+    const dish = await KitchenDish.findById(req.params.id);
+    if (!dish || dish.isArchived) return res.status(404).json({ ok: false, error: "Plato no encontrado." });
+
+    const nextData = {};
+    if (name) nextData.name = String(name).trim();
+    if (Array.isArray(ingredients)) nextData.ingredients = normalizeIngredientList(ingredients);
+    if (typeof sidedish === "boolean") nextData.sidedish = sidedish;
+
+    if (dish.sidedish && dish.scope === CATALOG_SCOPES.MASTER) {
+      if (isDiod) {
+        Object.assign(dish, nextData);
+        await dish.save();
+        await rebuildFutureShoppingLists({ householdId: effectiveHouseholdId, dishId: dish._id });
+        return res.json({ ok: true, dish });
+      }
+
+      const override = await KitchenDish.findOneAndUpdate(
+        {
+          householdId: effectiveHouseholdId,
+          scope: CATALOG_SCOPES.OVERRIDE,
+          masterId: dish._id
+        },
+        {
+          ...nextData,
+          scope: CATALOG_SCOPES.OVERRIDE,
+          masterId: dish._id,
+          householdId: effectiveHouseholdId,
+          sidedish: true,
+          isArchived: false
+        },
+        { upsert: true, new: true, setDefaultsOnInsert: true }
+      );
+      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "side", masterId: dish._id });
+      await rebuildFutureShoppingLists({ householdId: effectiveHouseholdId, dishId: override._id });
+      return res.json({ ok: true, dish: override, overridden: true });
+    }
+
+    if (!dish.householdId || String(dish.householdId) !== String(effectiveHouseholdId)) {
+      return res.status(403).json({ ok: false, error: "No tienes permisos para modificar este plato." });
+    }
+
+    Object.assign(dish, nextData);
     await dish.save();
+    await rebuildFutureShoppingLists({ householdId: effectiveHouseholdId, dishId: dish._id });
     return res.json({ ok: true, dish });
   } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo actualizar el plato." });
   }
 });
 
-router.delete("/:id", requireAuth, async (req, res) => {
-  try {
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const isDiod = isDiodUser(req.kitchenUser);
-    const dish = await KitchenDish.findById(req.params.id);
-    if (!dish || dish.isArchived) return res.status(404).json({ ok: false, error: "Plato no encontrado." });
-
-    if (dish.sidedish && dish.scope === CATALOG_SCOPES.MASTER) {
-      if (isDiod) {
-        dish.isArchived = true;
-        await dish.save();
-      } else {
-        await hideMasterForHousehold({ householdId: effectiveHouseholdId, type: "side", masterId: dish._id });
-      }
-      return res.json({ ok: true });
-    }
-
-    if (dish.sidedish) {
-      if (!dish.householdId || String(dish.householdId) !== String(effectiveHouseholdId)) {
-        return res.status(403).json({ ok: false, error: "No tienes permisos para eliminar esta guarnición." });
-      }
-      dish.isArchived = true;
-      await dish.save();
-      return res.json({ ok: true });
-    }
-
-    if (!isDiod && !["admin", "owner"].includes(req.kitchenUser.role)) {
-      return res.status(403).json({ ok: false, error: "No tienes permisos para esta acción." });
-    }
-
-    if (!dish.householdId || String(dish.householdId) !== String(effectiveHouseholdId)) {
-      return res.status(403).json({ ok: false, error: "No tienes permisos para eliminar este plato." });
-    }
-
-    await dish.deleteOne();
-    return res.json({ ok: true });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo eliminar el plato." });
-  }
+router.delete("/:id", requireAuth, async (req, res) => {
+  try {
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const isDiod = isDiodUser(req.kitchenUser);
+    const dish = await KitchenDish.findById(req.params.id);
+    if (!dish || dish.isArchived) return res.status(404).json({ ok: false, error: "Plato no encontrado." });
+
+    if (dish.sidedish && dish.scope === CATALOG_SCOPES.MASTER) {
+      if (isDiod) {
+        dish.isArchived = true;
+        await dish.save();
+      } else {
+        await hideMasterForHousehold({ householdId: effectiveHouseholdId, type: "side", masterId: dish._id });
+      }
+      return res.json({ ok: true });
+    }
+
+    if (dish.sidedish) {
+      if (!dish.householdId || String(dish.householdId) !== String(effectiveHouseholdId)) {
+        return res.status(403).json({ ok: false, error: "No tienes permisos para eliminar esta guarnición." });
+      }
+      dish.isArchived = true;
+      await dish.save();
+      return res.json({ ok: true });
+    }
+
+    if (!isDiod && !["admin", "owner"].includes(req.kitchenUser.role)) {
+      return res.status(403).json({ ok: false, error: "No tienes permisos para esta acción." });
+    }
+
+    if (!dish.householdId || String(dish.householdId) !== String(effectiveHouseholdId)) {
+      return res.status(403).json({ ok: false, error: "No tienes permisos para eliminar este plato." });
+    }
+
+    await dish.deleteOne();
+    return res.json({ ok: true });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo eliminar el plato." });
+  }
 });
 
 export default router;
diff --git a/backend/src/kitchen/routes/kitchenIngredients.js b/backend/src/kitchen/routes/kitchenIngredients.js
index 7857f618816114ed5425345ee90a2ee23361fc3e..6f2aeead7f293230614a02a91a0f297fd99248bc 100644
--- a/backend/src/kitchen/routes/kitchenIngredients.js
+++ b/backend/src/kitchen/routes/kitchenIngredients.js
@@ -1,279 +1,333 @@
 import express from "express";
 import { KitchenIngredient } from "../models/KitchenIngredient.js";
-import { Category } from "../models/Category.js";
+import { Category } from "../models/Category.js";
 import { requireAuth } from "../middleware.js";
 import { normalizeIngredientName } from "../utils/normalize.js";
-import { getEffectiveHouseholdId, handleHouseholdError } from "../householdScope.js";
-import {
-  CATALOG_SCOPES,
-  clearHiddenMasterForHousehold,
-  hideMasterForHousehold,
-  isDiodUser,
-  resolveCatalogForHousehold
-} from "../utils/catalogScopes.js";
+import { getEffectiveHouseholdId, handleHouseholdError } from "../householdScope.js";
+import {
+  CATALOG_SCOPES,
+  clearHiddenMasterForHousehold,
+  hideMasterForHousehold,
+  isDiodUser,
+  resolveCatalogForHousehold
+} from "../utils/catalogScopes.js";
+import { ensureDefaultCategory } from "../utils/categoryMatching.js";
+import { KitchenDish } from "../models/KitchenDish.js";
+import { KitchenWeekPlan } from "../models/KitchenWeekPlan.js";
+import { getWeekStart } from "../utils/dates.js";
 
 const router = express.Router();
 const MAX_RESULTS = 15;
 const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
-const ACCENT_CHAR_MAP = {
-  a: "aàáâäãå",
-  e: "eèéêë",
-  i: "iìíîï",
-  o: "oòóôöõ",
-  u: "uùúûü",
-  n: "nñ",
-  c: "cç"
-};
-
-const buildAccentInsensitiveRegex = (value) => {
-  const escaped = escapeRegex(value);
-  const pattern = escaped
-    .split("")
-    .map((char) => {
-      const lower = char.toLowerCase();
-      if (ACCENT_CHAR_MAP[lower]) {
-        return `[${ACCENT_CHAR_MAP[lower]}]`;
-      }
-      return char;
-    })
-    .join("");
-  return new RegExp(pattern, "i");
-};
-
-async function ensureCategoryScope({ categoryId, effectiveHouseholdId }) {
-  if (!categoryId) return null;
-  const category = await Category.findOne({
-    _id: categoryId,
-    isArchived: { $ne: true },
-    $or: [{ scope: CATALOG_SCOPES.MASTER }, { householdId: effectiveHouseholdId }]
-  });
-
-  return category;
-}
-
-function buildSearchFilter(q) {
-  if (!q) return {};
-
-  const trimmed = String(q).trim();
-  const normalized = normalizeIngredientName(trimmed);
-  const normalizedRegex = normalized ? new RegExp(escapeRegex(normalized), "i") : null;
-  const normalizedFallback =
-    normalized && normalized.length > 4 ? new RegExp(escapeRegex(normalized.slice(0, -1)), "i") : null;
-  const nameRegex = trimmed ? buildAccentInsensitiveRegex(trimmed) : null;
-  const orFilters = [];
-  if (normalizedRegex) orFilters.push({ canonicalName: normalizedRegex });
-  if (normalizedFallback) orFilters.push({ canonicalName: normalizedFallback });
-  if (nameRegex) orFilters.push({ name: nameRegex });
-  if (!orFilters.length) return {};
-
-  return { $or: orFilters };
-}
+const ACCENT_CHAR_MAP = {
+  a: "aàáâäãå",
+  e: "eèéêë",
+  i: "iìíîï",
+  o: "oòóôöõ",
+  u: "uùúûü",
+  n: "nñ",
+  c: "cç"
+};
+
+const buildAccentInsensitiveRegex = (value) => {
+  const escaped = escapeRegex(value);
+  const pattern = escaped
+    .split("")
+    .map((char) => {
+      const lower = char.toLowerCase();
+      if (ACCENT_CHAR_MAP[lower]) {
+        return `[${ACCENT_CHAR_MAP[lower]}]`;
+      }
+      return char;
+    })
+    .join("");
+  return new RegExp(pattern, "i");
+};
+
+async function ensureCategoryScope({ categoryId, effectiveHouseholdId }) {
+  if (!categoryId) {
+    return ensureDefaultCategory({ Category, householdId: effectiveHouseholdId });
+  }
+  const category = await Category.findOne({
+    _id: categoryId,
+    isArchived: { $ne: true },
+    $or: [{ scope: CATALOG_SCOPES.MASTER }, { householdId: effectiveHouseholdId }]
+  });
+
+  return category;
+}
+
+async function syncIngredientReferences({ ingredientId, name, canonicalName, householdId }) {
+  const dishFilter = {
+    "ingredients.ingredientId": ingredientId,
+    isArchived: { $ne: true }
+  };
+
+  if (householdId) {
+    dishFilter.$or = [
+      { scope: CATALOG_SCOPES.MASTER },
+      { householdId },
+      { scope: CATALOG_SCOPES.OVERRIDE, householdId }
+    ];
+  }
+
+  await KitchenDish.updateMany(
+    dishFilter,
+    {
+      $set: {
+        "ingredients.$[entry].displayName": name,
+        "ingredients.$[entry].canonicalName": canonicalName
+      }
+    },
+    {
+      arrayFilters: [{ "entry.ingredientId": ingredientId }]
+    }
+  );
+
+  const todayWeekStart = getWeekStart(new Date());
+  const weekFilter = {
+    weekStart: { $gte: todayWeekStart },
+    "days.ingredientOverrides.ingredientId": ingredientId
+  };
+  if (householdId) weekFilter.householdId = householdId;
+
+  await KitchenWeekPlan.updateMany(
+    weekFilter,
+    {
+      $set: {
+        "days.$[].ingredientOverrides.$[entry].displayName": name,
+        "days.$[].ingredientOverrides.$[entry].canonicalName": canonicalName
+      }
+    },
+    {
+      arrayFilters: [{ "entry.ingredientId": ingredientId }]
+    }
+  );
+}
+
+function buildSearchFilter(q) {
+  if (!q) return {};
+
+  const trimmed = String(q).trim();
+  const normalized = normalizeIngredientName(trimmed);
+  const normalizedRegex = normalized ? new RegExp(escapeRegex(normalized), "i") : null;
+  const normalizedFallback =
+    normalized && normalized.length > 4 ? new RegExp(escapeRegex(normalized.slice(0, -1)), "i") : null;
+  const nameRegex = trimmed ? buildAccentInsensitiveRegex(trimmed) : null;
+  const orFilters = [];
+  if (normalizedRegex) orFilters.push({ canonicalName: normalizedRegex });
+  if (normalizedFallback) orFilters.push({ canonicalName: normalizedFallback });
+  if (nameRegex) orFilters.push({ name: nameRegex });
+  if (!orFilters.length) return {};
+
+  return { $or: orFilters };
+}
 
 router.get("/", requireAuth, async (req, res) => {
-  try {
-    const { q, includeInactive, limit } = req.query;
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const shouldIncludeInactive = String(includeInactive || "").toLowerCase() === "true";
-
-    const ingredients = await resolveCatalogForHousehold({
-      Model: KitchenIngredient,
-      householdId: effectiveHouseholdId,
-      type: "ingredient",
-      baseFilter: buildSearchFilter(q),
-      masterFilter: shouldIncludeInactive ? {} : { active: true },
-      householdFilter: shouldIncludeInactive ? {} : { active: true },
-      overrideFilter: shouldIncludeInactive ? {} : { active: true },
-      populate: { path: "categoryId", select: "name colorBg colorText" },
-      sort: { name: 1 }
-    });
-
-    const limitValue = Number.parseInt(limit, 10);
-    const resolvedIngredients =
-      !Number.isNaN(limitValue) && limitValue > 0
-        ? ingredients.slice(0, limitValue)
-        : !limit
-          ? ingredients.slice(0, MAX_RESULTS)
-          : ingredients;
-
-    return res.json({ ok: true, ingredients: resolvedIngredients });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudieron cargar los ingredientes." });
-  }
+  try {
+    const { q, includeInactive, limit } = req.query;
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const shouldIncludeInactive = String(includeInactive || "").toLowerCase() === "true";
+
+    const ingredients = await resolveCatalogForHousehold({
+      Model: KitchenIngredient,
+      householdId: effectiveHouseholdId,
+      type: "ingredient",
+      baseFilter: buildSearchFilter(q),
+      masterFilter: shouldIncludeInactive ? {} : { active: true },
+      householdFilter: shouldIncludeInactive ? {} : { active: true },
+      overrideFilter: shouldIncludeInactive ? {} : { active: true },
+      populate: { path: "categoryId", select: "name slug colorBg colorText" },
+      sort: { name: 1 }
+    });
+
+    const limitValue = Number.parseInt(limit, 10);
+    const resolvedIngredients =
+      !Number.isNaN(limitValue) && limitValue > 0
+        ? ingredients.slice(0, limitValue)
+        : !limit
+          ? ingredients.slice(0, MAX_RESULTS)
+          : ingredients;
+
+    return res.json({ ok: true, ingredients: resolvedIngredients });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudieron cargar los ingredientes." });
+  }
 });
 
 router.post("/", requireAuth, async (req, res) => {
   try {
-    const { name, categoryId, canonicalName: canonicalInput, scope } = req.body;
+    const { name, categoryId, canonicalName: canonicalInput, scope } = req.body;
     if (!name) return res.status(400).json({ ok: false, error: "El nombre del ingrediente es obligatorio." });
-    if (!categoryId)
-      return res.status(400).json({ ok: false, error: "Selecciona una categoría para el ingrediente." });
-
-    const isDiod = isDiodUser(req.kitchenUser);
-    const isMasterWrite = scope === CATALOG_SCOPES.MASTER;
-    if (isMasterWrite && !isDiod) {
-      return res.status(403).json({ ok: false, error: "Solo DIOD puede crear ingredientes master." });
-    }
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const category = await ensureCategoryScope({ categoryId, effectiveHouseholdId });
-    if (!category) {
-      return res.status(404).json({ ok: false, error: "Categoría no encontrada para el hogar actual." });
-    }
-
+
+    const isDiod = isDiodUser(req.kitchenUser);
+    const isMasterWrite = scope === CATALOG_SCOPES.MASTER;
+    if (isMasterWrite && !isDiod) {
+      return res.status(403).json({ ok: false, error: "Solo DIOD puede crear ingredientes master." });
+    }
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const category = await ensureCategoryScope({ categoryId, effectiveHouseholdId });
+    if (!category) {
+      return res.status(404).json({ ok: false, error: "Categoría no encontrada para el hogar actual." });
+    }
+
     const trimmedName = String(name).trim();
-    const canonicalName = normalizeIngredientName(canonicalInput || trimmedName);
+    const canonicalName = normalizeIngredientName(canonicalInput || trimmedName);
     if (!canonicalName)
       return res.status(400).json({ ok: false, error: "El nombre del ingrediente no es válido." });
 
-    const duplicateFilter = {
-      canonicalName: new RegExp(`^${escapeRegex(canonicalName)}$`, "i"),
-      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
-      isArchived: { $ne: true }
-    };
-    if (!isMasterWrite) duplicateFilter.householdId = effectiveHouseholdId;
-
-    const existing = await KitchenIngredient.findOne(duplicateFilter).populate("categoryId", "name colorBg colorText");
+    const duplicateFilter = {
+      canonicalName: new RegExp(`^${escapeRegex(canonicalName)}$`, "i"),
+      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
+      isArchived: { $ne: true }
+    };
+    if (!isMasterWrite) duplicateFilter.householdId = effectiveHouseholdId;
+
+    const existing = await KitchenIngredient.findOne(duplicateFilter).populate("categoryId", "name slug colorBg colorText");
 
     if (existing) return res.json({ ok: true, ingredient: existing, created: false });
 
     const ingredient = await KitchenIngredient.create({
       name: trimmedName,
       canonicalName,
-      categoryId,
-      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
-      householdId: isMasterWrite ? undefined : effectiveHouseholdId
+      categoryId: category._id,
+      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
+      householdId: isMasterWrite ? undefined : effectiveHouseholdId
     });
 
     const populatedIngredient = await KitchenIngredient.findById(ingredient._id).populate(
       "categoryId",
-      "name colorBg colorText"
+      "name slug colorBg colorText"
     );
 
-    if (!isMasterWrite) {
-      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "ingredient", masterId: ingredient._id });
-    }
-
+    if (!isMasterWrite) {
+      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "ingredient", masterId: ingredient._id });
+    }
+
     return res.status(201).json({ ok: true, ingredient: populatedIngredient, created: true });
   } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo crear el ingrediente." });
   }
 });
 
-router.put("/:id", requireAuth, async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { name, categoryId, active, canonicalName: canonicalInput } = req.body;
-    if (!name) return res.status(400).json({ ok: false, error: "El nombre del ingrediente es obligatorio." });
-    if (!categoryId)
-      return res.status(400).json({ ok: false, error: "Selecciona una categoría para el ingrediente." });
-    if (typeof active !== "boolean")
-      return res.status(400).json({ ok: false, error: "Indica si el ingrediente está activo." });
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const isDiod = isDiodUser(req.kitchenUser);
-    const category = await ensureCategoryScope({ categoryId, effectiveHouseholdId });
-    if (!category) {
-      return res.status(404).json({ ok: false, error: "Categoría no encontrada para el hogar actual." });
-    }
-
-    const trimmedName = String(name).trim();
-    const canonicalName = normalizeIngredientName(canonicalInput || trimmedName);
-    if (!canonicalName)
-      return res.status(400).json({ ok: false, error: "El nombre del ingrediente no es válido." });
-
-    const target = await KitchenIngredient.findById(id);
-    if (!target || target.isArchived) {
-      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
-    }
-
-    const nextData = {
-      name: trimmedName,
-      canonicalName,
-      categoryId,
-      active
-    };
-
-    if (target.scope === CATALOG_SCOPES.MASTER) {
-      if (isDiod) {
-        Object.assign(target, nextData);
-        await target.save();
-        const ingredient = await KitchenIngredient.findById(target._id).populate("categoryId", "name colorBg colorText");
-        return res.json({ ok: true, ingredient });
-      }
-
-      const ingredient = await KitchenIngredient.findOneAndUpdate(
-        {
-          householdId: effectiveHouseholdId,
-          scope: CATALOG_SCOPES.OVERRIDE,
-          masterId: target._id
-        },
-        {
-          ...nextData,
-          householdId: effectiveHouseholdId,
-          scope: CATALOG_SCOPES.OVERRIDE,
-          masterId: target._id,
-          isArchived: false
-        },
-        { upsert: true, new: true, setDefaultsOnInsert: true }
-      ).populate("categoryId", "name colorBg colorText");
-
-      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "ingredient", masterId: target._id });
-      return res.json({ ok: true, ingredient, overridden: true });
-    }
-
-    if (!target.householdId || String(target.householdId) !== String(effectiveHouseholdId)) {
-      return res.status(403).json({ ok: false, error: "No tienes permisos para modificar este ingrediente." });
-    }
-
-    Object.assign(target, nextData);
-    await target.save();
-    const ingredient = await KitchenIngredient.findById(target._id).populate("categoryId", "name colorBg colorText");
-
-    return res.json({ ok: true, ingredient });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo actualizar el ingrediente." });
-  }
-});
-
-router.delete("/:id", requireAuth, async (req, res) => {
-  try {
-    const { id } = req.params;
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const isDiod = isDiodUser(req.kitchenUser);
-    const target = await KitchenIngredient.findById(id);
-
-    if (!target || target.isArchived) {
-      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
-    }
-
-    if (target.scope === CATALOG_SCOPES.MASTER) {
-      if (isDiod) {
-        target.isArchived = true;
-        await target.save();
-      } else {
-        await hideMasterForHousehold({ householdId: effectiveHouseholdId, type: "ingredient", masterId: target._id });
-      }
-      return res.json({ ok: true });
-    }
-
-    if (!target.householdId || String(target.householdId) !== String(effectiveHouseholdId)) {
-      return res.status(403).json({ ok: false, error: "No tienes permisos para eliminar este ingrediente." });
-    }
-
-    target.isArchived = true;
-    await target.save();
-    return res.json({ ok: true });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo eliminar el ingrediente." });
-  }
-});
-
+router.put("/:id", requireAuth, async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { name, categoryId, active, canonicalName: canonicalInput } = req.body;
+    if (!name) return res.status(400).json({ ok: false, error: "El nombre del ingrediente es obligatorio." });
+    if (typeof active !== "boolean")
+      return res.status(400).json({ ok: false, error: "Indica si el ingrediente está activo." });
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const isDiod = isDiodUser(req.kitchenUser);
+    const category = await ensureCategoryScope({ categoryId, effectiveHouseholdId });
+    if (!category) {
+      return res.status(404).json({ ok: false, error: "Categoría no encontrada para el hogar actual." });
+    }
+
+    const trimmedName = String(name).trim();
+    const canonicalName = normalizeIngredientName(canonicalInput || trimmedName);
+    if (!canonicalName)
+      return res.status(400).json({ ok: false, error: "El nombre del ingrediente no es válido." });
+
+    const target = await KitchenIngredient.findById(id);
+    if (!target || target.isArchived) {
+      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
+    }
+
+    const nextData = {
+      name: trimmedName,
+      canonicalName,
+      categoryId: category._id,
+      active
+    };
+
+    if (target.scope === CATALOG_SCOPES.MASTER) {
+      if (isDiod) {
+        Object.assign(target, nextData);
+        await target.save();
+        await syncIngredientReferences({ ingredientId: target._id, name: trimmedName, canonicalName, householdId: effectiveHouseholdId });
+        const ingredient = await KitchenIngredient.findById(target._id).populate("categoryId", "name slug colorBg colorText");
+        return res.json({ ok: true, ingredient });
+      }
+
+      const ingredient = await KitchenIngredient.findOneAndUpdate(
+        {
+          householdId: effectiveHouseholdId,
+          scope: CATALOG_SCOPES.OVERRIDE,
+          masterId: target._id
+        },
+        {
+          ...nextData,
+          householdId: effectiveHouseholdId,
+          scope: CATALOG_SCOPES.OVERRIDE,
+          masterId: target._id,
+          isArchived: false
+        },
+        { upsert: true, new: true, setDefaultsOnInsert: true }
+      ).populate("categoryId", "name slug colorBg colorText");
+
+      await syncIngredientReferences({ ingredientId: ingredient._id, name: trimmedName, canonicalName, householdId: effectiveHouseholdId });
+
+      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "ingredient", masterId: target._id });
+      return res.json({ ok: true, ingredient, overridden: true });
+    }
+
+    if (!target.householdId || String(target.householdId) !== String(effectiveHouseholdId)) {
+      return res.status(403).json({ ok: false, error: "No tienes permisos para modificar este ingrediente." });
+    }
+
+    Object.assign(target, nextData);
+    await target.save();
+    await syncIngredientReferences({ ingredientId: target._id, name: trimmedName, canonicalName, householdId: effectiveHouseholdId });
+    const ingredient = await KitchenIngredient.findById(target._id).populate("categoryId", "name slug colorBg colorText");
+
+    return res.json({ ok: true, ingredient });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar el ingrediente." });
+  }
+});
+
+router.delete("/:id", requireAuth, async (req, res) => {
+  try {
+    const { id } = req.params;
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const isDiod = isDiodUser(req.kitchenUser);
+    const target = await KitchenIngredient.findById(id);
+
+    if (!target || target.isArchived) {
+      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
+    }
+
+    if (target.scope === CATALOG_SCOPES.MASTER) {
+      if (isDiod) {
+        target.isArchived = true;
+        await target.save();
+      } else {
+        await hideMasterForHousehold({ householdId: effectiveHouseholdId, type: "ingredient", masterId: target._id });
+      }
+      return res.json({ ok: true });
+    }
+
+    if (!target.householdId || String(target.householdId) !== String(effectiveHouseholdId)) {
+      return res.status(403).json({ ok: false, error: "No tienes permisos para eliminar este ingrediente." });
+    }
+
+    target.isArchived = true;
+    await target.save();
+    return res.json({ ok: true });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo eliminar el ingrediente." });
+  }
+});
+
 export default router;
