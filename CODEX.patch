diff --git a/backend/package.json b/backend/package.json
index 4b130d6f5fb0aa8b3c91b885c9907fd644c07cf5..e45a76b96154ac4a08fb13bae76ccda49c8bef5d 100644
--- a/backend/package.json
+++ b/backend/package.json
@@ -1,25 +1,26 @@
 {
   "name": "pilot-backend",
   "version": "1.0.0",
   "type": "module",
   "main": "src/index.js",
   "scripts": {
     "start": "node src/index.js",
     "dev": "node --watch src/index.js",
     "migrate:households": "node scripts/migrate-households.js",
     "create:diod": "node scripts/create-diod.js",
-    "test:connection": "node scripts/test-connection.js",
-    "migrate:householdId": "node scripts/migrate-add-householdId.js",
-    "migrate:ingredientCategoryId": "node scripts/migrate-ingredient-category-id.js",
-    "repair:shoppingItems": "node scripts/repair-shopping-list-items.js"
+    "test:connection": "node scripts/test-connection.js",
+    "migrate:householdId": "node scripts/migrate-add-householdId.js",
+    "migrate:ingredientCategoryId": "node scripts/migrate-ingredient-category-id.js",
+    "repair:shoppingItems": "node scripts/repair-shopping-list-items.js",
+    "migrate:removeShoppingTripAmount": "node scripts/migrate-remove-shopping-trip-amount.js"
   },
   "dependencies": {
     "bcryptjs": "^2.4.3",
     "cors": "^2.8.5",
     "dotenv": "^16.4.5",
     "express": "^4.19.2",
     "jsonwebtoken": "^9.0.2",
     "mongoose": "^8.6.1",
     "nodemailer": "^6.9.14"
   }
 }
diff --git a/backend/src/kitchen/models/ShoppingTrip.js b/backend/src/kitchen/models/ShoppingTrip.js
index cfae590ace87789c1218bd7646ec33a730d573b9..ac5636e70ad38951fcb09762fca1f4465583faf1 100644
--- a/backend/src/kitchen/models/ShoppingTrip.js
+++ b/backend/src/kitchen/models/ShoppingTrip.js
@@ -1,19 +1,17 @@
 import mongoose from "mongoose";
 
 const ShoppingTripSchema = new mongoose.Schema(
   {
     householdId: { type: mongoose.Schema.Types.ObjectId, ref: "Household", index: true, required: true },
     storeId: { type: mongoose.Schema.Types.ObjectId, ref: "Store", default: null },
-    totalAmount: { type: Number, default: null },
-    currency: { type: String, default: "EUR" },
     startedAt: { type: Date, default: Date.now },
     closedAt: { type: Date, default: null },
     createdBy: { type: mongoose.Schema.Types.ObjectId, ref: "KitchenUser", required: true },
     notes: { type: String, default: "" }
   },
   { timestamps: true }
 );
 
 ShoppingTripSchema.index({ householdId: 1, closedAt: 1, startedAt: -1 });
 
 export const ShoppingTrip = mongoose.model("ShoppingTrip", ShoppingTripSchema, "shoppingTrips");
diff --git a/backend/src/kitchen/routes/shopping.js b/backend/src/kitchen/routes/shopping.js
index 7738e7ef4033f8a212016bf00301900a3d8fd9bb..63c6bddd6b0a2ae982c7566eff0aeae2bec5d68c 100644
--- a/backend/src/kitchen/routes/shopping.js
+++ b/backend/src/kitchen/routes/shopping.js
@@ -1,90 +1,102 @@
 import express from "express";
 import { Category } from "../models/Category.js";
 import { Store } from "../models/Store.js";
 import { KitchenUser } from "../models/KitchenUser.js";
 import { requireAuth, requireDiod } from "../middleware.js";
 import { formatDateISO, getWeekStart, parseISODate } from "../utils/dates.js";
 import {
   buildScopedFilter,
   getEffectiveHouseholdId,
   handleHouseholdError
 } from "../householdScope.js";
 import { ensureShoppingList, rebuildShoppingList, resolveShoppingItemIngredientData } from "../shoppingService.js";
+import { CATALOG_SCOPES } from "../utils/catalogScopes.js";
 import {
   DEFAULT_CATEGORY_COLOR_BG,
   DEFAULT_CATEGORY_COLOR_TEXT,
   DEFAULT_CATEGORY_NAME,
   DEFAULT_CATEGORY_SLUG,
   ensureDefaultCategory
 } from "../utils/categoryMatching.js";
 
 const router = express.Router();
 
 function normalizeStoreName(value = "") {
   return String(value).trim().toLowerCase();
 }
 
 function sortStores(stores = []) {
   return [...stores].sort((a, b) => {
     const orderA = Number.isFinite(a.order) ? a.order : Number.POSITIVE_INFINITY;
     const orderB = Number.isFinite(b.order) ? b.order : Number.POSITIVE_INFINITY;
     if (orderA !== orderB) return orderA - orderB;
     return String(a.name || "").localeCompare(String(b.name || ""), "es", { sensitivity: "base" });
   });
 }
 
 function buildStoreVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
   return {
     ...extraFilter,
     $or: [
       { scope: "master", householdId: null },
       { scope: "household", householdId: effectiveHouseholdId }
     ]
   };
 }
 
+function buildCategoryVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
+  return {
+    ...extraFilter,
+    $or: [
+      { scope: CATALOG_SCOPES.MASTER, householdId: null },
+      { scope: CATALOG_SCOPES.HOUSEHOLD, householdId: effectiveHouseholdId },
+      { scope: CATALOG_SCOPES.OVERRIDE, householdId: effectiveHouseholdId }
+    ]
+  };
+}
+
 function toDateGroup(value) {
   if (!value) return "sin-fecha";
   return new Date(value).toISOString().slice(0, 10);
 }
 
 async function getShoppingPayload(weekStartDate, effectiveHouseholdId) {
   const list = await ensureShoppingList(weekStartDate, effectiveHouseholdId);
 
   const resolved = await resolveShoppingItemIngredientData(list.items.map((item) => item.toObject()), effectiveHouseholdId);
   if (resolved.changed) {
     list.items = resolved.resolvedItems;
     await list.save();
   }
 
   const fallbackCategory = await ensureDefaultCategory({
     Category,
     householdId: effectiveHouseholdId
   });
 
-  const categories = await Category.find(buildScopedFilter(effectiveHouseholdId, {})).select(
+  const categories = await Category.find(buildCategoryVisibilityFilter(effectiveHouseholdId, { isArchived: { $ne: true } })).select(
     "_id name slug colorBg colorText"
   );
   const stores = sortStores(
     await Store.find(buildStoreVisibilityFilter(effectiveHouseholdId, { active: true }))
       .select("_id name order scope householdId")
       .lean()
   );
 
   const storeById = new Map(stores.map((store) => [String(store._id), store.name]));
   const categoryById = new Map(categories.map((category) => [String(category._id), category]));
   const purchaserIds = list.items
     .filter((item) => item.purchasedBy)
     .map((item) => String(item.purchasedBy));
   const purchasers = purchaserIds.length
     ? await KitchenUser.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: purchaserIds } })).select("_id displayName")
     : [];
   const purchaserById = new Map(purchasers.map((person) => [String(person._id), person.displayName]));
 
   const pendingByCategory = list.items
     .filter((item) => item.status === "pending")
     .reduce((acc, item) => {
       const key = item.categoryId ? String(item.categoryId) : "uncategorized";
       const resolvedCategory = item.categoryId
         ? categoryById.get(String(item.categoryId)) || null
         : fallbackCategory || null;
@@ -118,50 +130,58 @@ async function getShoppingPayload(weekStartDate, effectiveHouseholdId) {
         acc.set(key, {
           storeId: item.storeId || null,
           storeName: item.storeId ? storeById.get(String(item.storeId)) || "Supermercado" : "Sin supermercado",
           purchasedDate: dateKey,
           startedAt: item.purchasedAt,
           items: []
         });
       }
       acc.get(key).items.push({
         ...item.toObject(),
         purchasedByName: item.purchasedBy ? purchaserById.get(String(item.purchasedBy)) || "Usuario" : null
       });
       return acc;
     }, new Map());
 
   return {
     list,
     stores,
     pendingByCategory: Array.from(pendingByCategory.values()),
     purchasedByStoreDay: Array.from(purchasedByStoreDay.values()).sort(
       (a, b) => new Date(b.startedAt || 0).getTime() - new Date(a.startedAt || 0).getTime()
     )
   };
 }
 
+async function validateStoreSelection(storeId, effectiveHouseholdId) {
+  if (!storeId) return null;
+  const store = await Store.findOne(buildStoreVisibilityFilter(effectiveHouseholdId, { _id: storeId, active: true }))
+    .select("_id")
+    .lean();
+  return store ? store._id : null;
+}
+
 router.get("/:weekStart", requireAuth, async (req, res) => {
   try {
     const weekStart = parseISODate(req.params.weekStart);
     if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
 
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const monday = getWeekStart(weekStart);
     const payload = await getShoppingPayload(monday, effectiveHouseholdId);
 
     res.json({ ok: true, weekStart: formatDateISO(monday), ...payload });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo cargar la lista de compra." });
   }
 });
 
 router.post("/:weekStart/rebuild", requireAuth, async (req, res) => {
   try {
     const weekStart = parseISODate(req.params.weekStart);
     if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
 
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const monday = getWeekStart(weekStart);
     await rebuildShoppingList(monday, effectiveHouseholdId);
@@ -177,120 +197,122 @@ router.post("/:weekStart/rebuild", requireAuth, async (req, res) => {
 
 router.put("/:weekStart/item", requireAuth, async (req, res) => {
   try {
     const weekStart = parseISODate(req.params.weekStart);
     if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
 
     const { canonicalName, status, ingredientId, storeId } = req.body;
     if (!canonicalName && !ingredientId) {
       return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
     }
 
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const monday = getWeekStart(weekStart);
     const list = await ensureShoppingList(monday, effectiveHouseholdId);
 
     const item = list.items.find((current) => {
       if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
       return current.canonicalName === canonicalName;
     });
 
     if (!item) return res.status(404).json({ ok: false, error: "Ingrediente no encontrado en la lista." });
 
     const normalizedStatus = status === "purchased" ? "purchased" : "pending";
     item.status = normalizedStatus;
     if (normalizedStatus === "purchased") {
+      const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
       item.purchasedBy = req.kitchenUser._id;
       item.purchasedAt = new Date();
-      item.storeId = storeId || null;
+      item.storeId = validatedStoreId;
     } else {
       item.purchasedBy = null;
       item.purchasedAt = null;
       item.storeId = null;
     }
 
     await list.save();
     const payload = await getShoppingPayload(monday, effectiveHouseholdId);
     res.json({ ok: true, ...payload });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo actualizar la lista de compra." });
   }
 });
 
 router.put("/:weekStart/item/store", requireAuth, async (req, res) => {
   try {
     const weekStart = parseISODate(req.params.weekStart);
     if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
 
     const { canonicalName, ingredientId, storeId } = req.body;
     if (!canonicalName && !ingredientId) {
       return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
     }
 
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const monday = getWeekStart(weekStart);
     const list = await ensureShoppingList(monday, effectiveHouseholdId);
 
     const item = list.items.find((current) => {
       if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
       return current.canonicalName === canonicalName;
     });
 
     if (!item || item.status !== "purchased") {
       return res.status(404).json({ ok: false, error: "Ingrediente comprado no encontrado." });
     }
 
-    item.storeId = storeId || null;
+    item.storeId = await validateStoreSelection(storeId, effectiveHouseholdId);
     await list.save();
 
     const payload = await getShoppingPayload(monday, effectiveHouseholdId);
     return res.json({ ok: true, ...payload });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo actualizar el supermercado." });
   }
 });
 
 router.post("/:weekStart/purchased/assign-store", requireAuth, async (req, res) => {
   try {
     const weekStart = parseISODate(req.params.weekStart);
     if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
 
     const { storeId } = req.body;
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const monday = getWeekStart(weekStart);
     const list = await ensureShoppingList(monday, effectiveHouseholdId);
+    const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
 
     const today = new Date().toISOString().slice(0, 10);
     let changed = false;
     for (const item of list.items) {
       if (item.status !== "purchased" || item.storeId || !item.purchasedAt) continue;
       if (toDateGroup(item.purchasedAt) !== today) continue;
-      item.storeId = storeId || null;
+      item.storeId = validatedStoreId;
       changed = true;
     }
 
     if (changed) await list.save();
 
     const payload = await getShoppingPayload(monday, effectiveHouseholdId);
     return res.json({ ok: true, updated: changed, ...payload });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo asignar el supermercado." });
   }
 });
 
 router.post("/stores", requireAuth, async (req, res) => {
   try {
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const name = String(req.body?.name || "").trim();
     if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
     const canonicalName = normalizeStoreName(name);
 
     const store = await Store.findOneAndUpdate(
       { scope: "household", householdId: effectiveHouseholdId, canonicalName },
       { $setOnInsert: { scope: "household", householdId: effectiveHouseholdId, name, canonicalName } },
       { new: true, upsert: true }
diff --git a/backend/src/kitchen/shoppingService.js b/backend/src/kitchen/shoppingService.js
index e63b0c361922b1f39a0f99f3b4c3221e3a751fc1..f9f41bb296df4a8f6bf7ec0dbb5382534321d4ab 100644
--- a/backend/src/kitchen/shoppingService.js
+++ b/backend/src/kitchen/shoppingService.js
@@ -1,86 +1,123 @@
 import { KitchenShoppingList } from "./models/KitchenShoppingList.js";
 import { KitchenWeekPlan } from "./models/KitchenWeekPlan.js";
 import { KitchenDish } from "./models/KitchenDish.js";
 import { KitchenIngredient } from "./models/KitchenIngredient.js";
 import { buildScopedFilter } from "./householdScope.js";
 import { combineDayIngredients } from "./utils/ingredients.js";
-import { normalizeIngredientName } from "./utils/normalize.js";
+import { normalizeIngredientName } from "./utils/normalize.js";
+import { CATALOG_SCOPES } from "./utils/catalogScopes.js";
+
+const INGREDIENT_SCOPE_PRIORITY = {
+  [CATALOG_SCOPES.OVERRIDE]: 0,
+  [CATALOG_SCOPES.HOUSEHOLD]: 1,
+  [CATALOG_SCOPES.MASTER]: 2
+};
+
+function compareByScopePriority(a, b) {
+  const left = INGREDIENT_SCOPE_PRIORITY[a.scope] ?? 99;
+  const right = INGREDIENT_SCOPE_PRIORITY[b.scope] ?? 99;
+  return left - right;
+}
+
+function buildIngredientVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
+  return {
+    ...extraFilter,
+    isArchived: { $ne: true },
+    $or: [
+      { scope: CATALOG_SCOPES.MASTER },
+      { scope: CATALOG_SCOPES.HOUSEHOLD, householdId: effectiveHouseholdId },
+      { scope: CATALOG_SCOPES.OVERRIDE, householdId: effectiveHouseholdId }
+    ]
+  };
+}
 
 export async function ensureShoppingList(weekStartDate, effectiveHouseholdId) {
   const existing = await KitchenShoppingList.findOne(
     buildScopedFilter(effectiveHouseholdId, { weekStart: weekStartDate })
   );
   if (existing) return existing;
   return KitchenShoppingList.create({
     weekStart: weekStartDate,
     items: [],
     householdId: effectiveHouseholdId
   });
 }
 
-export async function resolveShoppingItemIngredientData(items, effectiveHouseholdId) {
+export async function resolveShoppingItemIngredientData(items, effectiveHouseholdId) {
   const byId = new Map();
   const byCanonical = new Map();
 
   for (const item of items) {
     if (item?.ingredientId) byId.set(String(item.ingredientId), true);
     const canonical = normalizeIngredientName(item?.canonicalName || item?.displayName || "");
     if (canonical) byCanonical.set(canonical, true);
   }
 
   const ingredientFilters = [];
   const ids = Array.from(byId.keys());
   const canonicalNames = Array.from(byCanonical.keys());
   if (ids.length) ingredientFilters.push({ _id: { $in: ids } });
   if (canonicalNames.length) ingredientFilters.push({ canonicalName: { $in: canonicalNames } });
   if (!ingredientFilters.length) return { changed: false, resolvedItems: items };
 
-  const ingredientDocs = await KitchenIngredient.find(
-    buildScopedFilter(effectiveHouseholdId, { $or: ingredientFilters })
-  ).select("_id canonicalName categoryId name");
-
-  const ingredientById = new Map(ingredientDocs.map((doc) => [String(doc._id), doc]));
-  const ingredientByCanonical = new Map(ingredientDocs.map((doc) => [doc.canonicalName, doc]));
+  const ingredientDocs = await KitchenIngredient.find(
+    buildIngredientVisibilityFilter(effectiveHouseholdId, { $or: ingredientFilters })
+  )
+    .select("_id canonicalName categoryId name scope")
+    .lean();
+
+  const sortedIngredients = ingredientDocs.sort(compareByScopePriority);
+  const ingredientById = new Map(sortedIngredients.map((doc) => [String(doc._id), doc]));
+  const ingredientByCanonical = new Map();
+  sortedIngredients.forEach((doc) => {
+    if (doc.canonicalName && !ingredientByCanonical.has(doc.canonicalName)) {
+      ingredientByCanonical.set(doc.canonicalName, doc);
+    }
+  });
 
   let changed = false;
   const resolvedItems = items.map((item) => {
     const normalizedCanonical = normalizeIngredientName(item?.canonicalName || item?.displayName || "");
     const byExistingId = item?.ingredientId ? ingredientById.get(String(item.ingredientId)) : null;
     const byName = normalizedCanonical ? ingredientByCanonical.get(normalizedCanonical) : null;
     const resolved = byExistingId || byName || null;
     if (!resolved) return item;
 
     const next = { ...item };
     if (!next.ingredientId || String(next.ingredientId) !== String(resolved._id)) {
       next.ingredientId = resolved._id;
       changed = true;
     }
-    if (next.canonicalName !== resolved.canonicalName) {
-      next.canonicalName = resolved.canonicalName;
-      changed = true;
-    }
+    if (next.canonicalName !== resolved.canonicalName) {
+      next.canonicalName = resolved.canonicalName;
+      changed = true;
+    }
+    if (!next.displayName) {
+      next.displayName = resolved.name;
+      changed = true;
+    }
     if (!next.categoryId || String(next.categoryId) !== String(resolved.categoryId || "")) {
       next.categoryId = resolved.categoryId || null;
       changed = true;
     }
     return next;
   });
 
   return { changed, resolvedItems };
 }
 
 async function buildAggregatedFromWeek(weekStartDate, effectiveHouseholdId) {
   const plan = await KitchenWeekPlan.findOne(
     buildScopedFilter(effectiveHouseholdId, { weekStart: weekStartDate })
   );
   if (!plan) return [];
 
   const dishIds = plan.days.flatMap((day) => [day.mainDishId, day.sideDishId]).filter(Boolean);
   const dishes = await KitchenDish.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: dishIds } }));
   const dishMap = new Map(dishes.map((dish) => [dish._id.toString(), dish]));
 
   const merged = new Map();
   for (const day of plan.days) {
     const main = day.mainDishId ? dishMap.get(day.mainDishId.toString()) : null;
     const side = day.sideDishId ? dishMap.get(day.sideDishId.toString()) : null;
     const ingredients = combineDayIngredients({
diff --git a/frontend/src/kitchen/pages/ShoppingPage.jsx b/frontend/src/kitchen/pages/ShoppingPage.jsx
index ce61f60fc99e2c52112829355341d90af3927c36..88bab9d4d0d472b90f66b6c6b4773db3501a75ac 100644
--- a/frontend/src/kitchen/pages/ShoppingPage.jsx
+++ b/frontend/src/kitchen/pages/ShoppingPage.jsx
@@ -1,26 +1,26 @@
-import React, { useEffect, useMemo, useState } from "react";
+import React, { useEffect, useMemo, useRef, useState } from "react";
 import KitchenLayout from "../Layout.jsx";
 import { apiRequest } from "../api.js";
 import { useAuth } from "../auth";
 import { useActiveWeek } from "../weekContext.jsx";
 
 function ChevronIcon(props) {
   return (
     <svg viewBox="0 0 20 20" fill="none" aria-hidden="true" {...props}>
       <path d="M11.75 4.5 6.25 10l5.5 5.5" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
     </svg>
   );
 }
 
 function addDaysToISO(iso, days) {
   const date = new Date(`${iso}T00:00:00Z`);
   date.setUTCDate(date.getUTCDate() + days);
   return date.toISOString().slice(0, 10);
 }
 
 function normalizeWeekStartInput(value) {
   if (!value) return "";
   const d = new Date(`${value}T00:00:00Z`);
   const day = d.getUTCDay();
   const diff = (day === 0 ? -6 : 1) - day;
   d.setUTCDate(d.getUTCDate() + diff);
@@ -42,50 +42,51 @@ function formatTripDate(value) {
 }
 
 function slugColor(slug = "") {
   const normalized = String(slug || "otros");
   const seed = normalized.split("").reduce((acc, char) => acc + char.charCodeAt(0), 0);
   const hue = seed % 360;
   return {
     colorBg: `hsl(${hue} 70% 95%)`,
     colorText: `hsl(${hue} 55% 35%)`
   };
 }
 
 function itemKey(item) {
   return `${item.ingredientId || "no-id"}-${item.canonicalName}`;
 }
 
 export default function ShoppingPage() {
   const { user } = useAuth();
   const { activeWeek: weekStart, setActiveWeek: setWeekStart } = useActiveWeek();
   const [tab, setTab] = useState("pending");
   const [error, setError] = useState("");
   const [success, setSuccess] = useState("");
   const [isRefreshing, setIsRefreshing] = useState(false);
   const [stores, setStores] = useState([]);
   const [selectedStoreId, setSelectedStoreId] = useState("");
+  const selectedStoreRef = useRef("");
   const [pendingByCategory, setPendingByCategory] = useState([]);
   const [purchasedByStoreDay, setPurchasedByStoreDay] = useState([]);
   const [transitioningItemKey, setTransitioningItemKey] = useState(null);
   const [recentlyMovedItemKey, setRecentlyMovedItemKey] = useState(null);
   const isDiodGlobalMode = user?.globalRole === "diod" && !user?.activeHouseholdId;
 
   const applyPayload = (data) => {
     setStores(data.stores || []);
     setPendingByCategory(data.pendingByCategory || []);
     setPurchasedByStoreDay(data.purchasedByStoreDay || []);
   };
 
   const loadList = async ({ silent = false } = {}) => {
     if (isDiodGlobalMode) return;
     if (!silent) setIsRefreshing(true);
     setError("");
     try {
       const data = await apiRequest(`/api/kitchen/shopping/${weekStart}`);
       applyPayload(data);
     } catch (err) {
       setError(err.message || "No se pudo cargar la lista.");
     } finally {
       if (!silent) setIsRefreshing(false);
     }
   };
@@ -103,51 +104,51 @@ export default function ShoppingPage() {
   const refreshList = async () => {
     if (isDiodGlobalMode) return;
     setIsRefreshing(true);
     try {
       const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/rebuild`, { method: "POST" });
       applyPayload(data);
       setSuccess("Lista reconstruida");
     } catch (err) {
       setError(err.message || "No se pudo refrescar la lista.");
     } finally {
       setIsRefreshing(false);
     }
   };
 
   const setItemStatus = async (item, status) => {
     if (isDiodGlobalMode) return;
     const key = itemKey(item);
     setTransitioningItemKey(key);
     try {
       const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/item`, {
         method: "PUT",
         body: JSON.stringify({
           canonicalName: item.canonicalName,
           ingredientId: item.ingredientId,
           status,
-          storeId: status === "purchased" ? selectedStoreId || null : null
+          storeId: status === "purchased" ? selectedStoreRef.current || null : null
         })
       });
       applyPayload(data);
       setRecentlyMovedItemKey(key);
     } catch (err) {
       setError(err.message || "No se pudo actualizar.");
     } finally {
       setTransitioningItemKey(null);
     }
   };
 
   const updatePurchasedItemStore = async (item, storeId) => {
     try {
       const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/item/store`, {
         method: "PUT",
         body: JSON.stringify({ canonicalName: item.canonicalName, ingredientId: item.ingredientId, storeId: storeId || null })
       });
       applyPayload(data);
     } catch (err) {
       setError(err.message || "No se pudo cambiar el supermercado.");
     }
   };
 
   const assignStoreToTodayUnassigned = async () => {
     try {
@@ -196,50 +197,51 @@ export default function ShoppingPage() {
         <div className="kitchen-card shopping-header-card">
           <div className="shopping-header-row">
             <div>
               <h3>Lista de la compra · Semana {formatWeekTitle(weekStart)}</h3>
               <p className="kitchen-muted">Marca productos y se registra automáticamente quién compró y cuándo.</p>
             </div>
             <button className="kitchen-button secondary" type="button" onClick={refreshList} disabled={isRefreshing}>Refrescar</button>
           </div>
 
           <div className="shopping-week-nav">
             <button className="shopping-week-arrow" type="button" onClick={() => setWeekStart((prev) => addDaysToISO(prev, -7))}><ChevronIcon className="shopping-week-arrow-icon" /></button>
             <input className="kitchen-input" type="date" value={weekStart} onChange={(event) => setWeekStart(normalizeWeekStartInput(event.target.value))} />
             <button className="shopping-week-arrow" type="button" onClick={() => setWeekStart((prev) => addDaysToISO(prev, 7))}><ChevronIcon className="shopping-week-arrow-icon is-next" /></button>
           </div>
 
           <div className="shopping-toolbar">
             <select
               className="kitchen-select"
               value={selectedStoreId}
               onChange={(event) => {
                 const value = event.target.value;
                 if (value === "__add__") {
                   void createStoreFromDropdown();
                   return;
                 }
+                selectedStoreRef.current = value;
                 setSelectedStoreId(value);
               }}
             >
               <option value="">Supermercado (opcional)</option>
               {stores.map((store) => (
                 <option key={store._id} value={store._id}>{store.name}</option>
               ))}
               <option value="__add__">Añadir supermercado…</option>
             </select>
             <button className="kitchen-button secondary" type="button" onClick={assignStoreToTodayUnassigned}>Asignar a comprados de hoy sin supermercado</button>
           </div>
           {success ? <div className="kitchen-alert success">{success}</div> : null}
           {error ? <div className="kitchen-alert error">{error}</div> : null}
         </div>
 
         <div className="kitchen-dishes-tabs" role="tablist" aria-label="Estado de la compra">
           <button className={`kitchen-tab-button ${tab === "pending" ? "is-active" : ""}`} onClick={() => setTab("pending")}>Pendiente ({pendingCount})</button>
           <button className={`kitchen-tab-button ${tab === "purchased" ? "is-active" : ""}`} onClick={() => setTab("purchased")}>Comprado</button>
         </div>
 
         {tab === "pending" ? (
           <div className="shopping-categories">
             {pendingByCategory.length === 0 ? (
               <div className="kitchen-card kitchen-empty"><h4>No hay pendientes para esta semana.</h4></div>
             ) : pendingByCategory.map((group) => {
