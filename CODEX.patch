diff --git a/backend/src/kitchen/routes/shopping.js b/backend/src/kitchen/routes/shopping.js
index e86324d1f91b001ef2228aaf9ff105ceb112ba39..05da834127d9419035a8fb4d4eb3221fdac9332e 100644
--- a/backend/src/kitchen/routes/shopping.js
+++ b/backend/src/kitchen/routes/shopping.js
@@ -1,424 +1,427 @@
-import express from "express";
-import { Category } from "../models/Category.js";
-import { Store } from "../models/Store.js";
-import { KitchenUser } from "../models/KitchenUser.js";
-import { requireAuth, requireDiod } from "../middleware.js";
-import { formatDateISO, getWeekStart, parseISODate } from "../utils/dates.js";
-import {
-  buildScopedFilter,
-  getEffectiveHouseholdId,
-  handleHouseholdError
-} from "../householdScope.js";
-import { ensureShoppingList, rebuildShoppingList, resolveShoppingItemIngredientData } from "../shoppingService.js";
-import { CATALOG_SCOPES } from "../utils/catalogScopes.js";
-import {
-  DEFAULT_CATEGORY_COLOR_BG,
-  DEFAULT_CATEGORY_COLOR_TEXT,
-  DEFAULT_CATEGORY_NAME,
-  DEFAULT_CATEGORY_SLUG,
-  ensureDefaultCategory
-} from "../utils/categoryMatching.js";
-
-const router = express.Router();
-
-function logShoppingError(context, error, extra = {}) {
-  console.error(`[kitchen][shopping] ${context}`, {
-    ...extra,
-    message: error?.message,
-    stack: error?.stack
-  });
-}
-
-
-function normalizeStoreName(value = "") {
-  return String(value).trim().toLowerCase();
-}
-
-function sortStores(stores = []) {
-  return [...stores].sort((a, b) => {
-    const orderA = Number.isFinite(a.order) ? a.order : Number.POSITIVE_INFINITY;
-    const orderB = Number.isFinite(b.order) ? b.order : Number.POSITIVE_INFINITY;
-    if (orderA !== orderB) return orderA - orderB;
-    return String(a.name || "").localeCompare(String(b.name || ""), "es", { sensitivity: "base" });
-  });
-}
-
-function buildStoreVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
-  return {
-    ...extraFilter,
-    $or: [
-      { scope: "master", householdId: null },
-      { scope: "household", householdId: effectiveHouseholdId }
-    ]
-  };
-}
-
-function buildCategoryVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
-  return {
-    ...extraFilter,
-    $or: [
-      { scope: CATALOG_SCOPES.MASTER, householdId: null },
-      { scope: CATALOG_SCOPES.HOUSEHOLD, householdId: effectiveHouseholdId },
-      { scope: CATALOG_SCOPES.OVERRIDE, householdId: effectiveHouseholdId }
-    ]
-  };
-}
-
-function toDateGroup(value) {
-  if (!value) return "sin-fecha";
-  return new Date(value).toISOString().slice(0, 10);
-}
-
-function isValidObjectId(value) {
-  return Boolean(value) && /^[a-f\d]{24}$/i.test(String(value));
-}
-
-function normalizeShoppingItemForResponse(item, purchaserById) {
-  const normalized = item.toObject ? item.toObject() : { ...item };
-  return {
-    ...normalized,
-    categoryId: normalized.categoryId || null,
-    storeId: normalized.storeId || null,
-    purchasedBy: normalized.purchasedBy || null,
-    purchasedAt: normalized.purchasedAt || null,
-    purchasedByName: normalized.purchasedBy && isValidObjectId(normalized.purchasedBy)
-      ? purchaserById.get(String(normalized.purchasedBy)) || "Usuario"
-      : null
-  };
-}
-
-async function getShoppingPayload(weekStartDate, effectiveHouseholdId) {
-  const list = await ensureShoppingList(weekStartDate, effectiveHouseholdId);
-
-  const fallbackCategory = await ensureDefaultCategory({
-    Category,
-    householdId: effectiveHouseholdId
-  });
-
-  const resolved = await resolveShoppingItemIngredientData(
-    list.items.map((item) => item.toObject()),
-    effectiveHouseholdId,
-    { fallbackCategoryId: fallbackCategory?._id || null }
-  );
-  if (resolved.changed) {
-    list.items = resolved.resolvedItems;
-    await list.save();
-  }
-
-  const categories = await Category.find(buildCategoryVisibilityFilter(effectiveHouseholdId, { isArchived: { $ne: true } })).select(
-    "_id name slug colorBg colorText"
-  );
-  const stores = sortStores(
-    await Store.find(buildStoreVisibilityFilter(effectiveHouseholdId, { active: true }))
-      .select("_id name order scope householdId")
-      .lean()
-  );
-
-  const storeById = new Map(stores.map((store) => [String(store._id), store.name]));
-  const categoryById = new Map(categories.map((category) => [String(category._id), category]));
-  const purchaserIds = Array.from(new Set(
-    list.items
-      .map((item) => item.purchasedBy)
-      .filter((value) => isValidObjectId(value))
-      .map((value) => String(value))
-  ));
-  const purchasers = purchaserIds.length
-    ? await KitchenUser.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: purchaserIds } })).select("_id displayName")
-    : [];
-  const purchaserById = new Map(purchasers.map((person) => [String(person._id), person.displayName]));
-
-  const pendingByCategory = list.items
-    .filter((item) => item.status === "pending")
-    .reduce((acc, item) => {
-      const key = item.categoryId ? String(item.categoryId) : "uncategorized";
-      const resolvedCategory = item.categoryId
-        ? categoryById.get(String(item.categoryId)) || null
-        : fallbackCategory || null;
-
-      if (!acc.has(key)) {
-        acc.set(key, {
-          categoryId: resolvedCategory?._id || item.categoryId || null,
-          categoryInfo: {
-            name: resolvedCategory?.name || DEFAULT_CATEGORY_NAME,
-            slug: resolvedCategory?.slug || DEFAULT_CATEGORY_SLUG,
-            colorBg: resolvedCategory?.colorBg || DEFAULT_CATEGORY_COLOR_BG,
-            colorText: resolvedCategory?.colorText || DEFAULT_CATEGORY_COLOR_TEXT
-          },
-          items: []
-        });
-      }
-      acc.get(key).items.push(normalizeShoppingItemForResponse(item, purchaserById));
-      return acc;
-    }, new Map());
-
-  const purchasedByStoreDay = list.items
-    .filter((item) => item.status === "purchased")
-    .reduce((acc, item) => {
-      const dateKey = toDateGroup(item.purchasedAt);
-      const storeKey = item.storeId ? String(item.storeId) : "no-store";
-      const key = `${dateKey}::${storeKey}`;
-      if (!acc.has(key)) {
-        const purchasedByName = item.purchasedBy && isValidObjectId(item.purchasedBy)
-          ? purchaserById.get(String(item.purchasedBy)) || "Usuario"
-          : "Usuario";
-        acc.set(key, {
-          storeId: item.storeId || null,
-          storeName: item.storeId ? storeById.get(String(item.storeId)) || "Supermercado no definido" : "Supermercado no definido",
-          purchasedDate: dateKey,
-          startedAt: item.purchasedAt,
-          purchasedByName,
-          items: []
-        });
-      }
-      acc.get(key).items.push(normalizeShoppingItemForResponse(item, purchaserById));
-      return acc;
-    }, new Map());
-
-  return {
-    list,
-    stores,
-    pendingByCategory: Array.from(pendingByCategory.values()),
-    purchasedByStoreDay: Array.from(purchasedByStoreDay.values()).sort(
-      (a, b) => new Date(b.startedAt || 0).getTime() - new Date(a.startedAt || 0).getTime()
-    )
-  };
-}
-
-async function validateStoreSelection(storeId, effectiveHouseholdId) {
-  if (!storeId) return null;
-  const store = await Store.findOne(buildStoreVisibilityFilter(effectiveHouseholdId, { _id: storeId, active: true }))
-    .select("_id")
-    .lean();
-  return store ? store._id : null;
-}
-
-router.get("/:weekStart", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-
-    res.json({ ok: true, weekStart: formatDateISO(monday), ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    logShoppingError("get-list", error, { weekStart: req.params.weekStart, userId: String(req.kitchenUser?._id || "") });
-    return res.status(500).json({ ok: false, error: "No se pudo cargar la lista de compra." });
-  }
-});
-
-router.post("/:weekStart/rebuild", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    await rebuildShoppingList(monday, effectiveHouseholdId);
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-
-    res.json({ ok: true, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    logShoppingError("rebuild", error, { weekStart: req.params.weekStart, userId: String(req.kitchenUser?._id || "") });
-    if (error?.name === "ValidationError" || error?.name === "CastError") {
-      return res.status(400).json({ ok: false, error: "Datos inválidos al reconstruir la lista." });
-    }
-    return res.status(500).json({ ok: false, error: "No se pudo reconstruir la lista de compra." });
-  }
-});
-
-router.put("/:weekStart/item", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const { canonicalName, status, ingredientId, storeId } = req.body;
-    if (!canonicalName && !ingredientId) {
-      return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
-    }
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-
-    const item = list.items.find((current) => {
-      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
-      return current.canonicalName === canonicalName;
-    });
-
-    if (!item) return res.status(404).json({ ok: false, error: "Ingrediente no encontrado en la lista." });
-
-    const normalizedStatus = status === "purchased" ? "purchased" : "pending";
-    item.status = normalizedStatus;
-    if (normalizedStatus === "purchased") {
-      const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
-      item.purchasedBy = req.kitchenUser._id;
-      item.purchasedAt = new Date();
-      item.storeId = validatedStoreId;
-    } else {
-      item.purchasedBy = null;
-      item.purchasedAt = null;
-      item.storeId = null;
-    }
-
-    await list.save();
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-    res.json({ ok: true, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo actualizar la lista de compra." });
-  }
-});
-
-router.put("/:weekStart/item/store", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const { canonicalName, ingredientId, storeId } = req.body;
-    if (!canonicalName && !ingredientId) {
-      return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
-    }
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-
-    const item = list.items.find((current) => {
-      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
-      return current.canonicalName === canonicalName;
-    });
-
-    if (!item || item.status !== "purchased") {
-      return res.status(404).json({ ok: false, error: "Ingrediente comprado no encontrado." });
-    }
-
-    item.storeId = await validateStoreSelection(storeId, effectiveHouseholdId);
-    await list.save();
-
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-    return res.json({ ok: true, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo actualizar el supermercado." });
-  }
-});
-
-router.post("/:weekStart/purchased/assign-store", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const { storeId } = req.body;
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-    const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
-
-    const today = new Date().toISOString().slice(0, 10);
-    let changed = false;
-    for (const item of list.items) {
-      if (item.status !== "purchased" || item.storeId || !item.purchasedAt) continue;
-      if (toDateGroup(item.purchasedAt) !== today) continue;
-      item.storeId = validatedStoreId;
-      changed = true;
-    }
-
-    if (changed) await list.save();
-
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-    return res.json({ ok: true, updated: changed, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo asignar el supermercado." });
-  }
-});
-
-router.post("/stores", requireAuth, async (req, res) => {
-  try {
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const name = String(req.body?.name || "").trim();
-    if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
-    const canonicalName = normalizeStoreName(name);
-
-    const store = await Store.findOneAndUpdate(
-      { scope: "household", householdId: effectiveHouseholdId, canonicalName },
-      { $setOnInsert: { scope: "household", householdId: effectiveHouseholdId, name, canonicalName } },
-      { new: true, upsert: true }
-    );
-
-    return res.status(201).json({ ok: true, store });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo crear la tienda." });
-  }
-});
-
-router.get("/stores/master", requireAuth, requireDiod, async (req, res) => {
-  const stores = sortStores(
-    await Store.find({ scope: "master", householdId: null }).select("_id name canonicalName active order scope")
-  );
-  return res.json({ ok: true, stores });
-});
-
-router.post("/stores/master", requireAuth, requireDiod, async (req, res) => {
-  const name = String(req.body?.name || "").trim();
-  if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
-  const canonicalName = normalizeStoreName(name);
-  const requestedOrder = Number(req.body?.order);
-
-  const store = await Store.findOneAndUpdate(
-    { scope: "master", householdId: null, canonicalName },
-    {
-      $set: {
-        name,
-        canonicalName,
-        active: req.body?.active !== false,
-        order: Number.isFinite(requestedOrder) ? requestedOrder : null,
-        scope: "master",
-        householdId: null
-      }
-    },
-    { new: true, upsert: true }
-  );
-  return res.status(201).json({ ok: true, store });
-});
-
-router.put("/stores/master/:storeId", requireAuth, requireDiod, async (req, res) => {
-  const store = await Store.findOne({ _id: req.params.storeId, scope: "master", householdId: null });
-  if (!store) return res.status(404).json({ ok: false, error: "Supermercado no encontrado." });
-
-  if (req.body?.name !== undefined) {
-    const name = String(req.body.name || "").trim();
-    if (!name) return res.status(400).json({ ok: false, error: "Nombre inválido." });
-    store.name = name;
-    store.canonicalName = normalizeStoreName(name);
-  }
-  if (req.body?.active !== undefined) store.active = Boolean(req.body.active);
-  if (req.body?.order !== undefined) {
-    const requestedOrder = Number(req.body.order);
-    store.order = Number.isFinite(requestedOrder) ? requestedOrder : null;
-  }
-
-  await store.save();
-  return res.json({ ok: true, store });
-});
-
-router.delete("/stores/master/:storeId", requireAuth, requireDiod, async (req, res) => {
-  const store = await Store.findOne({ _id: req.params.storeId, scope: "master", householdId: null });
-  if (!store) return res.status(404).json({ ok: false, error: "Supermercado no encontrado." });
-  store.active = false;
-  await store.save();
-  return res.json({ ok: true, store });
-});
-
-export default router;
+import express from "express";
+import { Category } from "../models/Category.js";
+import { Store } from "../models/Store.js";
+import { KitchenUser } from "../models/KitchenUser.js";
+import { requireAuth, requireDiod } from "../middleware.js";
+import { formatDateISO, getWeekStart, parseISODate } from "../utils/dates.js";
+import {
+  buildScopedFilter,
+  getEffectiveHouseholdId,
+  handleHouseholdError
+} from "../householdScope.js";
+import { ensureShoppingList, rebuildShoppingList, repairShoppingListItems } from "../shoppingService.js";
+import { CATALOG_SCOPES } from "../utils/catalogScopes.js";
+import {
+  DEFAULT_CATEGORY_COLOR_BG,
+  DEFAULT_CATEGORY_COLOR_TEXT,
+  DEFAULT_CATEGORY_NAME,
+  DEFAULT_CATEGORY_SLUG,
+  ensureDefaultCategory
+} from "../utils/categoryMatching.js";
+
+const router = express.Router();
+
+function logShoppingError(context, error, extra = {}) {
+  console.error(`[kitchen][shopping] ${context}`, {
+    ...extra,
+    message: error?.message,
+    stack: error?.stack
+  });
+}
+
+
+function normalizeStoreName(value = "") {
+  return String(value).trim().toLowerCase();
+}
+
+function sortStores(stores = []) {
+  return [...stores].sort((a, b) => {
+    const orderA = Number.isFinite(a.order) ? a.order : Number.POSITIVE_INFINITY;
+    const orderB = Number.isFinite(b.order) ? b.order : Number.POSITIVE_INFINITY;
+    if (orderA !== orderB) return orderA - orderB;
+    return String(a.name || "").localeCompare(String(b.name || ""), "es", { sensitivity: "base" });
+  });
+}
+
+function buildStoreVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
+  return {
+    ...extraFilter,
+    $or: [
+      { scope: "master", householdId: null },
+      { scope: "household", householdId: effectiveHouseholdId }
+    ]
+  };
+}
+
+function buildCategoryVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
+  return {
+    ...extraFilter,
+    $or: [
+      { scope: CATALOG_SCOPES.MASTER, householdId: null },
+      { scope: CATALOG_SCOPES.HOUSEHOLD, householdId: effectiveHouseholdId },
+      { scope: CATALOG_SCOPES.OVERRIDE, householdId: effectiveHouseholdId }
+    ]
+  };
+}
+
+function toDateGroup(value) {
+  if (!value) return "sin-fecha";
+  return new Date(value).toISOString().slice(0, 10);
+}
+
+function isValidObjectId(value) {
+  return Boolean(value) && /^[a-f\d]{24}$/i.test(String(value));
+}
+
+function normalizeShoppingItemForResponse(item, purchaserById) {
+  const normalized = item.toObject ? item.toObject() : { ...item };
+  return {
+    ...normalized,
+    categoryId: normalized.categoryId || null,
+    storeId: normalized.storeId || null,
+    purchasedBy: normalized.purchasedBy || null,
+    purchasedAt: normalized.purchasedAt || null,
+    purchasedByName: normalized.purchasedBy && isValidObjectId(normalized.purchasedBy)
+      ? purchaserById.get(String(normalized.purchasedBy)) || "Usuario"
+      : null
+  };
+}
+
+async function getShoppingPayload(weekStartDate, effectiveHouseholdId) {
+  const list = await ensureShoppingList(weekStartDate, effectiveHouseholdId);
+
+  const fallbackCategory = await ensureDefaultCategory({
+    Category,
+    householdId: effectiveHouseholdId
+  });
+  await repairShoppingListItems(list, effectiveHouseholdId, {
+    fallbackCategory,
+    context: "getShoppingPayload"
+  });
+
+  const categories = await Category.find(buildCategoryVisibilityFilter(effectiveHouseholdId, { isArchived: { $ne: true } })).select(
+    "_id name slug colorBg colorText"
+  );
+  const stores = sortStores(
+    await Store.find(buildStoreVisibilityFilter(effectiveHouseholdId, { active: true }))
+      .select("_id name order scope householdId")
+      .lean()
+  );
+
+  const storeById = new Map(stores.map((store) => [String(store._id), store.name]));
+  const categoryById = new Map(categories.map((category) => [String(category._id), category]));
+  const purchaserIds = Array.from(new Set(
+    list.items
+      .map((item) => item.purchasedBy)
+      .filter((value) => isValidObjectId(value))
+      .map((value) => String(value))
+  ));
+  const purchasers = purchaserIds.length
+    ? await KitchenUser.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: purchaserIds } })).select("_id displayName")
+    : [];
+  const purchaserById = new Map(purchasers.map((person) => [String(person._id), person.displayName]));
+
+  const pendingByCategory = list.items
+    .filter((item) => item.status === "pending")
+    .reduce((acc, item) => {
+      const key = item.categoryId ? String(item.categoryId) : "uncategorized";
+      const resolvedCategory = item.categoryId
+        ? categoryById.get(String(item.categoryId)) || null
+        : fallbackCategory || null;
+
+      if (!acc.has(key)) {
+        acc.set(key, {
+          categoryId: resolvedCategory?._id || item.categoryId || null,
+          categoryInfo: {
+            name: resolvedCategory?.name || DEFAULT_CATEGORY_NAME,
+            slug: resolvedCategory?.slug || DEFAULT_CATEGORY_SLUG,
+            colorBg: resolvedCategory?.colorBg || DEFAULT_CATEGORY_COLOR_BG,
+            colorText: resolvedCategory?.colorText || DEFAULT_CATEGORY_COLOR_TEXT
+          },
+          items: []
+        });
+      }
+      acc.get(key).items.push(normalizeShoppingItemForResponse(item, purchaserById));
+      return acc;
+    }, new Map());
+
+  const purchasedByStoreDay = list.items
+    .filter((item) => item.status === "purchased")
+    .reduce((acc, item) => {
+      const dateKey = toDateGroup(item.purchasedAt);
+      const storeKey = item.storeId ? String(item.storeId) : "no-store";
+      const key = `${dateKey}::${storeKey}`;
+      if (!acc.has(key)) {
+        const purchasedByName = item.purchasedBy && isValidObjectId(item.purchasedBy)
+          ? purchaserById.get(String(item.purchasedBy)) || "Usuario"
+          : "Usuario";
+        acc.set(key, {
+          storeId: item.storeId || null,
+          storeName: item.storeId ? storeById.get(String(item.storeId)) || "Supermercado no definido" : "Supermercado no definido",
+          purchasedDate: dateKey,
+          startedAt: item.purchasedAt,
+          purchasedByName,
+          items: []
+        });
+      }
+      acc.get(key).items.push(normalizeShoppingItemForResponse(item, purchaserById));
+      return acc;
+    }, new Map());
+
+  return {
+    list,
+    stores,
+    pendingByCategory: Array.from(pendingByCategory.values()),
+    purchasedByStoreDay: Array.from(purchasedByStoreDay.values()).sort(
+      (a, b) => new Date(b.startedAt || 0).getTime() - new Date(a.startedAt || 0).getTime()
+    )
+  };
+}
+
+async function validateStoreSelection(storeId, effectiveHouseholdId) {
+  if (!storeId) return null;
+  const store = await Store.findOne(buildStoreVisibilityFilter(effectiveHouseholdId, { _id: storeId, active: true }))
+    .select("_id")
+    .lean();
+  return store ? store._id : null;
+}
+
+router.get("/:weekStart", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+
+    res.json({ ok: true, weekStart: formatDateISO(monday), ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    logShoppingError("get-list", error, { weekStart: req.params.weekStart, userId: String(req.kitchenUser?._id || "") });
+    return res.status(500).json({ ok: false, error: "No se pudo cargar la lista de compra." });
+  }
+});
+
+router.post("/:weekStart/rebuild", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    await rebuildShoppingList(monday, effectiveHouseholdId);
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+
+    res.json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    logShoppingError("rebuild", error, { weekStart: req.params.weekStart, userId: String(req.kitchenUser?._id || "") });
+    if (error?.name === "ValidationError" || error?.name === "CastError") {
+      return res.status(400).json({ ok: false, error: "Datos inválidos al reconstruir la lista." });
+    }
+    return res.status(500).json({ ok: false, error: "No se pudo reconstruir la lista de compra." });
+  }
+});
+
+router.put("/:weekStart/item", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const { canonicalName, status, ingredientId, storeId } = req.body;
+    if (!canonicalName && !ingredientId) {
+      return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
+    }
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+    await repairShoppingListItems(list, effectiveHouseholdId, {
+      context: "update-item"
+    });
+
+    const item = list.items.find((current) => {
+      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
+      return current.canonicalName === canonicalName;
+    });
+
+    if (!item) return res.status(404).json({ ok: false, error: "Ingrediente no encontrado en la lista." });
+
+    const normalizedStatus = status === "purchased" ? "purchased" : "pending";
+    item.status = normalizedStatus;
+    if (normalizedStatus === "purchased") {
+      const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
+      item.purchasedBy = req.kitchenUser._id;
+      item.purchasedAt = new Date();
+      item.storeId = validatedStoreId;
+    } else {
+      item.purchasedBy = null;
+      item.purchasedAt = null;
+      item.storeId = null;
+    }
+
+    await list.save();
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    res.json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar la lista de compra." });
+  }
+});
+
+router.put("/:weekStart/item/store", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const { canonicalName, ingredientId, storeId } = req.body;
+    if (!canonicalName && !ingredientId) {
+      return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
+    }
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+    await repairShoppingListItems(list, effectiveHouseholdId, {
+      context: "update-item-store"
+    });
+
+    const item = list.items.find((current) => {
+      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
+      return current.canonicalName === canonicalName;
+    });
+
+    if (!item || item.status !== "purchased") {
+      return res.status(404).json({ ok: false, error: "Ingrediente comprado no encontrado." });
+    }
+
+    item.storeId = await validateStoreSelection(storeId, effectiveHouseholdId);
+    await list.save();
+
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    return res.json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar el supermercado." });
+  }
+});
+
+router.post("/:weekStart/purchased/assign-store", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const { storeId } = req.body;
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+    await repairShoppingListItems(list, effectiveHouseholdId, {
+      context: "assign-store"
+    });
+    const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
+
+    const today = new Date().toISOString().slice(0, 10);
+    let changed = false;
+    for (const item of list.items) {
+      if (item.status !== "purchased" || item.storeId || !item.purchasedAt) continue;
+      if (toDateGroup(item.purchasedAt) !== today) continue;
+      item.storeId = validatedStoreId;
+      changed = true;
+    }
+
+    if (changed) await list.save();
+
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    return res.json({ ok: true, updated: changed, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo asignar el supermercado." });
+  }
+});
+
+router.post("/stores", requireAuth, async (req, res) => {
+  try {
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const name = String(req.body?.name || "").trim();
+    if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
+    const canonicalName = normalizeStoreName(name);
+
+    const store = await Store.findOneAndUpdate(
+      { scope: "household", householdId: effectiveHouseholdId, canonicalName },
+      { $setOnInsert: { scope: "household", householdId: effectiveHouseholdId, name, canonicalName } },
+      { new: true, upsert: true }
+    );
+
+    return res.status(201).json({ ok: true, store });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo crear la tienda." });
+  }
+});
+
+router.get("/stores/master", requireAuth, requireDiod, async (req, res) => {
+  const stores = sortStores(
+    await Store.find({ scope: "master", householdId: null }).select("_id name canonicalName active order scope")
+  );
+  return res.json({ ok: true, stores });
+});
+
+router.post("/stores/master", requireAuth, requireDiod, async (req, res) => {
+  const name = String(req.body?.name || "").trim();
+  if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
+  const canonicalName = normalizeStoreName(name);
+  const requestedOrder = Number(req.body?.order);
+
+  const store = await Store.findOneAndUpdate(
+    { scope: "master", householdId: null, canonicalName },
+    {
+      $set: {
+        name,
+        canonicalName,
+        active: req.body?.active !== false,
+        order: Number.isFinite(requestedOrder) ? requestedOrder : null,
+        scope: "master",
+        householdId: null
+      }
+    },
+    { new: true, upsert: true }
+  );
+  return res.status(201).json({ ok: true, store });
+});
+
+router.put("/stores/master/:storeId", requireAuth, requireDiod, async (req, res) => {
+  const store = await Store.findOne({ _id: req.params.storeId, scope: "master", householdId: null });
+  if (!store) return res.status(404).json({ ok: false, error: "Supermercado no encontrado." });
+
+  if (req.body?.name !== undefined) {
+    const name = String(req.body.name || "").trim();
+    if (!name) return res.status(400).json({ ok: false, error: "Nombre inválido." });
+    store.name = name;
+    store.canonicalName = normalizeStoreName(name);
+  }
+  if (req.body?.active !== undefined) store.active = Boolean(req.body.active);
+  if (req.body?.order !== undefined) {
+    const requestedOrder = Number(req.body.order);
+    store.order = Number.isFinite(requestedOrder) ? requestedOrder : null;
+  }
+
+  await store.save();
+  return res.json({ ok: true, store });
+});
+
+router.delete("/stores/master/:storeId", requireAuth, requireDiod, async (req, res) => {
+  const store = await Store.findOne({ _id: req.params.storeId, scope: "master", householdId: null });
+  if (!store) return res.status(404).json({ ok: false, error: "Supermercado no encontrado." });
+  store.active = false;
+  await store.save();
+  return res.json({ ok: true, store });
+});
+
+export default router;
diff --git a/backend/src/kitchen/shoppingService.js b/backend/src/kitchen/shoppingService.js
index babedaa5cec86e783679fff5f570e04173f4b9ae..2f5801756c6db6a2d12f6a37f0ba8fc5e8ec8bcb 100644
--- a/backend/src/kitchen/shoppingService.js
+++ b/backend/src/kitchen/shoppingService.js
@@ -1,144 +1,199 @@
 import { KitchenShoppingList } from "./models/KitchenShoppingList.js";
 import { KitchenWeekPlan } from "./models/KitchenWeekPlan.js";
 import { KitchenDish } from "./models/KitchenDish.js";
 import { KitchenIngredient } from "./models/KitchenIngredient.js";
 import { Category } from "./models/Category.js";
 import { buildScopedFilter } from "./householdScope.js";
 import { combineDayIngredients } from "./utils/ingredients.js";
 import { normalizeIngredientName } from "./utils/normalize.js";
 import { CATALOG_SCOPES } from "./utils/catalogScopes.js";
 import { ensureDefaultCategory } from "./utils/categoryMatching.js";
 import mongoose from "mongoose";
 
 const INGREDIENT_SCOPE_PRIORITY = {
   [CATALOG_SCOPES.OVERRIDE]: 0,
   [CATALOG_SCOPES.HOUSEHOLD]: 1,
   [CATALOG_SCOPES.MASTER]: 2
 };
 
 function compareByScopePriority(a, b) {
   const left = INGREDIENT_SCOPE_PRIORITY[a.scope] ?? 99;
   const right = INGREDIENT_SCOPE_PRIORITY[b.scope] ?? 99;
   return left - right;
 }
 
-function buildIngredientVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
+function buildIngredientVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
   return {
     ...extraFilter,
     isArchived: { $ne: true },
     $or: [
       { scope: CATALOG_SCOPES.MASTER },
       { scope: CATALOG_SCOPES.HOUSEHOLD, householdId: effectiveHouseholdId },
       { scope: CATALOG_SCOPES.OVERRIDE, householdId: effectiveHouseholdId }
     ]
   };
 }
 
 export async function ensureShoppingList(weekStartDate, effectiveHouseholdId) {
   const existing = await KitchenShoppingList.findOne(
     buildScopedFilter(effectiveHouseholdId, { weekStart: weekStartDate })
   );
   if (existing) return existing;
   return KitchenShoppingList.create({
     weekStart: weekStartDate,
     items: [],
     householdId: effectiveHouseholdId
   });
 }
 
-export async function resolveShoppingItemIngredientData(items, effectiveHouseholdId, options = {}) {
+function deriveCanonicalName(item, fallbackSeed = "") {
+  const normalized = normalizeIngredientName(
+    item?.canonicalName || item?.displayName || fallbackSeed || ""
+  );
+  if (normalized) return normalized;
+  if (item?.ingredientId) return `item-${String(item.ingredientId).toLowerCase()}`;
+  return `item-${fallbackSeed || "sin-nombre"}`;
+}
+
+function ensureValidShoppingItemShape(item, index, fallbackCategoryId = null) {
+  const next = { ...(item || {}) };
+  const canonicalName = deriveCanonicalName(next, String(index + 1));
+  const displayName = String(
+    next.displayName || next.name || canonicalName || `Ingrediente ${index + 1}`
+  ).trim();
+
+  return {
+    ...next,
+    displayName,
+    canonicalName,
+    categoryId: next.categoryId || fallbackCategoryId || null
+  };
+}
+
+function filterValidShoppingItems(items = [], context = "unknown") {
+  const valid = [];
+  let filteredCount = 0;
+
+  items.forEach((rawItem, index) => {
+    const item = rawItem || {};
+    if (!item.displayName || !item.canonicalName) {
+      filteredCount += 1;
+      console.warn("[kitchen][shopping] filtering invalid item before save", {
+        context,
+        index,
+        displayName: item.displayName,
+        canonicalName: item.canonicalName,
+        ingredientId: item.ingredientId ? String(item.ingredientId) : null
+      });
+      return;
+    }
+    valid.push(item);
+  });
+
+  return { valid, filteredCount };
+}
+
+export async function resolveShoppingItemIngredientData(items, effectiveHouseholdId, options = {}) {
   const fallbackCategoryId = options.fallbackCategoryId || null;
   const byId = new Map();
   const byCanonical = new Map();
 
   for (const item of items) {
     if (item?.ingredientId) byId.set(String(item.ingredientId), true);
     const canonical = normalizeIngredientName(item?.canonicalName || item?.displayName || "");
     if (canonical) byCanonical.set(canonical, true);
   }
 
   const ingredientFilters = [];
   const ids = Array.from(byId.keys()).filter((id) => mongoose.isValidObjectId(id));
   const canonicalNames = Array.from(byCanonical.keys());
   if (ids.length) ingredientFilters.push({ _id: { $in: ids } });
   if (canonicalNames.length) ingredientFilters.push({ canonicalName: { $in: canonicalNames } });
   if (!ingredientFilters.length) {
     const resolvedWithoutLookup = items.map((item) => {
       if (item?.categoryId || !fallbackCategoryId) return item;
       return { ...item, categoryId: fallbackCategoryId };
     });
     return { changed: resolvedWithoutLookup.some((item, index) => item !== items[index]), resolvedItems: resolvedWithoutLookup };
   }
 
   const ingredientDocs = await KitchenIngredient.find(
     buildIngredientVisibilityFilter(effectiveHouseholdId, { $or: ingredientFilters })
   )
     .select("_id canonicalName categoryId name scope")
     .lean();
 
   const sortedIngredients = ingredientDocs.sort(compareByScopePriority);
   const ingredientById = new Map(sortedIngredients.map((doc) => [String(doc._id), doc]));
   const ingredientByCanonical = new Map();
   sortedIngredients.forEach((doc) => {
     if (doc.canonicalName && !ingredientByCanonical.has(doc.canonicalName)) {
       ingredientByCanonical.set(doc.canonicalName, doc);
     }
   });
 
   let changed = false;
-  const resolvedItems = items.map((item) => {
-    const normalizedCanonical = normalizeIngredientName(item?.canonicalName || item?.displayName || "");
-    const byExistingId = item?.ingredientId ? ingredientById.get(String(item.ingredientId)) : null;
-    const byName = normalizedCanonical ? ingredientByCanonical.get(normalizedCanonical) : null;
-    const resolved = byExistingId || byName || null;
-    if (!resolved) {
-      if (item?.categoryId || !fallbackCategoryId) return item;
-      changed = true;
-      return { ...item, categoryId: fallbackCategoryId };
-    }
-
-    const next = { ...item };
+  const resolvedItems = items.map((item, index) => {
+    const normalizedCanonical = normalizeIngredientName(item?.canonicalName || item?.displayName || "");
+    const byExistingId = item?.ingredientId ? ingredientById.get(String(item.ingredientId)) : null;
+    const byName = normalizedCanonical ? ingredientByCanonical.get(normalizedCanonical) : null;
+    const resolved = byExistingId || byName || null;
+    if (!resolved) {
+      const ensuredItem = ensureValidShoppingItemShape(item, index, fallbackCategoryId);
+      const previousCanonical = String(item?.canonicalName || "").trim();
+      const previousDisplayName = String(item?.displayName || "").trim();
+      if (!item?.categoryId || previousCanonical !== ensuredItem.canonicalName || previousDisplayName !== ensuredItem.displayName) {
+        changed = true;
+      }
+      return ensuredItem;
+    }
+
+    const next = { ...item };
     if (!next.ingredientId || String(next.ingredientId) !== String(resolved._id)) {
       next.ingredientId = resolved._id;
       changed = true;
     }
     if (next.canonicalName !== resolved.canonicalName) {
       next.canonicalName = resolved.canonicalName;
       changed = true;
     }
-    if (!next.displayName) {
-      next.displayName = resolved.name;
-      changed = true;
-    }
-    const resolvedCategoryId = resolved.categoryId || fallbackCategoryId || null;
+    if (!next.displayName) {
+      next.displayName = resolved.name;
+      changed = true;
+    }
+    if (!next.canonicalName) {
+      next.canonicalName = deriveCanonicalName(next, String(index + 1));
+      changed = true;
+    }
+    const resolvedCategoryId = resolved.categoryId || fallbackCategoryId || null;
     if (!next.categoryId || String(next.categoryId) !== String(resolvedCategoryId || "")) {
       next.categoryId = resolvedCategoryId;
       changed = true;
     }
-    return next;
-  });
+    return ensureValidShoppingItemShape(next, index, fallbackCategoryId);
+  });
 
   return { changed, resolvedItems };
 }
 
 async function buildAggregatedFromWeek(weekStartDate, effectiveHouseholdId) {
   const plan = await KitchenWeekPlan.findOne(
     buildScopedFilter(effectiveHouseholdId, { weekStart: weekStartDate })
   );
   if (!plan) return [];
 
   const dishIds = plan.days.flatMap((day) => [day.mainDishId, day.sideDishId]).filter(Boolean);
   const dishes = await KitchenDish.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: dishIds } }));
   const dishMap = new Map(dishes.map((dish) => [dish._id.toString(), dish]));
 
   const merged = new Map();
   for (const day of plan.days) {
     const main = day.mainDishId ? dishMap.get(day.mainDishId.toString()) : null;
     const side = day.sideDishId ? dishMap.get(day.sideDishId.toString()) : null;
     const ingredients = combineDayIngredients({
       mainDish: main,
       sideDish: side,
       overrides: day.ingredientOverrides
     });
 
     for (const ingredient of ingredients) {
@@ -154,42 +209,69 @@ async function buildAggregatedFromWeek(weekStartDate, effectiveHouseholdId) {
         unit: null,
         occurrences: 0,
         fromDishes: []
       };
 
       current.occurrences += 1;
       const dayDishIds = [day.mainDishId, day.sideDishId].filter(Boolean).map(String);
       current.fromDishes = Array.from(new Set([...current.fromDishes.map(String), ...dayDishIds]));
       merged.set(key, current);
     }
   }
 
   const unresolved = await resolveShoppingItemIngredientData(Array.from(merged.values()), effectiveHouseholdId);
   return unresolved.resolvedItems;
 }
 
 export async function rebuildShoppingList(weekStartDate, effectiveHouseholdId) {
   const fallbackCategory = await ensureDefaultCategory({ Category, householdId: effectiveHouseholdId });
   const list = await ensureShoppingList(weekStartDate, effectiveHouseholdId);
   const builtItems = await buildAggregatedFromWeek(weekStartDate, effectiveHouseholdId);
   const resolvedBuiltItems = await resolveShoppingItemIngredientData(builtItems, effectiveHouseholdId, {
     fallbackCategoryId: fallbackCategory?._id || null
   });
 
   const previousMap = new Map(list.items.map((item) => [item.ingredientId ? String(item.ingredientId) : item.canonicalName, item]));
-  list.items = resolvedBuiltItems.resolvedItems.map((item) => {
+  const rebuiltItems = resolvedBuiltItems.resolvedItems.map((item, index) => {
+    const normalizedItem = ensureValidShoppingItemShape(item, index, fallbackCategory?._id || null);
     const previous = previousMap.get(item.ingredientId ? String(item.ingredientId) : item.canonicalName);
     const nextStatus = previous?.status === "purchased" ? "purchased" : "pending";
     return {
-      ...item,
-      categoryId: item.categoryId || fallbackCategory?._id || null,
-      fromDishes: item.fromDishes,
+      ...normalizedItem,
+      categoryId: normalizedItem.categoryId || fallbackCategory?._id || null,
+      fromDishes: normalizedItem.fromDishes,
       status: nextStatus,
       purchasedBy: nextStatus === "purchased" ? previous?.purchasedBy || null : null,
       purchasedAt: nextStatus === "purchased" ? previous?.purchasedAt || null : null,
-      storeId: nextStatus === "purchased" ? previous?.storeId || null : null
+      storeId: nextStatus === "purchased" ? previous?.storeId || null : null
     };
   });
 
+  const { valid } = filterValidShoppingItems(rebuiltItems, "rebuildShoppingList");
+  list.items = valid;
+
   await list.save();
   return list;
 }
+
+export async function repairShoppingListItems(list, effectiveHouseholdId, options = {}) {
+  const fallbackCategory = options.fallbackCategory || null;
+  const resolved = await resolveShoppingItemIngredientData(
+    (list.items || []).map((item) => (item?.toObject ? item.toObject() : item)),
+    effectiveHouseholdId,
+    { fallbackCategoryId: fallbackCategory?._id || null }
+  );
+
+  const normalizedItems = resolved.resolvedItems.map((item, index) =>
+    ensureValidShoppingItemShape(item, index, fallbackCategory?._id || null)
+  );
+  const { valid, filteredCount } = filterValidShoppingItems(normalizedItems, options.context || "repairShoppingListItems");
+
+  const changedByCount = valid.length !== (list.items || []).length;
+  const changed = resolved.changed || filteredCount > 0 || changedByCount;
+  if (changed) {
+    list.items = valid;
+    await list.save();
+  }
+
+  return { changed, filteredCount };
+}
