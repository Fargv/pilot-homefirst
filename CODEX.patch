diff --git a/backend/src/kitchen/models/KitchenShoppingList.js b/backend/src/kitchen/models/KitchenShoppingList.js
index d20e5ffc1104ec424f7c31326a8829bdb68d004d..b6f3dae4895d85cd92e57908b5cff5a4d60105ac 100644
--- a/backend/src/kitchen/models/KitchenShoppingList.js
+++ b/backend/src/kitchen/models/KitchenShoppingList.js
@@ -1,26 +1,35 @@
 import mongoose from "mongoose";
 
 const ShoppingItemSchema = new mongoose.Schema(
   {
+    ingredientId: { type: mongoose.Schema.Types.ObjectId, ref: "KitchenIngredient", default: null },
+    categoryId: { type: mongoose.Schema.Types.ObjectId, ref: "Category", default: null },
     displayName: { type: String, required: true, trim: true },
     canonicalName: { type: String, required: true, index: true },
-    status: { type: String, enum: ["need", "have", "bought"], default: "need" }
+    quantity: { type: Number, default: null },
+    unit: { type: String, default: null },
+    occurrences: { type: Number, default: 1 },
+    fromDishes: { type: [mongoose.Schema.Types.ObjectId], ref: "KitchenDish", default: [] },
+    status: { type: String, enum: ["pending", "purchased"], default: "pending" },
+    purchasedBy: { type: mongoose.Schema.Types.ObjectId, ref: "KitchenUser", default: null },
+    purchasedAt: { type: Date, default: null },
+    tripId: { type: mongoose.Schema.Types.ObjectId, ref: "ShoppingTrip", default: null }
   },
   { _id: false }
 );
 
 const KitchenShoppingListSchema = new mongoose.Schema(
   {
-    weekStart: { type: Date, required: true },
-    householdId: { type: mongoose.Schema.Types.ObjectId, ref: "Household", index: true },
+    weekStart: { type: Date, required: true },
+    householdId: { type: mongoose.Schema.Types.ObjectId, ref: "Household", index: true },
     items: { type: [ShoppingItemSchema], default: [] }
   },
   { timestamps: true }
 );
 
-KitchenShoppingListSchema.index(
-  { householdId: 1, weekStart: 1 },
-  { unique: true, partialFilterExpression: { householdId: { $exists: true } } }
-);
-
+KitchenShoppingListSchema.index(
+  { householdId: 1, weekStart: 1 },
+  { unique: true, partialFilterExpression: { householdId: { $exists: true } } }
+);
+
 export const KitchenShoppingList = mongoose.model("KitchenShoppingList", KitchenShoppingListSchema);
diff --git a/backend/src/kitchen/routes/shopping.js b/backend/src/kitchen/routes/shopping.js
index ed1653185d5ce3a83831c2d0e10242d8e151c5bd..ffbf44fa68680776e5a24beb25ffdf0925ed6224 100644
--- a/backend/src/kitchen/routes/shopping.js
+++ b/backend/src/kitchen/routes/shopping.js
@@ -1,138 +1,255 @@
 import express from "express";
-import { KitchenShoppingList } from "../models/KitchenShoppingList.js";
-import { KitchenWeekPlan } from "../models/KitchenWeekPlan.js";
-import { KitchenDish } from "../models/KitchenDish.js";
+import { Category } from "../models/Category.js";
+import { Store } from "../models/Store.js";
+import { ShoppingTrip } from "../models/ShoppingTrip.js";
+import { KitchenUser } from "../models/KitchenUser.js";
 import { requireAuth } from "../middleware.js";
 import { formatDateISO, getWeekStart, parseISODate } from "../utils/dates.js";
-import { combineDayIngredients } from "../utils/ingredients.js";
-import {
-  buildScopedFilter,
-  getEffectiveHouseholdId,
-  handleHouseholdError
-} from "../householdScope.js";
+import {
+  buildScopedFilter,
+  getEffectiveHouseholdId,
+  handleHouseholdError
+} from "../householdScope.js";
+import { ensureShoppingList, rebuildShoppingList } from "../shoppingService.js";
 
 const router = express.Router();
 
-async function ensureShoppingList(weekStartDate, effectiveHouseholdId) {
-  const existing = await KitchenShoppingList.findOne(
-    buildScopedFilter(effectiveHouseholdId, { weekStart: weekStartDate })
-  );
-  if (existing) return existing;
-  return KitchenShoppingList.create({
-    weekStart: weekStartDate,
-    items: [],
-    householdId: effectiveHouseholdId
-  });
+function normalizeAmount(value) {
+  if (value === null || value === undefined || value === "") return null;
+  const parsed = Number(value);
+  return Number.isFinite(parsed) ? parsed : null;
 }
 
-async function buildFromWeek(weekStartDate, effectiveHouseholdId) {
-  const plan = await KitchenWeekPlan.findOne(
-    buildScopedFilter(effectiveHouseholdId, { weekStart: weekStartDate })
-  );
-  if (!plan) return [];
-
-  const dishIds = plan.days.flatMap((day) => [day.mainDishId, day.sideDishId]).filter(Boolean);
-  const dishes = await KitchenDish.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: dishIds } }));
-  const dishMap = new Map(dishes.map((dish) => [dish._id.toString(), dish]));
-
-  const ingredients = [];
-  plan.days.forEach((day) => {
-    const main = day.mainDishId ? dishMap.get(day.mainDishId.toString()) : null;
-    const side = day.sideDishId ? dishMap.get(day.sideDishId.toString()) : null;
-    ingredients.push(
-      ...combineDayIngredients({
-        mainDish: main,
-        sideDish: side,
-        overrides: day.ingredientOverrides
-      })
-    );
-  });
-
-  return ingredients;
+async function getActiveTrip(effectiveHouseholdId) {
+  return ShoppingTrip.findOne(
+    buildScopedFilter(effectiveHouseholdId, { closedAt: null })
+  ).sort({ startedAt: -1 });
+}
+
+async function getShoppingPayload(weekStartDate, effectiveHouseholdId) {
+  const list = await ensureShoppingList(weekStartDate, effectiveHouseholdId);
+  const categories = await Category.find(buildScopedFilter(effectiveHouseholdId, {})).select("_id name");
+  const stores = await Store.find(buildScopedFilter(effectiveHouseholdId, { active: true }))
+    .sort({ name: 1 })
+    .select("_id name");
+  const activeTrip = await getActiveTrip(effectiveHouseholdId);
+
+  const purchasedTripIds = list.items
+    .filter((item) => item.tripId)
+    .map((item) => String(item.tripId));
+
+  const trips = purchasedTripIds.length
+    ? await ShoppingTrip.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: purchasedTripIds } }))
+        .sort({ startedAt: -1 })
+        .lean()
+    : [];
+
+  const storeById = new Map(stores.map((store) => [String(store._id), store.name]));
+  const tripById = new Map(trips.map((trip) => [String(trip._id), trip]));
+
+  const categoryById = new Map(categories.map((category) => [String(category._id), category.name]));
+  const purchaserIds = list.items
+    .filter((item) => item.purchasedBy)
+    .map((item) => String(item.purchasedBy));
+  const purchasers = purchaserIds.length
+    ? await KitchenUser.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: purchaserIds } })).select("_id displayName")
+    : [];
+  const purchaserById = new Map(purchasers.map((person) => [String(person._id), person.displayName]));
+
+  const pendingByCategory = list.items
+    .filter((item) => item.status === "pending")
+    .reduce((acc, item) => {
+      const key = item.categoryId ? String(item.categoryId) : "uncategorized";
+      if (!acc.has(key)) {
+        acc.set(key, {
+          categoryId: item.categoryId || null,
+          categoryName: item.categoryId ? categoryById.get(String(item.categoryId)) || "Sin categorÃ­a" : "Sin categorÃ­a",
+          items: []
+        });
+      }
+      acc.get(key).items.push({
+        ...item.toObject(),
+        purchasedByName: item.purchasedBy ? purchaserById.get(String(item.purchasedBy)) || "Usuario" : null
+      });
+      return acc;
+    }, new Map());
+
+  const purchasedByTrip = list.items
+    .filter((item) => item.status === "purchased")
+    .reduce((acc, item) => {
+      const key = item.tripId ? String(item.tripId) : "no-trip";
+      if (!acc.has(key)) {
+        const trip = item.tripId ? tripById.get(String(item.tripId)) : null;
+        acc.set(key, {
+          tripId: trip?._id || null,
+          storeName: trip?.storeId ? storeById.get(String(trip.storeId)) || "Tienda" : "Sin tienda",
+          totalAmount: trip?.totalAmount ?? null,
+          startedAt: trip?.startedAt || item.purchasedAt,
+          items: []
+        });
+      }
+      acc.get(key).items.push({
+        ...item.toObject(),
+        purchasedByName: item.purchasedBy ? purchaserById.get(String(item.purchasedBy)) || "Usuario" : null
+      });
+      return acc;
+    }, new Map());
+
+  return {
+    list,
+    stores,
+    activeTrip,
+    pendingByCategory: Array.from(pendingByCategory.values()),
+    purchasedByTrip: Array.from(purchasedByTrip.values()).sort(
+      (a, b) => new Date(b.startedAt || 0).getTime() - new Date(a.startedAt || 0).getTime()
+    )
+  };
 }
 
 router.get("/:weekStart", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha invÃ¡lida." });
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-        const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-
-    res.json({ ok: true, weekStart: formatDateISO(monday), list });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo cargar la lista de compra." });
-  }
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha invÃ¡lida." });
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+
+    res.json({ ok: true, weekStart: formatDateISO(monday), ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo cargar la lista de compra." });
+  }
 });
 
 router.post("/:weekStart/rebuild", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha invÃ¡lida." });
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-        const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-
-    const ingredients = await buildFromWeek(monday, effectiveHouseholdId);
-    const merged = new Map();
-
-    ingredients.forEach((item) => {
-      if (!item.canonicalName) return;
-      const existing = merged.get(item.canonicalName);
-      if (existing) return;
-      const previous = list.items.find((oldItem) => oldItem.canonicalName === item.canonicalName);
-      merged.set(item.canonicalName, {
-        displayName: item.displayName,
-        canonicalName: item.canonicalName,
-        status: previous?.status || "need"
-      });
-    });
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha invÃ¡lida." });
 
-    list.items = Array.from(merged.values());
-    await list.save();
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    await rebuildShoppingList(monday, effectiveHouseholdId);
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
 
-    res.json({ ok: true, list });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo reconstruir la lista de compra." });
-  }
+    res.json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo reconstruir la lista de compra." });
+  }
 });
 
 router.put("/:weekStart/item", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha invÃ¡lida." });
-
-    const { canonicalName, status, displayName } = req.body;
-    if (!canonicalName) return res.status(400).json({ ok: false, error: "Ingrediente invÃ¡lido." });
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-        const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-
-    const item = list.items.find((current) => current.canonicalName === canonicalName);
-    if (!item) {
-      list.items.push({
-        canonicalName,
-        displayName: displayName || canonicalName,
-        status: status || "need"
-      });
-    } else {
-      item.status = status || item.status;
-    }
-
-    await list.save();
-    res.json({ ok: true, list });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo actualizar la lista de compra." });
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha invÃ¡lida." });
+
+    const { canonicalName, status, ingredientId } = req.body;
+    if (!canonicalName && !ingredientId) {
+      return res.status(400).json({ ok: false, error: "Ingrediente invÃ¡lido." });
+    }
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+
+    const item = list.items.find((current) => {
+      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
+      return current.canonicalName === canonicalName;
+    });
+
+    if (!item) return res.status(404).json({ ok: false, error: "Ingrediente no encontrado en la lista." });
+
+    const normalizedStatus = status === "purchased" ? "purchased" : "pending";
+    item.status = normalizedStatus;
+    if (normalizedStatus === "purchased") {
+      const activeTrip = await getActiveTrip(effectiveHouseholdId);
+      item.purchasedBy = req.kitchenUser._id;
+      item.purchasedAt = new Date();
+      item.tripId = activeTrip?._id || null;
+    } else {
+      item.purchasedBy = null;
+      item.purchasedAt = null;
+      item.tripId = null;
+    }
+
+    await list.save();
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    res.json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar la lista de compra." });
+  }
+});
+
+router.post("/stores", requireAuth, async (req, res) => {
+  try {
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const name = String(req.body?.name || "").trim();
+    if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
+    const canonicalName = name.toLowerCase();
+
+    const store = await Store.findOneAndUpdate(
+      buildScopedFilter(effectiveHouseholdId, { canonicalName }),
+      { $setOnInsert: { householdId: effectiveHouseholdId, name, canonicalName } },
+      { new: true, upsert: true }
+    );
+
+    return res.status(201).json({ ok: true, store });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo crear la tienda." });
+  }
+});
+
+router.put("/trip/active", requireAuth, async (req, res) => {
+  try {
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const storeId = req.body?.storeId || null;
+    const totalAmount = normalizeAmount(req.body?.totalAmount);
+
+    let trip = await getActiveTrip(effectiveHouseholdId);
+    if (!trip && (storeId || totalAmount !== null)) {
+      trip = await ShoppingTrip.create({
+        householdId: effectiveHouseholdId,
+        storeId,
+        totalAmount,
+        createdBy: req.kitchenUser._id,
+        startedAt: new Date()
+      });
+    } else if (trip) {
+      trip.storeId = storeId;
+      trip.totalAmount = totalAmount;
+      await trip.save();
+    }
+
+    return res.json({ ok: true, activeTrip: trip });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar la compra activa." });
+  }
+});
+
+router.post("/trip/active/close", requireAuth, async (req, res) => {
+  try {
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const trip = await getActiveTrip(effectiveHouseholdId);
+    if (!trip) return res.status(404).json({ ok: false, error: "No hay compra activa." });
+
+    trip.closedAt = new Date();
+    await trip.save();
+
+    return res.json({ ok: true, trip });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo cerrar la compra." });
   }
 });
 
 export default router;
diff --git a/backend/src/kitchen/routes/weeks.js b/backend/src/kitchen/routes/weeks.js
index 33d6efdfd7030af15f5d2e8a0511e738e4d7d723..270a99077ffb45b8b7bbe7c88b0a349a7569eda4 100644
--- a/backend/src/kitchen/routes/weeks.js
+++ b/backend/src/kitchen/routes/weeks.js
@@ -1,36 +1,37 @@
 import express from "express";
 import { KitchenDish } from "../models/KitchenDish.js";
 import { KitchenUser } from "../models/KitchenUser.js";
 import { requireAuth, requireRole } from "../middleware.js";
 import { formatDateISO, getWeekStart, isSameDay, parseISODate } from "../utils/dates.js";
-import {
-  buildScopedFilter,
-  getEffectiveHouseholdId,
-  handleHouseholdError
-} from "../householdScope.js";
-import { createOrGetWeekPlan, ensureWeekPlan, findWeekPlan } from "../weekPlanService.js";
+import {
+  buildScopedFilter,
+  getEffectiveHouseholdId,
+  handleHouseholdError
+} from "../householdScope.js";
+import { createOrGetWeekPlan, ensureWeekPlan, findWeekPlan } from "../weekPlanService.js";
+import { rebuildShoppingList } from "../shoppingService.js";
 
 const router = express.Router();
 
 function isHouseholdAdmin(user) {
   return user?.globalRole === "diod" || user?.role === "owner" || user?.role === "admin";
 }
 
 function isSelfAssignment(req, userId) {
   if (!userId) return false;
   return String(userId) === String(req.kitchenUser?._id);
 }
 
 function hasAdministrativePlanChange(req, day, updates) {
   if (isHouseholdAdmin(req.kitchenUser)) return false;
 
   if (Object.prototype.hasOwnProperty.call(updates, "cookUserId")) {
     const requestedCook = updates.cookUserId || null;
     if (!requestedCook || !isSelfAssignment(req, requestedCook)) {
       return true;
     }
   }
 
   const clearsMainDish = Object.prototype.hasOwnProperty.call(updates, "mainDishId")
     && !updates.mainDishId
     && Boolean(day.mainDishId);
@@ -99,86 +100,88 @@ router.put("/:weekStart/day/:date", requireAuth, async (req, res) => {
       ).select("_id");
       if (!mainDish) {
         return res.status(400).json({ ok: false, error: "El plato principal no pertenece a este hogar." });
       }
     }
 
     if (sideDishId) {
       const sideDish = await KitchenDish.findOne(
         buildScopedFilter(effectiveHouseholdId, { _id: sideDishId, sidedish: true })
       ).select("_id");
       if (!sideDish) {
         return res.status(400).json({ ok: false, error: "La guarniciÃ³n no pertenece a este hogar." });
       }
     }
 
     if (cookUserId !== undefined) day.cookUserId = cookUserId || null;
     if (cookUserId === undefined && mainDishId && !day.cookUserId) {
       day.cookUserId = req.kitchenUser._id;
     }
     if (cookTiming) day.cookTiming = cookTiming === "same_day" ? "same_day" : "previous_day";
     if (servings) day.servings = Number(servings) || 4;
     if (mainDishId !== undefined) day.mainDishId = mainDishId || null;
     if (sideDishId !== undefined) day.sideDishId = sideDishId || null;
     if (Array.isArray(ingredientOverrides)) day.ingredientOverrides = ingredientOverrides;
 
-    await plan.save();
-    return res.json({ ok: true, plan });
+    await plan.save();
+    await rebuildShoppingList(monday, effectiveHouseholdId);
+    return res.json({ ok: true, plan });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo actualizar el dÃ­a del plan." });
   }
 });
 
 router.post("/:weekStart/copy-from/:otherWeekStart", requireAuth, requireRole("admin"), async (req, res) => {
   try {
     const weekStart = parseISODate(req.params.weekStart);
     const otherWeekStart = parseISODate(req.params.otherWeekStart);
     if (!weekStart || !otherWeekStart) {
       return res.status(400).json({ ok: false, error: "Fecha invÃ¡lida." });
     }
 
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const monday = getWeekStart(weekStart);
     const sourceMonday = getWeekStart(otherWeekStart);
 
     const sourcePlan = await ensureWeekPlan(sourceMonday, effectiveHouseholdId);
     const targetPlan = await ensureWeekPlan(monday, effectiveHouseholdId);
 
     targetPlan.days = sourcePlan.days.map((day) => ({
       date: new Date(day.date),
       cookUserId: day.cookUserId,
       cookTiming: day.cookTiming,
       servings: day.servings,
       mainDishId: day.mainDishId,
       sideDishId: day.sideDishId,
       ingredientOverrides: day.ingredientOverrides
     }));
 
-    await targetPlan.save();
-    return res.json({ ok: true, plan: targetPlan });
+    await targetPlan.save();
+    await rebuildShoppingList(monday, effectiveHouseholdId);
+    return res.json({ ok: true, plan: targetPlan });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo copiar el plan semanal." });
   }
 });
 
 router.post("/:weekStart", requireAuth, async (req, res) => {
   try {
     const weekStart = parseISODate(req.params.weekStart);
     if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha de semana invÃ¡lida." });
 
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const monday = getWeekStart(weekStart);
     const { plan, created } = await createOrGetWeekPlan(monday, effectiveHouseholdId);
 
     return res.status(created ? 201 : 200).json({
       ok: true,
       weekStart: formatDateISO(monday),
       plan
     });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     if (error?.code === "WEEK_PLAN_INDEX_CONFLICT") {
@@ -211,52 +214,53 @@ router.post("/:weekStart/day/:date/move", requireAuth, async (req, res) => {
     const sourceDay = plan.days.find((item) => isSameDay(item.date, sourceDate));
     const targetDay = plan.days.find((item) => isSameDay(item.date, targetDate));
 
     if (!sourceDay || !targetDay) {
       return res.status(404).json({ ok: false, error: "No encontramos los dÃ­as de origen o destino en esa semana." });
     }
 
     targetDay.cookUserId = sourceDay.cookUserId || null;
     targetDay.cookTiming = sourceDay.cookTiming || "previous_day";
     targetDay.servings = sourceDay.servings || 4;
     targetDay.mainDishId = sourceDay.mainDishId || null;
     targetDay.sideDishId = sourceDay.sideDishId || null;
     targetDay.ingredientOverrides = Array.isArray(sourceDay.ingredientOverrides)
       ? sourceDay.ingredientOverrides.map((item) => ({
         displayName: item.displayName,
         canonicalName: item.canonicalName,
         ...(item.ingredientId ? { ingredientId: item.ingredientId } : {})
       }))
       : [];
 
     sourceDay.cookUserId = null;
     sourceDay.mainDishId = null;
     sourceDay.sideDishId = null;
     sourceDay.ingredientOverrides = [];
 
-    await plan.save();
-    return res.json({ ok: true, plan });
+    await plan.save();
+    await rebuildShoppingList(monday, effectiveHouseholdId);
+    return res.json({ ok: true, plan });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo mover la asignaciÃ³n de dÃ­a." });
   }
 });
 
 router.get("/:weekStart/summary", requireAuth, async (req, res) => {
   try {
     const weekStart = parseISODate(req.params.weekStart);
     if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha invÃ¡lida." });
 
     const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
     const monday = getWeekStart(weekStart);
     const plan = await ensureWeekPlan(monday, effectiveHouseholdId);
     const dishIds = plan.days.flatMap((day) => [day.mainDishId, day.sideDishId]).filter(Boolean);
     const dishes = await KitchenDish.find(
       buildScopedFilter(effectiveHouseholdId, { _id: { $in: dishIds } })
     );
 
     res.json({ ok: true, weekStart: formatDateISO(monday), plan, dishes });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo cargar el resumen semanal." });
diff --git a/frontend/src/kitchen/kitchen.css b/frontend/src/kitchen/kitchen.css
index 7141b3424166e184d03bced50365077a1c9bacce..3b297ec6510e92aed7a3f57aa4e8433ba3f9e57f 100644
--- a/frontend/src/kitchen/kitchen.css
+++ b/frontend/src/kitchen/kitchen.css
@@ -2726,25 +2726,96 @@ body {
 .kitchen-week-mobile-frame { gap: 22px; }
 
 .kitchen-ui-bottom-nav {
   background: #eef2ff;
   border-top: 1px solid #dbe3ff;
 }
 
 @media (max-width: 900px) {
   .kitchen-ui-header { display: none; }
   .kitchen-container {
     padding: 14px 14px 88px;
   }
 }
 
 .kitchen-user-menu-household {
   display: flex;
   flex-direction: column;
   gap: 6px;
   padding: 8px 10px;
 }
 
 .kitchen-user-menu-household span {
   font-size: 12px;
   color: #64748b;
 }
+
+.shopping-header-card {
+  margin-bottom: 16px;
+}
+
+.shopping-header-row {
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  gap: 12px;
+}
+
+.shopping-refresh-icon {
+  border: 1px solid var(--hf-border);
+  background: white;
+  border-radius: 10px;
+  width: 34px;
+  height: 34px;
+  cursor: pointer;
+}
+
+.shopping-toolbar {
+  margin-top: 12px;
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
+  gap: 10px;
+}
+
+.shopping-tabs {
+  margin-top: 12px;
+  display: flex;
+  gap: 8px;
+}
+
+.shopping-tab {
+  border: 1px solid var(--hf-border);
+  background: #fff;
+  border-radius: 999px;
+  padding: 8px 12px;
+  cursor: pointer;
+}
+
+.shopping-tab.active {
+  background: var(--hf-surface-soft);
+  border-color: var(--hf-brand);
+}
+
+.shopping-categories {
+  display: grid;
+  gap: 12px;
+}
+
+.shopping-items-list {
+  display: grid;
+  gap: 8px;
+  margin-top: 8px;
+}
+
+.shopping-item {
+  display: flex;
+  align-items: center;
+  gap: 8px;
+  padding: 8px;
+  border-radius: 10px;
+  transition: all 0.2s ease;
+}
+
+.shopping-item.purchased span {
+  text-decoration: line-through;
+  color: var(--hf-muted);
+}
diff --git a/frontend/src/kitchen/pages/ShoppingPage.jsx b/frontend/src/kitchen/pages/ShoppingPage.jsx
index 7df188bf9366b7f6ccbd85a70b9fea33bd6eeb24..53ca5db2dc3501cdba0f64da478b946b37a0bb6b 100644
--- a/frontend/src/kitchen/pages/ShoppingPage.jsx
+++ b/frontend/src/kitchen/pages/ShoppingPage.jsx
@@ -1,140 +1,230 @@
-import React, { useEffect, useState } from "react";
+import React, { useEffect, useMemo, useState } from "react";
 import KitchenLayout from "../Layout.jsx";
 import { apiRequest } from "../api.js";
-import { useAuth } from "../auth";
+import { useAuth } from "../auth";
 
 function getMondayISO(date = new Date()) {
   const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
   const day = d.getUTCDay();
   const diff = (day === 0 ? -6 : 1) - day;
   d.setUTCDate(d.getUTCDate() + diff);
   return d.toISOString().slice(0, 10);
 }
 
+function formatTripDate(value) {
+  if (!value) return "";
+  return new Date(value).toLocaleDateString("es-ES", { day: "2-digit", month: "2-digit", year: "numeric" });
+}
+
+function formatAmount(value) {
+  if (value === null || value === undefined || value === "") return "";
+  return `${Number(value).toFixed(2)} â‚¬`;
+}
+
 export default function ShoppingPage() {
-  const { user } = useAuth();
+  const { user } = useAuth();
   const [weekStart, setWeekStart] = useState(getMondayISO());
-  const [list, setList] = useState(null);
-  const [filter, setFilter] = useState("need");
+  const [tab, setTab] = useState("pending");
   const [error, setError] = useState("");
-  const isDiodGlobalMode = user?.globalRole === "diod" && !user?.activeHouseholdId;
+  const [isRefreshing, setIsRefreshing] = useState(false);
+  const [stores, setStores] = useState([]);
+  const [activeTrip, setActiveTrip] = useState(null);
+  const [pendingByCategory, setPendingByCategory] = useState([]);
+  const [purchasedByTrip, setPurchasedByTrip] = useState([]);
+  const isDiodGlobalMode = user?.globalRole === "diod" && !user?.activeHouseholdId;
 
-  const loadList = async () => {
-    if (isDiodGlobalMode) {
-      setList(null);
-      return;
-    }
+  const applyPayload = (data) => {
+    setStores(data.stores || []);
+    setActiveTrip(data.activeTrip || null);
+    setPendingByCategory(data.pendingByCategory || []);
+    setPurchasedByTrip(data.purchasedByTrip || []);
+  };
+
+  const loadList = async ({ silent = false } = {}) => {
+    if (isDiodGlobalMode) {
+      return;
+    }
+    if (!silent) setIsRefreshing(true);
     setError("");
     try {
       const data = await apiRequest(`/api/kitchen/shopping/${weekStart}`);
-      setList(data.list);
+      applyPayload(data);
     } catch (err) {
       setError(err.message || "No se pudo cargar la lista.");
+    } finally {
+      if (!silent) setIsRefreshing(false);
     }
   };
 
   useEffect(() => {
     loadList();
-  }, [weekStart, isDiodGlobalMode]);
+  }, [weekStart, isDiodGlobalMode]);
+
+  useEffect(() => {
+    if (isDiodGlobalMode) return undefined;
+    const pollId = setInterval(() => loadList({ silent: true }), 15000);
+    return () => clearInterval(pollId);
+  }, [weekStart, isDiodGlobalMode]);
 
-  const rebuild = async () => {
-    if (isDiodGlobalMode) return;
+  const refreshList = async () => {
+    if (isDiodGlobalMode) return;
+    setIsRefreshing(true);
     try {
       const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/rebuild`, { method: "POST" });
-      setList(data.list);
+      applyPayload(data);
     } catch (err) {
-      setError(err.message || "No se pudo regenerar la lista.");
+      setError(err.message || "No se pudo refrescar la lista.");
+    } finally {
+      setIsRefreshing(false);
     }
   };
 
-  const updateStatus = async (item, status) => {
-    if (isDiodGlobalMode) return;
+  const setItemStatus = async (item, status) => {
+    if (isDiodGlobalMode) return;
     try {
       const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/item`, {
         method: "PUT",
-        body: JSON.stringify({ canonicalName: item.canonicalName, status, displayName: item.displayName })
+        body: JSON.stringify({ canonicalName: item.canonicalName, ingredientId: item.ingredientId, status })
       });
-      setList(data.list);
+      applyPayload(data);
     } catch (err) {
       setError(err.message || "No se pudo actualizar.");
     }
   };
 
-  const items = (list?.items || []).filter((item) => (filter ? item.status === filter : true));
-
-  if (isDiodGlobalMode) {
-    return (
-      <KitchenLayout>
-        <div className="kitchen-card">
-          <h3>Selecciona un hogar para ver la lista de la compra</h3>
-          <p className="kitchen-muted">En modo global DIOD no hay lista de compra asociada.</p>
-        </div>
-      </KitchenLayout>
-    );
-  }
-
+  const updateTrip = async (payload) => {
+    if (isDiodGlobalMode) return;
+    try {
+      const data = await apiRequest("/api/kitchen/shopping/trip/active", {
+        method: "PUT",
+        body: JSON.stringify(payload)
+      });
+      setActiveTrip(data.activeTrip || null);
+      await loadList({ silent: true });
+    } catch (err) {
+      setError(err.message || "No se pudo actualizar la compra activa.");
+    }
+  };
+
+  const closeTrip = async () => {
+    if (!activeTrip) return;
+    try {
+      await apiRequest("/api/kitchen/shopping/trip/active/close", { method: "POST" });
+      await loadList();
+    } catch (err) {
+      setError(err.message || "No se pudo cerrar la compra.");
+    }
+  };
+
+  const pendingCount = useMemo(
+    () => pendingByCategory.reduce((acc, group) => acc + (group.items?.length || 0), 0),
+    [pendingByCategory]
+  );
+
+  if (isDiodGlobalMode) {
+    return (
+      <KitchenLayout>
+        <div className="kitchen-card">
+          <h3>Selecciona un hogar para ver la lista de la compra</h3>
+          <p className="kitchen-muted">En modo global DIOD no hay lista de compra asociada.</p>
+        </div>
+      </KitchenLayout>
+    );
+  }
+
   return (
     <KitchenLayout>
-      <div className="kitchen-card" style={{ marginBottom: 16 }}>
-        <h3>Lista de la compra</h3>
-        <p className="kitchen-muted">Generada desde la planificaciÃ³n semanal.</p>
-        <div className="kitchen-actions">
-          <button className="kitchen-button" onClick={rebuild}>Recalcular lista</button>
-          <label>
-            <input
-              className="kitchen-input"
-              type="date"
-              value={weekStart}
-              onChange={(event) => setWeekStart(event.target.value)}
-              aria-label="Semana"
-            />
-          </label>
-          <label>
-            <span className="kitchen-label">Filtro</span>
-            <select className="kitchen-select" value={filter} onChange={(event) => setFilter(event.target.value)}>
-              <option value="need">Pendiente</option>
-              <option value="have">Ya lo tenemos</option>
-              <option value="bought">Comprado</option>
-              <option value="">Todos</option>
-            </select>
-          </label>
+      <div className="kitchen-card shopping-header-card">
+        <div className="shopping-header-row">
+          <div>
+            <h3>Lista de la compra</h3>
+            <p className="kitchen-muted">Sincronizada automÃ¡ticamente al asignar platos.</p>
+          </div>
+          <button className="shopping-refresh-icon" onClick={refreshList} title="Refrescar" disabled={isRefreshing}>â†»</button>
         </div>
+
+        <div className="shopping-toolbar">
+          <input className="kitchen-input" type="date" value={weekStart} onChange={(event) => setWeekStart(event.target.value)} />
+          <select
+            className="kitchen-select"
+            value={activeTrip?.storeId || ""}
+            onChange={(event) => updateTrip({ storeId: event.target.value || null, totalAmount: activeTrip?.totalAmount ?? null })}
+          >
+            <option value="">Supermercado (opcional)</option>
+            {stores.map((store) => (
+              <option key={store._id} value={store._id}>{store.name}</option>
+            ))}
+          </select>
+          <input
+            className="kitchen-input"
+            type="number"
+            min="0"
+            step="0.01"
+            placeholder="Importe total â‚¬"
+            value={activeTrip?.totalAmount ?? ""}
+            onChange={(event) => updateTrip({ storeId: activeTrip?.storeId || null, totalAmount: event.target.value })}
+          />
+          {activeTrip ? (
+            <button className="kitchen-button secondary" onClick={closeTrip}>Cerrar compra</button>
+          ) : null}
+        </div>
+
+        <div className="shopping-tabs">
+          <button className={`shopping-tab ${tab === "pending" ? "active" : ""}`} onClick={() => setTab("pending")}>ðŸ›’ Pendiente ({pendingCount})</button>
+          <button className={`shopping-tab ${tab === "purchased" ? "active" : ""}`} onClick={() => setTab("purchased")}>âœ… Comprado</button>
+        </div>
+
         {error ? <div style={{ color: "#b42318", marginTop: 8 }}>{error}</div> : null}
       </div>
 
-      <div className="kitchen-card">
-        {items.length === 0 ? (
-          <div className="kitchen-empty">
-            <h4>No hay ingredientes en este estado.</h4>
-            <p className="kitchen-muted">Recalcula la lista o cambia el filtro.</p>
-          </div>
-        ) : (
-          <table className="kitchen-table">
-            <thead>
-              <tr>
-                <th>Ingrediente</th>
-                <th>Estado</th>
-                <th>AcciÃ³n rÃ¡pida</th>
-              </tr>
-            </thead>
-            <tbody>
-              {items.map((item) => (
-                <tr key={item.canonicalName}>
-                  <td>{item.displayName}</td>
-                  <td>{item.status}</td>
-                  <td>
-                    <div className="kitchen-actions">
-                      <button className="kitchen-button secondary" onClick={() => updateStatus(item, "need")}>Pendiente</button>
-                      <button className="kitchen-button secondary" onClick={() => updateStatus(item, "have")}>Tenemos</button>
-                      <button className="kitchen-button secondary" onClick={() => updateStatus(item, "bought")}>Comprado</button>
-                    </div>
-                  </td>
-                </tr>
-              ))}
-            </tbody>
-          </table>
-        )}
-      </div>
+      {tab === "pending" ? (
+        <div className="shopping-categories">
+          {pendingByCategory.length === 0 ? (
+            <div className="kitchen-card kitchen-empty">
+              <h4>No hay pendientes para esta semana.</h4>
+            </div>
+          ) : (
+            pendingByCategory.map((group) => (
+              <div className="kitchen-card shopping-category-card" key={group.categoryName}>
+                <h4>{group.categoryName.toUpperCase()} ({group.items.length})</h4>
+                <div className="shopping-items-list">
+                  {group.items.map((item) => (
+                    <label className="shopping-item" key={`${item.canonicalName}-${item.ingredientId || "no-id"}`}>
+                      <input type="checkbox" checked={false} onChange={() => setItemStatus(item, "purchased")} />
+                      <span>{item.displayName} {item.occurrences > 1 ? `x${item.occurrences}` : ""}</span>
+                    </label>
+                  ))}
+                </div>
+              </div>
+            ))
+          )}
+        </div>
+      ) : (
+        <div className="shopping-categories">
+          {purchasedByTrip.length === 0 ? (
+            <div className="kitchen-card kitchen-empty">
+              <h4>AÃºn no hay ingredientes comprados.</h4>
+            </div>
+          ) : (
+            purchasedByTrip.map((trip) => (
+              <div className="kitchen-card shopping-category-card" key={trip.tripId || `trip-${trip.startedAt}`}>
+                <h4>{trip.storeName} Â· {formatTripDate(trip.startedAt)} {trip.totalAmount !== null ? `Â· ${formatAmount(trip.totalAmount)}` : ""}</h4>
+                <div className="shopping-items-list">
+                  {trip.items.map((item) => (
+                    <label className="shopping-item purchased" key={`${item.canonicalName}-${item.ingredientId || "no-id"}`}>
+                      <input type="checkbox" checked onChange={() => setItemStatus(item, "pending")} />
+                      <span>
+                        {item.displayName} {item.occurrences > 1 ? `x${item.occurrences}` : ""}
+                        <small className="kitchen-muted"> Â· marcado por {item.purchasedByName || "Usuario"} {item.purchasedAt ? new Date(item.purchasedAt).toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" }) : ""}</small>
+                      </span>
+                    </label>
+                  ))}
+                </div>
+              </div>
+            ))
+          )}
+        </div>
+      )}
     </KitchenLayout>
   );
 }
