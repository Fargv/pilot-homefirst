diff --git a/backend/src/db.js b/backend/src/db.js
index cfeecb8814828f7b692471409d013a940b5fc861..80bd0db144bac642bbbaec7cbeab60b4b39c48bc 100644
--- a/backend/src/db.js
+++ b/backend/src/db.js
@@ -1,10 +1,15 @@
 import mongoose from "mongoose";
 import { config } from "./config.js";
 
 export async function connectDb() {
   if (!config.mongodbUri) return;
 
   mongoose.set("strictQuery", true);
   await mongoose.connect(config.mongodbUri);
+  const match = config.mongodbUri.match(/\/([^/?]+)(\?|$)/);
+  const dbName = match ? match[1] : "desconocida";
   console.log("âœ… MongoDB conectado");
+  if (config.nodeEnv === "development") {
+    console.log(`ðŸ”Ž MongoDB DB: ${dbName}`);
+  }
 }
diff --git a/backend/src/kitchen/routes/kitchenIngredients.js b/backend/src/kitchen/routes/kitchenIngredients.js
index 30d1c819793b3d0ba0538a74232d28cde96d9794..3f4e917c32fd6a68315356628cfe7a44433c3911 100644
--- a/backend/src/kitchen/routes/kitchenIngredients.js
+++ b/backend/src/kitchen/routes/kitchenIngredients.js
@@ -1,60 +1,66 @@
 import express from "express";
 import { KitchenIngredient } from "../models/KitchenIngredient.js";
 import { requireAuth } from "../middleware.js";
 import { normalizeIngredientName } from "../utils/normalize.js";
 
 const router = express.Router();
 const MAX_RESULTS = 15;
 const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
 
 router.get("/", requireAuth, async (req, res) => {
   const { q } = req.query;
   const filters = { active: true };
+  if (process.env.NODE_ENV === "development") {
+    console.log("ðŸ”Ž [kitchenIngredients] search", { q });
+  }
 
   if (q) {
     const trimmed = String(q).trim();
     const normalized = normalizeIngredientName(trimmed);
     const normalizedRegex = normalized ? new RegExp(escapeRegex(normalized), "i") : null;
     const nameRegex = trimmed ? new RegExp(escapeRegex(trimmed), "i") : null;
     const orFilters = [];
     if (normalizedRegex) orFilters.push({ canonicalName: normalizedRegex });
     if (nameRegex) orFilters.push({ name: nameRegex });
     if (orFilters.length) filters.$or = orFilters;
   }
 
   const ingredients = await KitchenIngredient.find(filters)
     .populate("categoryId", "name colorBg colorText")
     .sort({ name: 1 })
     .limit(MAX_RESULTS);
 
   return res.json({ ok: true, ingredients });
 });
 
 router.post("/", requireAuth, async (req, res) => {
   try {
     const { name, categoryId } = req.body;
+    if (process.env.NODE_ENV === "development") {
+      console.log("ðŸ§ª [kitchenIngredients] create", { name, categoryId });
+    }
     if (!name) return res.status(400).json({ ok: false, error: "El nombre del ingrediente es obligatorio." });
     if (!categoryId)
       return res.status(400).json({ ok: false, error: "Selecciona una categorÃ­a para el ingrediente." });
 
     const trimmedName = String(name).trim();
     const canonicalName = normalizeIngredientName(trimmedName);
     if (!canonicalName)
       return res.status(400).json({ ok: false, error: "El nombre del ingrediente no es vÃ¡lido." });
 
     const existing = await KitchenIngredient.findOne({
       canonicalName: new RegExp(`^${escapeRegex(canonicalName)}$`, "i")
     }).populate("categoryId", "name colorBg colorText");
 
     if (existing) return res.json({ ok: true, ingredient: existing, created: false });
 
     const ingredient = await KitchenIngredient.create({
       name: trimmedName,
       canonicalName,
       categoryId
     });
 
     const populatedIngredient = await KitchenIngredient.findById(ingredient._id).populate(
       "categoryId",
       "name colorBg colorText"
     );
diff --git a/frontend/src/kitchen/components/IngredientPicker.jsx b/frontend/src/kitchen/components/IngredientPicker.jsx
index 3a7ef0538698a7b6915028fb3d1faf6091caaaa5..28ace9afb7eefd88c699023d73507987930c263b 100644
--- a/frontend/src/kitchen/components/IngredientPicker.jsx
+++ b/frontend/src/kitchen/components/IngredientPicker.jsx
@@ -12,50 +12,53 @@ export default function IngredientPicker({ value = [], onChange, categories = []
   const [searchError, setSearchError] = useState("");
   const [showCreate, setShowCreate] = useState(false);
   const [createName, setCreateName] = useState("");
   const [createError, setCreateError] = useState("");
   const [saving, setSaving] = useState(false);
   const [categoryQuery, setCategoryQuery] = useState("");
   const [selectedCategory, setSelectedCategory] = useState(null);
   const [lastUsedCategory, setLastUsedCategory] = useState(null);
   const [creatingCategory, setCreatingCategory] = useState(false);
   const [replaceItem, setReplaceItem] = useState(null);
 
   useEffect(() => {
     if (!query) {
       setSuggestions([]);
       setSearchError("");
       setSearching(false);
       return;
     }
 
     let active = true;
     setSearching(true);
     setSearchError("");
 
     const timeout = setTimeout(async () => {
       try {
+        if (import.meta.env.DEV) {
+          console.debug("[IngredientPicker] buscando", { query });
+        }
         const data = await apiRequest(`/api/kitchenIngredients?q=${encodeURIComponent(query)}`);
         if (!active) return;
         setSuggestions(data.ingredients || []);
       } catch (err) {
         if (!active) return;
         setSearchError(err.message || "No se pudieron buscar ingredientes.");
       } finally {
         if (active) setSearching(false);
       }
     }, 250);
 
     return () => {
       active = false;
       clearTimeout(timeout);
     };
   }, [query]);
 
   const filteredCategories = useMemo(() => {
     if (!categoryQuery) return categories;
     const lower = categoryQuery.toLowerCase();
     return categories.filter((category) => category.name.toLowerCase().includes(lower));
   }, [categories, categoryQuery]);
 
   const addIngredient = (ingredient, displayNameOverride, targetToReplace = null) => {
     const canonicalName = ingredient.canonicalName || normalizeIngredientName(displayNameOverride || ingredient.name);
@@ -84,50 +87,56 @@ export default function IngredientPicker({ value = [], onChange, categories = []
     addIngredient(ingredient, ingredient.name);
     setQuery("");
     setSuggestions([]);
     setShowCreate(false);
     setCreateName("");
   };
 
   const openCreateFlow = (name, itemToReplace = null) => {
     setCreateName(name);
     setCreateError("");
     setShowCreate(true);
     setSelectedCategory(lastUsedCategory);
     setCategoryQuery("");
     setReplaceItem(itemToReplace);
   };
 
   const handleCreateIngredient = async () => {
     if (!createName.trim()) return;
     if (!selectedCategory?._id) {
       setCreateError("Selecciona una categorÃ­a para continuar.");
       return;
     }
     setSaving(true);
     setCreateError("");
     try {
+      if (import.meta.env.DEV) {
+        console.debug("[IngredientPicker] creando ingrediente", {
+          name: createName.trim(),
+          categoryId: selectedCategory?._id
+        });
+      }
       const data = await apiRequest("/api/kitchenIngredients", {
         method: "POST",
         body: JSON.stringify({ name: createName, categoryId: selectedCategory._id })
       });
       const ingredient = data.ingredient;
       addIngredient(ingredient, createName.trim(), replaceItem);
       setLastUsedCategory(selectedCategory);
       setShowCreate(false);
       setCreateName("");
       setQuery("");
     } catch (err) {
       setCreateError(err.message || "No se pudo crear el ingrediente.");
     } finally {
       setSaving(false);
     }
   };
 
   const handleCreateCategory = async () => {
     if (!onCategoryCreated) return;
     if (!categoryQuery.trim()) return;
     setCreatingCategory(true);
     try {
       const category = await onCategoryCreated(categoryQuery.trim());
       setSelectedCategory(category);
       setCategoryQuery("");
