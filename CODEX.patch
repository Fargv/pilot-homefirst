diff --git a/backend/src/kitchen/models/Category.js b/backend/src/kitchen/models/Category.js
index 13d7fc20b4d7aded4fa45620448684236b2a7acb..003d7316dc1c5af77ab9b0b4d19106a07735ed17 100644
--- a/backend/src/kitchen/models/Category.js
+++ b/backend/src/kitchen/models/Category.js
@@ -1,30 +1,31 @@
 import mongoose from "mongoose";
 
 const CategorySchema = new mongoose.Schema(
   {
     scope: {
       type: String,
       enum: ["master", "household", "override"],
       default: "household",
       index: true
     },
     householdId: { type: mongoose.Schema.Types.ObjectId, ref: "Household", index: true },
     masterId: { type: mongoose.Schema.Types.ObjectId, ref: "Category", index: true },
     name: { type: String, required: true, trim: true },
     slug: { type: String, required: true, index: true },
     colorBg: { type: String, required: true },
     colorText: { type: String, required: true },
     order: { type: Number, default: 0 },
-    active: { type: Boolean, default: true },
+    forRecipes: { type: Boolean, default: true },
+    active: { type: Boolean, default: true },
     isArchived: { type: Boolean, default: false }
   },
   { timestamps: true }
 );
 
 CategorySchema.index({ householdId: 1, scope: 1 });
 CategorySchema.index(
   { householdId: 1, masterId: 1, scope: 1 },
   { unique: true, partialFilterExpression: { scope: "override" } }
 );
 
 export const Category = mongoose.model("Category", CategorySchema);
diff --git a/backend/src/kitchen/routes/categories.js b/backend/src/kitchen/routes/categories.js
index cf61401caadebc49aebd00631431c8d0f97c2e2d..6057eb41cea046f013b9cacfdeac00bd8f7b41c7 100644
--- a/backend/src/kitchen/routes/categories.js
+++ b/backend/src/kitchen/routes/categories.js
@@ -19,121 +19,123 @@ const DEFAULT_COLOR_TEXT = "#1D4ED8";
 const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
 
 router.get("/", requireAuth, async (req, res) => {
   try {
     const effectiveHouseholdId = getOptionalHouseholdId(req.user);
     const categories = await resolveCatalogForHousehold({
       Model: Category,
       householdId: effectiveHouseholdId,
       type: "category",
       masterFilter: { active: true },
       householdFilter: { active: true },
       overrideFilter: { active: true },
       sort: { order: 1, name: 1 }
     });
 
     return res.json({ ok: true, categories });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudieron cargar las categorías." });
   }
 });
 
 router.post("/", requireAuth, async (req, res) => {
   try {
-    const { name, colorBg, colorText, scope } = req.body;
+    const { name, colorBg, colorText, scope, forRecipes } = req.body;
     if (!name) return res.status(400).json({ ok: false, error: "El nombre de la categoría es obligatorio." });
 
     const isDiod = isDiodUser(req.kitchenUser);
     const isMasterWrite = scope === CATALOG_SCOPES.MASTER;
 
     const effectiveHouseholdId = isMasterWrite ? getOptionalHouseholdId(req.user) : getEffectiveHouseholdId(req.user);
 
     if (isMasterWrite && !isDiod) {
       return res.status(403).json({ ok: false, error: "Solo DIOD puede crear categorías master." });
     }
 
     const trimmedName = String(name).trim();
     const slug = slugifyCategory(trimmedName);
     if (!slug) return res.status(400).json({ ok: false, error: "El nombre de la categoría no es válido." });
 
     const baseFilter = {
       $or: [{ slug: new RegExp(`^${escapeRegex(slug)}$`, "i") }, { name: new RegExp(`^${escapeRegex(trimmedName)}$`, "i") }],
       scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
       isArchived: { $ne: true }
     };
     if (!isMasterWrite) baseFilter.householdId = effectiveHouseholdId;
 
     const existing = await Category.findOne(baseFilter);
 
     if (existing) return res.json({ ok: true, category: existing, created: false });
 
     const category = await Category.create({
       name: trimmedName,
       slug,
       colorBg: colorBg || DEFAULT_COLOR_BG,
-      colorText: colorText || DEFAULT_COLOR_TEXT,
-      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
-      householdId: isMasterWrite ? undefined : effectiveHouseholdId
+      colorText: colorText || DEFAULT_COLOR_TEXT,
+      forRecipes: typeof forRecipes === "boolean" ? forRecipes : true,
+      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
+      householdId: isMasterWrite ? undefined : effectiveHouseholdId
     });
 
     if (!isMasterWrite) {
       await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "category", masterId: category._id });
     }
 
     return res.status(201).json({ ok: true, category, created: true });
   } catch (error) {
     const handled = handleHouseholdError(res, error);
     if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo crear la categoría." });
   }
 });
 
 router.put("/:id", requireAuth, async (req, res) => {
   try {
     const { id } = req.params;
-    const { name, colorBg, colorText, active } = req.body;
+    const { name, colorBg, colorText, active, forRecipes } = req.body;
     if (!name) return res.status(400).json({ ok: false, error: "El nombre de la categoría es obligatorio." });
 
     getOptionalHouseholdId(req.user);
     const isDiod = isDiodUser(req.kitchenUser);
     const trimmedName = String(name).trim();
     const slug = slugifyCategory(trimmedName);
 
     const target = await Category.findById(id);
     if (!target || target.isArchived) {
       return res.status(404).json({ ok: false, error: "Categoría no encontrada." });
     }
 
     const nextData = {
       name: trimmedName,
       slug,
-      colorBg: colorBg || DEFAULT_COLOR_BG,
-      colorText: colorText || DEFAULT_COLOR_TEXT,
-      active: typeof active === "boolean" ? active : target.active
-    };
+      colorBg: colorBg || DEFAULT_COLOR_BG,
+      colorText: colorText || DEFAULT_COLOR_TEXT,
+      active: typeof active === "boolean" ? active : target.active,
+      forRecipes: typeof forRecipes === "boolean" ? forRecipes : target.forRecipes
+    };
 
     if (target.scope === CATALOG_SCOPES.MASTER) {
       if (isDiod) {
         Object.assign(target, nextData);
         await target.save();
         return res.json({ ok: true, category: target });
       }
 
       const category = await Category.findOneAndUpdate(
         {
           householdId: getEffectiveHouseholdId(req.user),
           scope: CATALOG_SCOPES.OVERRIDE,
           masterId: target._id
         },
         {
           ...nextData,
           householdId: getEffectiveHouseholdId(req.user),
           masterId: target._id,
           scope: CATALOG_SCOPES.OVERRIDE,
           isArchived: false
         },
         { upsert: true, new: true, setDefaultsOnInsert: true }
       );
 
       await clearHiddenMasterForHousehold({ householdId: getEffectiveHouseholdId(req.user), type: "category", masterId: target._id });
diff --git a/backend/src/kitchen/routes/kitchenIngredients.js b/backend/src/kitchen/routes/kitchenIngredients.js
index 0900ef54eeb652427c0581445c6587a9919dfe53..4749671464ad2ecdd6e2d65bd2e9383109512ed2 100644
--- a/backend/src/kitchen/routes/kitchenIngredients.js
+++ b/backend/src/kitchen/routes/kitchenIngredients.js
@@ -1,346 +1,365 @@
 import express from "express";
 import { KitchenIngredient } from "../models/KitchenIngredient.js";
-import { Category } from "../models/Category.js";
+import { Category } from "../models/Category.js";
 import { requireAuth } from "../middleware.js";
 import { normalizeIngredientName } from "../utils/normalize.js";
-import { getEffectiveHouseholdId, getOptionalHouseholdId, handleHouseholdError } from "../householdScope.js";
-import {
-  CATALOG_SCOPES,
-  clearHiddenMasterForHousehold,
-  hideMasterForHousehold,
-  isDiodUser,
-  resolveCatalogForHousehold
-} from "../utils/catalogScopes.js";
-import { ensureDefaultCategory } from "../utils/categoryMatching.js";
-import { KitchenDish } from "../models/KitchenDish.js";
-import { KitchenWeekPlan } from "../models/KitchenWeekPlan.js";
-import { getWeekStart } from "../utils/dates.js";
+import { getEffectiveHouseholdId, getOptionalHouseholdId, handleHouseholdError } from "../householdScope.js";
+import {
+  CATALOG_SCOPES,
+  clearHiddenMasterForHousehold,
+  hideMasterForHousehold,
+  isDiodUser,
+  resolveCatalogForHousehold
+} from "../utils/catalogScopes.js";
+import { ensureDefaultCategory } from "../utils/categoryMatching.js";
+import { KitchenDish } from "../models/KitchenDish.js";
+import { KitchenWeekPlan } from "../models/KitchenWeekPlan.js";
+import { getWeekStart } from "../utils/dates.js";
 
 const router = express.Router();
 const MAX_RESULTS = 15;
 const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
-const ACCENT_CHAR_MAP = {
-  a: "aàáâäãå",
-  e: "eèéêë",
-  i: "iìíîï",
-  o: "oòóôöõ",
-  u: "uùúûü",
-  n: "nñ",
-  c: "cç"
-};
-
-const buildAccentInsensitiveRegex = (value) => {
-  const escaped = escapeRegex(value);
-  const pattern = escaped
-    .split("")
-    .map((char) => {
-      const lower = char.toLowerCase();
-      if (ACCENT_CHAR_MAP[lower]) {
-        return `[${ACCENT_CHAR_MAP[lower]}]`;
-      }
-      return char;
-    })
-    .join("");
-  return new RegExp(pattern, "i");
-};
-
-async function ensureCategoryScope({ categoryId, effectiveHouseholdId, isMasterWrite = false }) {
-  if (!categoryId) {
-    return ensureDefaultCategory({
-      Category,
-      householdId: effectiveHouseholdId,
-      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD
-    });
-  }
-
-  const scopeFilters = [{ scope: CATALOG_SCOPES.MASTER }];
-  if (effectiveHouseholdId) {
-    scopeFilters.push({ householdId: effectiveHouseholdId });
-  }
-
-  const category = await Category.findOne({
-    _id: categoryId,
-    isArchived: { $ne: true },
-    $or: scopeFilters
-  });
-
-  return category;
-}
-
-async function syncIngredientReferences({ ingredientId, name, canonicalName, householdId }) {
-  const dishFilter = {
-    "ingredients.ingredientId": ingredientId,
-    isArchived: { $ne: true }
-  };
-
-  if (householdId) {
-    dishFilter.$or = [
-      { scope: CATALOG_SCOPES.MASTER },
-      { householdId },
-      { scope: CATALOG_SCOPES.OVERRIDE, householdId }
-    ];
-  }
-
-  await KitchenDish.updateMany(
-    dishFilter,
-    {
-      $set: {
-        "ingredients.$[entry].displayName": name,
-        "ingredients.$[entry].canonicalName": canonicalName
-      }
-    },
-    {
-      arrayFilters: [{ "entry.ingredientId": ingredientId }]
-    }
-  );
-
-  const todayWeekStart = getWeekStart(new Date());
-  const weekFilter = {
-    weekStart: { $gte: todayWeekStart },
-    "days.ingredientOverrides.ingredientId": ingredientId
-  };
-  if (householdId) weekFilter.householdId = householdId;
-
-  await KitchenWeekPlan.updateMany(
-    weekFilter,
-    {
-      $set: {
-        "days.$[].ingredientOverrides.$[entry].displayName": name,
-        "days.$[].ingredientOverrides.$[entry].canonicalName": canonicalName
-      }
-    },
-    {
-      arrayFilters: [{ "entry.ingredientId": ingredientId }]
-    }
-  );
-}
-
-function buildSearchFilter(q) {
-  if (!q) return {};
-
-  const trimmed = String(q).trim();
-  const normalized = normalizeIngredientName(trimmed);
-  const normalizedRegex = normalized ? new RegExp(escapeRegex(normalized), "i") : null;
-  const normalizedFallback =
-    normalized && normalized.length > 4 ? new RegExp(escapeRegex(normalized.slice(0, -1)), "i") : null;
-  const nameRegex = trimmed ? buildAccentInsensitiveRegex(trimmed) : null;
-  const orFilters = [];
-  if (normalizedRegex) orFilters.push({ canonicalName: normalizedRegex });
-  if (normalizedFallback) orFilters.push({ canonicalName: normalizedFallback });
-  if (nameRegex) orFilters.push({ name: nameRegex });
-  if (!orFilters.length) return {};
-
-  return { $or: orFilters };
-}
+const ACCENT_CHAR_MAP = {
+  a: "aàáâäãå",
+  e: "eèéêë",
+  i: "iìíîï",
+  o: "oòóôöõ",
+  u: "uùúûü",
+  n: "nñ",
+  c: "cç"
+};
+
+const buildAccentInsensitiveRegex = (value) => {
+  const escaped = escapeRegex(value);
+  const pattern = escaped
+    .split("")
+    .map((char) => {
+      const lower = char.toLowerCase();
+      if (ACCENT_CHAR_MAP[lower]) {
+        return `[${ACCENT_CHAR_MAP[lower]}]`;
+      }
+      return char;
+    })
+    .join("");
+  return new RegExp(pattern, "i");
+};
+
+async function ensureCategoryScope({ categoryId, effectiveHouseholdId, isMasterWrite = false }) {
+  if (!categoryId) {
+    return ensureDefaultCategory({
+      Category,
+      householdId: effectiveHouseholdId,
+      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD
+    });
+  }
+
+  const scopeFilters = [{ scope: CATALOG_SCOPES.MASTER }];
+  if (effectiveHouseholdId) {
+    scopeFilters.push({ householdId: effectiveHouseholdId });
+  }
+
+  const category = await Category.findOne({
+    _id: categoryId,
+    isArchived: { $ne: true },
+    $or: scopeFilters
+  });
+
+  return category;
+}
+
+async function syncIngredientReferences({ ingredientId, name, canonicalName, householdId }) {
+  const dishFilter = {
+    "ingredients.ingredientId": ingredientId,
+    isArchived: { $ne: true }
+  };
+
+  if (householdId) {
+    dishFilter.$or = [
+      { scope: CATALOG_SCOPES.MASTER },
+      { householdId },
+      { scope: CATALOG_SCOPES.OVERRIDE, householdId }
+    ];
+  }
+
+  await KitchenDish.updateMany(
+    dishFilter,
+    {
+      $set: {
+        "ingredients.$[entry].displayName": name,
+        "ingredients.$[entry].canonicalName": canonicalName
+      }
+    },
+    {
+      arrayFilters: [{ "entry.ingredientId": ingredientId }]
+    }
+  );
+
+  const todayWeekStart = getWeekStart(new Date());
+  const weekFilter = {
+    weekStart: { $gte: todayWeekStart },
+    "days.ingredientOverrides.ingredientId": ingredientId
+  };
+  if (householdId) weekFilter.householdId = householdId;
+
+  await KitchenWeekPlan.updateMany(
+    weekFilter,
+    {
+      $set: {
+        "days.$[].ingredientOverrides.$[entry].displayName": name,
+        "days.$[].ingredientOverrides.$[entry].canonicalName": canonicalName
+      }
+    },
+    {
+      arrayFilters: [{ "entry.ingredientId": ingredientId }]
+    }
+  );
+}
+
+function buildSearchFilter(q) {
+  if (!q) return {};
+
+  const trimmed = String(q).trim();
+  const normalized = normalizeIngredientName(trimmed);
+  const normalizedRegex = normalized ? new RegExp(escapeRegex(normalized), "i") : null;
+  const normalizedFallback =
+    normalized && normalized.length > 4 ? new RegExp(escapeRegex(normalized.slice(0, -1)), "i") : null;
+  const nameRegex = trimmed ? buildAccentInsensitiveRegex(trimmed) : null;
+  const orFilters = [];
+  if (normalizedRegex) orFilters.push({ canonicalName: normalizedRegex });
+  if (normalizedFallback) orFilters.push({ canonicalName: normalizedFallback });
+  if (nameRegex) orFilters.push({ name: nameRegex });
+  if (!orFilters.length) return {};
+
+  return { $or: orFilters };
+}
 
 router.get("/", requireAuth, async (req, res) => {
-  try {
-    const { q, includeInactive, limit } = req.query;
-    const effectiveHouseholdId = getOptionalHouseholdId(req.user);
-    const shouldIncludeInactive = String(includeInactive || "").toLowerCase() === "true";
-
-    const ingredients = await resolveCatalogForHousehold({
-      Model: KitchenIngredient,
-      householdId: effectiveHouseholdId,
-      type: "ingredient",
-      baseFilter: buildSearchFilter(q),
-      masterFilter: shouldIncludeInactive ? {} : { active: true },
-      householdFilter: shouldIncludeInactive ? {} : { active: true },
-      overrideFilter: shouldIncludeInactive ? {} : { active: true },
-      populate: { path: "categoryId", select: "name slug colorBg colorText" },
-      sort: { name: 1 }
-    });
-
-    const limitValue = Number.parseInt(limit, 10);
-    const resolvedIngredients =
-      !Number.isNaN(limitValue) && limitValue > 0
-        ? ingredients.slice(0, limitValue)
-        : !limit
-          ? ingredients.slice(0, MAX_RESULTS)
-          : ingredients;
-
-    return res.json({ ok: true, ingredients: resolvedIngredients });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudieron cargar los ingredientes." });
-  }
+  try {
+    const { q, includeInactive, limit, mode } = req.query;
+    const effectiveHouseholdId = getOptionalHouseholdId(req.user);
+    const shouldIncludeInactive = String(includeInactive || "").toLowerCase() === "true";
+
+    const ingredients = await resolveCatalogForHousehold({
+      Model: KitchenIngredient,
+      householdId: effectiveHouseholdId,
+      type: "ingredient",
+      baseFilter: buildSearchFilter(q),
+      masterFilter: shouldIncludeInactive ? {} : { active: true },
+      householdFilter: shouldIncludeInactive ? {} : { active: true },
+      overrideFilter: shouldIncludeInactive ? {} : { active: true },
+      populate: { path: "categoryId", select: "name slug colorBg colorText" },
+      sort: { name: 1 }
+    });
+
+    let filteredIngredients = ingredients;
+    if (String(mode || "").toLowerCase() === "recipe") {
+      const allowedCategories = await resolveCatalogForHousehold({
+        Model: Category,
+        householdId: effectiveHouseholdId,
+        type: "category",
+        masterFilter: { active: true, forRecipes: true },
+        householdFilter: { active: true, forRecipes: true },
+        overrideFilter: { active: true, forRecipes: true },
+        sort: { order: 1, name: 1 }
+      });
+      const allowedIds = new Set(allowedCategories.map((category) => String(category._id)));
+      filteredIngredients = ingredients.filter((ingredient) => {
+        const categoryValue = ingredient?.categoryId?._id || ingredient?.categoryId;
+        return categoryValue && allowedIds.has(String(categoryValue));
+      });
+    }
+
+    const limitValue = Number.parseInt(limit, 10);
+    const resolvedIngredients =
+      !Number.isNaN(limitValue) && limitValue > 0
+        ? filteredIngredients.slice(0, limitValue)
+        : !limit
+          ? filteredIngredients.slice(0, MAX_RESULTS)
+          : filteredIngredients;
+
+    return res.json({ ok: true, ingredients: resolvedIngredients });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudieron cargar los ingredientes." });
+  }
 });
 
 router.post("/", requireAuth, async (req, res) => {
   try {
-    const { name, categoryId, canonicalName: canonicalInput, scope } = req.body;
+    const { name, categoryId, canonicalName: canonicalInput, scope } = req.body;
     if (!name) return res.status(400).json({ ok: false, error: "El nombre del ingrediente es obligatorio." });
-
-    const isDiod = isDiodUser(req.kitchenUser);
-    const isMasterWrite = scope === CATALOG_SCOPES.MASTER;
-    if (isMasterWrite && !isDiod) {
-      return res.status(403).json({ ok: false, error: "Solo DIOD puede crear ingredientes master." });
-    }
-
-    const effectiveHouseholdId = isMasterWrite ? getOptionalHouseholdId(req.user) : getEffectiveHouseholdId(req.user);
-    const category = await ensureCategoryScope({ categoryId, effectiveHouseholdId });
-    if (!category) {
-      return res.status(404).json({ ok: false, error: "Categoría no encontrada para el hogar actual." });
-    }
-
+
+    const isDiod = isDiodUser(req.kitchenUser);
+    const requestedMasterWrite = scope === CATALOG_SCOPES.MASTER;
+    const isMasterWrite = isDiod && requestedMasterWrite;
+    if (requestedMasterWrite && !isDiod) {
+      return res.status(403).json({ ok: false, error: "Solo DIOD puede crear ingredientes master." });
+    }
+
+    const effectiveHouseholdId = isMasterWrite ? getOptionalHouseholdId(req.user) : getEffectiveHouseholdId(req.user);
+    const category = await ensureCategoryScope({ categoryId, effectiveHouseholdId });
+    if (!category) {
+      return res.status(404).json({ ok: false, error: "Categoría no encontrada para el hogar actual." });
+    }
+
     const trimmedName = String(name).trim();
-    const canonicalName = normalizeIngredientName(canonicalInput || trimmedName);
+    const canonicalName = normalizeIngredientName(canonicalInput || trimmedName);
     if (!canonicalName)
       return res.status(400).json({ ok: false, error: "El nombre del ingrediente no es válido." });
 
-    const duplicateFilter = {
-      canonicalName: new RegExp(`^${escapeRegex(canonicalName)}$`, "i"),
-      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
-      isArchived: { $ne: true }
-    };
-    if (!isMasterWrite) duplicateFilter.householdId = effectiveHouseholdId;
-
-    const existing = await KitchenIngredient.findOne(duplicateFilter).populate("categoryId", "name slug colorBg colorText");
+    const duplicateFilter = {
+      canonicalName: new RegExp(`^${escapeRegex(canonicalName)}$`, "i"),
+      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
+      isArchived: { $ne: true }
+    };
+    if (!isMasterWrite) duplicateFilter.householdId = effectiveHouseholdId;
+
+    const existing = await KitchenIngredient.findOne(duplicateFilter).populate("categoryId", "name slug colorBg colorText");
 
     if (existing) return res.json({ ok: true, ingredient: existing, created: false });
 
     const ingredient = await KitchenIngredient.create({
       name: trimmedName,
       canonicalName,
-      categoryId: category._id,
-      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
-      householdId: isMasterWrite ? undefined : effectiveHouseholdId
+      categoryId: category._id,
+      scope: isMasterWrite ? CATALOG_SCOPES.MASTER : CATALOG_SCOPES.HOUSEHOLD,
+      householdId: isMasterWrite ? undefined : effectiveHouseholdId
     });
 
     const populatedIngredient = await KitchenIngredient.findById(ingredient._id).populate(
       "categoryId",
-      "name slug colorBg colorText"
+      "name slug colorBg colorText"
     );
 
-    if (!isMasterWrite) {
-      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "ingredient", masterId: ingredient._id });
-    }
-
+    if (!isMasterWrite) {
+      await clearHiddenMasterForHousehold({ householdId: effectiveHouseholdId, type: "ingredient", masterId: ingredient._id });
+    }
+
     return res.status(201).json({ ok: true, ingredient: populatedIngredient, created: true });
   } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
     return res.status(500).json({ ok: false, error: "No se pudo crear el ingrediente." });
   }
 });
 
-router.put("/:id", requireAuth, async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { name, categoryId, active, canonicalName: canonicalInput } = req.body;
-    if (!name) return res.status(400).json({ ok: false, error: "El nombre del ingrediente es obligatorio." });
-    if (typeof active !== "boolean")
-      return res.status(400).json({ ok: false, error: "Indica si el ingrediente está activo." });
-
-    const optionalHouseholdId = getOptionalHouseholdId(req.user);
-    const isDiod = isDiodUser(req.kitchenUser);
-
-    const target = await KitchenIngredient.findById(id);
-    if (!target || target.isArchived) {
-      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
-    }
-
-    const effectiveHouseholdId = target.scope === CATALOG_SCOPES.MASTER ? optionalHouseholdId : getEffectiveHouseholdId(req.user);
-    const category = await ensureCategoryScope({ categoryId, effectiveHouseholdId });
-    if (!category) {
-      return res.status(404).json({ ok: false, error: "Categoría no encontrada para el hogar actual." });
-    }
-
-    const trimmedName = String(name).trim();
-    const canonicalName = normalizeIngredientName(canonicalInput || trimmedName);
-    if (!canonicalName)
-      return res.status(400).json({ ok: false, error: "El nombre del ingrediente no es válido." });
-
-    const nextData = {
-      name: trimmedName,
-      canonicalName,
-      categoryId: category._id,
-      active
-    };
-
-    if (target.scope === CATALOG_SCOPES.MASTER) {
-      if (isDiod) {
-        Object.assign(target, nextData);
-        await target.save();
-        await syncIngredientReferences({ ingredientId: target._id, name: trimmedName, canonicalName, householdId: optionalHouseholdId });
-        const ingredient = await KitchenIngredient.findById(target._id).populate("categoryId", "name slug colorBg colorText");
-        return res.json({ ok: true, ingredient });
-      }
-
-      const requiredHouseholdId = getEffectiveHouseholdId(req.user);
-      const ingredient = await KitchenIngredient.findOneAndUpdate(
-        {
-          householdId: requiredHouseholdId,
-          scope: CATALOG_SCOPES.OVERRIDE,
-          masterId: target._id
-        },
-        {
-          ...nextData,
-          householdId: requiredHouseholdId,
-          scope: CATALOG_SCOPES.OVERRIDE,
-          masterId: target._id,
-          isArchived: false
-        },
-        { upsert: true, new: true, setDefaultsOnInsert: true }
-      ).populate("categoryId", "name slug colorBg colorText");
-
-      await syncIngredientReferences({ ingredientId: ingredient._id, name: trimmedName, canonicalName, householdId: requiredHouseholdId });
-
-      await clearHiddenMasterForHousehold({ householdId: requiredHouseholdId, type: "ingredient", masterId: target._id });
-      return res.json({ ok: true, ingredient, overridden: true });
-    }
-
-    if (!target.householdId || String(target.householdId) !== String(getEffectiveHouseholdId(req.user))) {
-      return res.status(403).json({ ok: false, error: "No tienes permisos para modificar este ingrediente." });
-    }
-
-    Object.assign(target, nextData);
-    await target.save();
-    await syncIngredientReferences({ ingredientId: target._id, name: trimmedName, canonicalName, householdId: getEffectiveHouseholdId(req.user) });
-    const ingredient = await KitchenIngredient.findById(target._id).populate("categoryId", "name slug colorBg colorText");
-
-    return res.json({ ok: true, ingredient });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo actualizar el ingrediente." });
-  }
-});
-
-router.delete("/:id", requireAuth, async (req, res) => {
-  try {
-    const { id } = req.params;
-    getOptionalHouseholdId(req.user);
-    const isDiod = isDiodUser(req.kitchenUser);
-    const target = await KitchenIngredient.findById(id);
-
-    if (!target || target.isArchived) {
-      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
-    }
-
-    if (target.scope === CATALOG_SCOPES.MASTER) {
-      if (isDiod) {
-        target.isArchived = true;
-        await target.save();
-      } else {
-        await hideMasterForHousehold({ householdId: getEffectiveHouseholdId(req.user), type: "ingredient", masterId: target._id });
-      }
-      return res.json({ ok: true });
-    }
-
-    if (!target.householdId || String(target.householdId) !== String(getEffectiveHouseholdId(req.user))) {
-      return res.status(403).json({ ok: false, error: "No tienes permisos para eliminar este ingrediente." });
-    }
-
-    target.isArchived = true;
-    await target.save();
-    return res.json({ ok: true });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo eliminar el ingrediente." });
-  }
-});
-
+router.put("/:id", requireAuth, async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { name, categoryId, active, canonicalName: canonicalInput } = req.body;
+    if (!name) return res.status(400).json({ ok: false, error: "El nombre del ingrediente es obligatorio." });
+    if (typeof active !== "boolean")
+      return res.status(400).json({ ok: false, error: "Indica si el ingrediente está activo." });
+
+    const optionalHouseholdId = getOptionalHouseholdId(req.user);
+    const isDiod = isDiodUser(req.kitchenUser);
+
+    const target = await KitchenIngredient.findById(id);
+    if (!target || target.isArchived) {
+      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
+    }
+
+    const effectiveHouseholdId = target.scope === CATALOG_SCOPES.MASTER ? optionalHouseholdId : getEffectiveHouseholdId(req.user);
+    const category = await ensureCategoryScope({ categoryId, effectiveHouseholdId });
+    if (!category) {
+      return res.status(404).json({ ok: false, error: "Categoría no encontrada para el hogar actual." });
+    }
+
+    const trimmedName = String(name).trim();
+    const canonicalName = normalizeIngredientName(canonicalInput || trimmedName);
+    if (!canonicalName)
+      return res.status(400).json({ ok: false, error: "El nombre del ingrediente no es válido." });
+
+    const nextData = {
+      name: trimmedName,
+      canonicalName,
+      categoryId: category._id,
+      active
+    };
+
+    if (target.scope === CATALOG_SCOPES.MASTER) {
+      if (isDiod) {
+        Object.assign(target, nextData);
+        await target.save();
+        await syncIngredientReferences({ ingredientId: target._id, name: trimmedName, canonicalName, householdId: optionalHouseholdId });
+        const ingredient = await KitchenIngredient.findById(target._id).populate("categoryId", "name slug colorBg colorText");
+        return res.json({ ok: true, ingredient });
+      }
+
+      const requiredHouseholdId = getEffectiveHouseholdId(req.user);
+      const ingredient = await KitchenIngredient.findOneAndUpdate(
+        {
+          householdId: requiredHouseholdId,
+          scope: CATALOG_SCOPES.OVERRIDE,
+          masterId: target._id
+        },
+        {
+          ...nextData,
+          householdId: requiredHouseholdId,
+          scope: CATALOG_SCOPES.OVERRIDE,
+          masterId: target._id,
+          isArchived: false
+        },
+        { upsert: true, new: true, setDefaultsOnInsert: true }
+      ).populate("categoryId", "name slug colorBg colorText");
+
+      await syncIngredientReferences({ ingredientId: ingredient._id, name: trimmedName, canonicalName, householdId: requiredHouseholdId });
+
+      await clearHiddenMasterForHousehold({ householdId: requiredHouseholdId, type: "ingredient", masterId: target._id });
+      return res.json({ ok: true, ingredient, overridden: true });
+    }
+
+    if (!target.householdId || String(target.householdId) !== String(getEffectiveHouseholdId(req.user))) {
+      return res.status(403).json({ ok: false, error: "No tienes permisos para modificar este ingrediente." });
+    }
+
+    Object.assign(target, nextData);
+    await target.save();
+    await syncIngredientReferences({ ingredientId: target._id, name: trimmedName, canonicalName, householdId: getEffectiveHouseholdId(req.user) });
+    const ingredient = await KitchenIngredient.findById(target._id).populate("categoryId", "name slug colorBg colorText");
+
+    return res.json({ ok: true, ingredient });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar el ingrediente." });
+  }
+});
+
+router.delete("/:id", requireAuth, async (req, res) => {
+  try {
+    const { id } = req.params;
+    getOptionalHouseholdId(req.user);
+    const isDiod = isDiodUser(req.kitchenUser);
+    const target = await KitchenIngredient.findById(id);
+
+    if (!target || target.isArchived) {
+      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
+    }
+
+    if (target.scope === CATALOG_SCOPES.MASTER) {
+      if (isDiod) {
+        target.isArchived = true;
+        await target.save();
+      } else {
+        await hideMasterForHousehold({ householdId: getEffectiveHouseholdId(req.user), type: "ingredient", masterId: target._id });
+      }
+      return res.json({ ok: true });
+    }
+
+    if (!target.householdId || String(target.householdId) !== String(getEffectiveHouseholdId(req.user))) {
+      return res.status(403).json({ ok: false, error: "No tienes permisos para eliminar este ingrediente." });
+    }
+
+    target.isArchived = true;
+    await target.save();
+    return res.json({ ok: true });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo eliminar el ingrediente." });
+  }
+});
+
 export default router;
diff --git a/backend/src/kitchen/routes/shopping.js b/backend/src/kitchen/routes/shopping.js
index 9e15d892353f23aac629efb08d3cb3d8ecaa2257..11f2a3a6eada0b85861291ba1dacde7bfd8929be 100644
--- a/backend/src/kitchen/routes/shopping.js
+++ b/backend/src/kitchen/routes/shopping.js
@@ -1,502 +1,566 @@
-import express from "express";
-import { Category } from "../models/Category.js";
-import { Store } from "../models/Store.js";
-import { KitchenUser } from "../models/KitchenUser.js";
-import { requireAuth, requireDiod } from "../middleware.js";
-import { formatDateISO, getWeekStart, parseISODate } from "../utils/dates.js";
-import {
-  buildScopedFilter,
-  getEffectiveHouseholdId,
-  handleHouseholdError
-} from "../householdScope.js";
-import { ensureShoppingList, rebuildShoppingList, repairShoppingListItems } from "../shoppingService.js";
-import { CATALOG_SCOPES } from "../utils/catalogScopes.js";
-import {
-  DEFAULT_CATEGORY_COLOR_BG,
-  DEFAULT_CATEGORY_COLOR_TEXT,
-  DEFAULT_CATEGORY_NAME,
-  DEFAULT_CATEGORY_SLUG,
-  ensureDefaultCategory
-} from "../utils/categoryMatching.js";
-
-const router = express.Router();
-
-function logShoppingError(context, error, extra = {}) {
-  console.error(`[kitchen][shopping] ${context}`, {
-    ...extra,
-    message: error?.message,
-    stack: error?.stack
-  });
-}
-
-
-function normalizeStoreName(value = "") {
-  return String(value).trim().toLowerCase();
-}
-
-function sortStores(stores = []) {
-  return [...stores].sort((a, b) => {
-    const orderA = Number.isFinite(a.order) ? a.order : Number.POSITIVE_INFINITY;
-    const orderB = Number.isFinite(b.order) ? b.order : Number.POSITIVE_INFINITY;
-    if (orderA !== orderB) return orderA - orderB;
-    return String(a.name || "").localeCompare(String(b.name || ""), "es", { sensitivity: "base" });
-  });
-}
-
-function buildStoreVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
-  return {
-    ...extraFilter,
-    $or: [
-      { scope: "master", householdId: null },
-      { scope: "household", householdId: effectiveHouseholdId }
-    ]
-  };
-}
-
-function buildCategoryVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
-  return {
-    ...extraFilter,
-    $or: [
-      { scope: CATALOG_SCOPES.MASTER, householdId: null },
-      { scope: CATALOG_SCOPES.HOUSEHOLD, householdId: effectiveHouseholdId },
-      { scope: CATALOG_SCOPES.OVERRIDE, householdId: effectiveHouseholdId }
-    ]
-  };
-}
-
-function toDateGroup(value) {
-  if (!value) return "sin-fecha";
-  return new Date(value).toISOString().slice(0, 10);
-}
-
-function isValidObjectId(value) {
-  return Boolean(value) && /^[a-f\d]{24}$/i.test(String(value));
-}
-
-function compareCategoryGroups(a, b) {
-  const orderA = Number.isFinite(a?.categoryInfo?.order) ? a.categoryInfo.order : Number.POSITIVE_INFINITY;
-  const orderB = Number.isFinite(b?.categoryInfo?.order) ? b.categoryInfo.order : Number.POSITIVE_INFINITY;
-  if (orderA !== orderB) return orderA - orderB;
-  return String(a?.categoryInfo?.name || "").localeCompare(String(b?.categoryInfo?.name || ""), "es", { sensitivity: "base" });
-}
-
-function compareShoppingItems(a, b) {
-  const left = String(a?.canonicalName || a?.displayName || "");
-  const right = String(b?.canonicalName || b?.displayName || "");
-  return left.localeCompare(right, "es", { sensitivity: "base" });
-}
-
-function normalizeShoppingItemForResponse(item, purchaserById) {
-  const normalized = item.toObject ? item.toObject() : { ...item };
-  return {
-    ...normalized,
-    categoryId: normalized.categoryId || null,
-    storeId: normalized.storeId || null,
-    purchasedBy: normalized.purchasedBy || null,
-    purchasedAt: normalized.purchasedAt || null,
-    purchasedByName: normalized.purchasedBy && isValidObjectId(normalized.purchasedBy)
-      ? purchaserById.get(String(normalized.purchasedBy)) || "Usuario"
-      : null
-  };
-}
-
-async function getShoppingPayload(weekStartDate, effectiveHouseholdId) {
-  const list = await ensureShoppingList(weekStartDate, effectiveHouseholdId);
-
-  const fallbackCategory = await ensureDefaultCategory({
-    Category,
-    householdId: effectiveHouseholdId
-  });
-  await repairShoppingListItems(list, effectiveHouseholdId, {
-    fallbackCategory,
-    context: "getShoppingPayload"
-  });
-
-  const categories = await Category.find(buildCategoryVisibilityFilter(effectiveHouseholdId, { isArchived: { $ne: true } })).select(
-    "_id name slug colorBg colorText order"
-  );
-  const stores = sortStores(
-    await Store.find(buildStoreVisibilityFilter(effectiveHouseholdId, { active: true }))
-      .select("_id name order scope householdId")
-      .lean()
-  );
-
-  const storeById = new Map(stores.map((store) => [String(store._id), store.name]));
-  const categoryById = new Map(categories.map((category) => [String(category._id), category]));
-  const purchaserIds = Array.from(new Set(
-    list.items
-      .map((item) => item.purchasedBy)
-      .filter((value) => isValidObjectId(value))
-      .map((value) => String(value))
-  ));
-  const purchasers = purchaserIds.length
-    ? await KitchenUser.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: purchaserIds } })).select("_id displayName")
-    : [];
-  const purchaserById = new Map(purchasers.map((person) => [String(person._id), person.displayName]));
-
-  const pendingByCategory = list.items
-    .filter((item) => item.status === "pending")
-    .reduce((acc, item) => {
-      const key = item.categoryId ? String(item.categoryId) : "uncategorized";
-      const resolvedCategory = item.categoryId
-        ? categoryById.get(String(item.categoryId)) || null
-        : fallbackCategory || null;
-
-      if (!acc.has(key)) {
-        acc.set(key, {
-          categoryId: resolvedCategory?._id || item.categoryId || null,
-          categoryInfo: {
-            name: resolvedCategory?.name || DEFAULT_CATEGORY_NAME,
-            slug: resolvedCategory?.slug || DEFAULT_CATEGORY_SLUG,
-            colorBg: resolvedCategory?.colorBg || DEFAULT_CATEGORY_COLOR_BG,
-            colorText: resolvedCategory?.colorText || DEFAULT_CATEGORY_COLOR_TEXT,
-            order: Number.isFinite(resolvedCategory?.order) ? resolvedCategory.order : null
-          },
-          items: []
-        });
-      }
-      acc.get(key).items.push(normalizeShoppingItemForResponse(item, purchaserById));
-      return acc;
-    }, new Map());
-
-  const purchasedByStoreDay = list.items
-    .filter((item) => item.status === "purchased")
-    .reduce((acc, item) => {
-      const dateKey = toDateGroup(item.purchasedAt);
-      const storeKey = item.storeId ? String(item.storeId) : "no-store";
-      const key = `${dateKey}::${storeKey}`;
-      if (!acc.has(key)) {
-        const purchasedByName = item.purchasedBy && isValidObjectId(item.purchasedBy)
-          ? purchaserById.get(String(item.purchasedBy)) || "Usuario"
-          : "Usuario";
-        acc.set(key, {
-          storeId: item.storeId || null,
-          storeName: item.storeId ? storeById.get(String(item.storeId)) || "Supermercado no definido" : "Supermercado no definido",
-          purchasedDate: dateKey,
-          startedAt: item.purchasedAt,
-          purchasedByName,
-          items: []
-        });
-      }
-      acc.get(key).items.push(normalizeShoppingItemForResponse(item, purchaserById));
-      return acc;
-    }, new Map());
-
-  return {
-    list,
-    stores,
-    pendingByCategory: Array.from(pendingByCategory.values())
-      .map((group) => ({
-        ...group,
-        items: [...group.items].sort(compareShoppingItems)
-      }))
-      .sort(compareCategoryGroups),
-    purchasedByStoreDay: Array.from(purchasedByStoreDay.values()).sort(
-      (a, b) => new Date(b.startedAt || 0).getTime() - new Date(a.startedAt || 0).getTime()
-    ).map((group) => ({
-      ...group,
-      items: [...group.items].sort(compareShoppingItems)
-    }))
-  };
-}
-
-async function validateStoreSelection(storeId, effectiveHouseholdId) {
-  if (!storeId) return null;
-  const store = await Store.findOne(buildStoreVisibilityFilter(effectiveHouseholdId, { _id: storeId, active: true }))
-    .select("_id")
-    .lean();
-  return store ? store._id : null;
-}
-
-router.get("/:weekStart", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-
-    res.json({ ok: true, weekStart: formatDateISO(monday), ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    logShoppingError("get-list", error, { weekStart: req.params.weekStart, userId: String(req.kitchenUser?._id || "") });
-    return res.status(500).json({ ok: false, error: "No se pudo cargar la lista de compra." });
-  }
-});
-
-router.post("/:weekStart/rebuild", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    await rebuildShoppingList(monday, effectiveHouseholdId);
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-
-    res.json({ ok: true, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    logShoppingError("rebuild", error, { weekStart: req.params.weekStart, userId: String(req.kitchenUser?._id || "") });
-    if (error?.name === "ValidationError" || error?.name === "CastError") {
-      return res.status(400).json({ ok: false, error: "Datos inválidos al reconstruir la lista." });
-    }
-    return res.status(500).json({ ok: false, error: "No se pudo reconstruir la lista de compra." });
-  }
-});
-
-router.put("/:weekStart/item", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const { canonicalName, status, ingredientId, storeId } = req.body;
-    if (!canonicalName && !ingredientId) {
-      return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
-    }
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-    await repairShoppingListItems(list, effectiveHouseholdId, {
-      context: "update-item"
-    });
-
-    const item = list.items.find((current) => {
-      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
-      return current.canonicalName === canonicalName;
-    });
-
-    if (!item) return res.status(404).json({ ok: false, error: "Ingrediente no encontrado en la lista." });
-
-    const normalizedStatus = status === "purchased" ? "purchased" : "pending";
-    item.status = normalizedStatus;
-    if (normalizedStatus === "purchased") {
-      const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
-      item.purchasedBy = req.kitchenUser._id;
-      item.purchasedAt = new Date();
-      item.storeId = validatedStoreId;
-    } else {
-      item.purchasedBy = null;
-      item.purchasedAt = null;
-      item.storeId = null;
-    }
-
-    await list.save();
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-    res.json({ ok: true, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo actualizar la lista de compra." });
-  }
-});
-
-router.put("/:weekStart/item/store", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const { canonicalName, ingredientId, storeId } = req.body;
-    if (!canonicalName && !ingredientId) {
-      return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
-    }
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-    await repairShoppingListItems(list, effectiveHouseholdId, {
-      context: "update-item-store"
-    });
-
-    const item = list.items.find((current) => {
-      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
-      return current.canonicalName === canonicalName;
-    });
-
-    if (!item || item.status !== "purchased") {
-      return res.status(404).json({ ok: false, error: "Ingrediente comprado no encontrado." });
-    }
-
-    item.storeId = await validateStoreSelection(storeId, effectiveHouseholdId);
-    await list.save();
-
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-    return res.json({ ok: true, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo actualizar el supermercado." });
-  }
-});
-
-router.put("/:weekStart/items/status", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const normalizedStatus = req.body?.status === "purchased" ? "purchased" : req.body?.status === "pending" ? "pending" : null;
-    if (!normalizedStatus) {
-      return res.status(400).json({ ok: false, error: "Estado inválido." });
-    }
-
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-    await repairShoppingListItems(list, effectiveHouseholdId, {
-      context: "bulk-update-status"
-    });
-
-    let changed = false;
-    if (normalizedStatus === "purchased") {
-      const validatedStoreId = await validateStoreSelection(req.body?.storeId, effectiveHouseholdId);
-      const now = new Date();
-      for (const item of list.items) {
-        if (item.status !== "pending") continue;
-        item.status = "purchased";
-        item.purchasedBy = req.kitchenUser._id;
-        item.purchasedAt = now;
-        item.storeId = validatedStoreId;
-        changed = true;
-      }
-    } else {
-      for (const item of list.items) {
-        if (item.status !== "purchased") continue;
-        item.status = "pending";
-        item.purchasedBy = null;
-        item.purchasedAt = null;
-        item.storeId = null;
-        changed = true;
-      }
-    }
-
-    if (changed) {
-      await list.save();
-    }
-
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-    return res.json({ ok: true, updated: changed, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo actualizar el estado en bloque." });
-  }
-});
-
-router.post("/:weekStart/purchased/assign-store", requireAuth, async (req, res) => {
-  try {
-    const weekStart = parseISODate(req.params.weekStart);
-    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
-
-    const { storeId } = req.body;
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const monday = getWeekStart(weekStart);
-    const list = await ensureShoppingList(monday, effectiveHouseholdId);
-    await repairShoppingListItems(list, effectiveHouseholdId, {
-      context: "assign-store"
-    });
-    const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
-
-    const today = new Date().toISOString().slice(0, 10);
-    let changed = false;
-    for (const item of list.items) {
-      if (item.status !== "purchased" || item.storeId || !item.purchasedAt) continue;
-      if (toDateGroup(item.purchasedAt) !== today) continue;
-      item.storeId = validatedStoreId;
-      changed = true;
-    }
-
-    if (changed) await list.save();
-
-    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
-    return res.json({ ok: true, updated: changed, ...payload });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo asignar el supermercado." });
-  }
-});
-
-router.post("/stores", requireAuth, async (req, res) => {
-  try {
-    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
-    const name = String(req.body?.name || "").trim();
-    if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
-    const canonicalName = normalizeStoreName(name);
-
-    const store = await Store.findOneAndUpdate(
-      { scope: "household", householdId: effectiveHouseholdId, canonicalName },
-      { $setOnInsert: { scope: "household", householdId: effectiveHouseholdId, name, canonicalName } },
-      { new: true, upsert: true }
-    );
-
-    return res.status(201).json({ ok: true, store });
-  } catch (error) {
-    const handled = handleHouseholdError(res, error);
-    if (handled) return handled;
-    return res.status(500).json({ ok: false, error: "No se pudo crear la tienda." });
-  }
-});
-
-router.get("/stores/master", requireAuth, requireDiod, async (req, res) => {
-  const stores = sortStores(
-    await Store.find({ scope: "master", householdId: null }).select("_id name canonicalName active order scope")
-  );
-  return res.json({ ok: true, stores });
-});
-
-router.post("/stores/master", requireAuth, requireDiod, async (req, res) => {
-  const name = String(req.body?.name || "").trim();
-  if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
-  const canonicalName = normalizeStoreName(name);
-  const requestedOrder = Number(req.body?.order);
-
-  const store = await Store.findOneAndUpdate(
-    { scope: "master", householdId: null, canonicalName },
-    {
-      $set: {
-        name,
-        canonicalName,
-        active: req.body?.active !== false,
-        order: Number.isFinite(requestedOrder) ? requestedOrder : null,
-        scope: "master",
-        householdId: null
-      }
-    },
-    { new: true, upsert: true }
-  );
-  return res.status(201).json({ ok: true, store });
-});
-
-router.put("/stores/master/:storeId", requireAuth, requireDiod, async (req, res) => {
-  const store = await Store.findOne({ _id: req.params.storeId, scope: "master", householdId: null });
-  if (!store) return res.status(404).json({ ok: false, error: "Supermercado no encontrado." });
-
-  if (req.body?.name !== undefined) {
-    const name = String(req.body.name || "").trim();
-    if (!name) return res.status(400).json({ ok: false, error: "Nombre inválido." });
-    store.name = name;
-    store.canonicalName = normalizeStoreName(name);
-  }
-  if (req.body?.active !== undefined) store.active = Boolean(req.body.active);
-  if (req.body?.order !== undefined) {
-    const requestedOrder = Number(req.body.order);
-    store.order = Number.isFinite(requestedOrder) ? requestedOrder : null;
-  }
-
-  await store.save();
-  return res.json({ ok: true, store });
-});
-
-router.delete("/stores/master/:storeId", requireAuth, requireDiod, async (req, res) => {
-  const store = await Store.findOne({ _id: req.params.storeId, scope: "master", householdId: null });
-  if (!store) return res.status(404).json({ ok: false, error: "Supermercado no encontrado." });
-  store.active = false;
-  await store.save();
-  return res.json({ ok: true, store });
-});
-
-export default router;
+import express from "express";
+import { Category } from "../models/Category.js";
+import { Store } from "../models/Store.js";
+import { KitchenIngredient } from "../models/KitchenIngredient.js";
+import { KitchenUser } from "../models/KitchenUser.js";
+import { requireAuth, requireDiod } from "../middleware.js";
+import { formatDateISO, getWeekStart, parseISODate } from "../utils/dates.js";
+import {
+  buildScopedFilter,
+  getEffectiveHouseholdId,
+  handleHouseholdError
+} from "../householdScope.js";
+import { ensureShoppingList, rebuildShoppingList, repairShoppingListItems } from "../shoppingService.js";
+import { CATALOG_SCOPES } from "../utils/catalogScopes.js";
+import { normalizeIngredientName } from "../utils/normalize.js";
+import {
+  DEFAULT_CATEGORY_COLOR_BG,
+  DEFAULT_CATEGORY_COLOR_TEXT,
+  DEFAULT_CATEGORY_NAME,
+  DEFAULT_CATEGORY_SLUG,
+  ensureDefaultCategory
+} from "../utils/categoryMatching.js";
+
+const router = express.Router();
+
+function logShoppingError(context, error, extra = {}) {
+  console.error(`[kitchen][shopping] ${context}`, {
+    ...extra,
+    message: error?.message,
+    stack: error?.stack
+  });
+}
+
+
+function normalizeStoreName(value = "") {
+  return String(value).trim().toLowerCase();
+}
+
+function sortStores(stores = []) {
+  return [...stores].sort((a, b) => {
+    const orderA = Number.isFinite(a.order) ? a.order : Number.POSITIVE_INFINITY;
+    const orderB = Number.isFinite(b.order) ? b.order : Number.POSITIVE_INFINITY;
+    if (orderA !== orderB) return orderA - orderB;
+    return String(a.name || "").localeCompare(String(b.name || ""), "es", { sensitivity: "base" });
+  });
+}
+
+function buildStoreVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
+  return {
+    ...extraFilter,
+    $or: [
+      { scope: "master", householdId: null },
+      { scope: "household", householdId: effectiveHouseholdId }
+    ]
+  };
+}
+
+function buildCategoryVisibilityFilter(effectiveHouseholdId, extraFilter = {}) {
+  return {
+    ...extraFilter,
+    $or: [
+      { scope: CATALOG_SCOPES.MASTER, householdId: null },
+      { scope: CATALOG_SCOPES.HOUSEHOLD, householdId: effectiveHouseholdId },
+      { scope: CATALOG_SCOPES.OVERRIDE, householdId: effectiveHouseholdId }
+    ]
+  };
+}
+
+function toDateGroup(value) {
+  if (!value) return "sin-fecha";
+  return new Date(value).toISOString().slice(0, 10);
+}
+
+function isValidObjectId(value) {
+  return Boolean(value) && /^[a-f\d]{24}$/i.test(String(value));
+}
+
+function compareCategoryGroups(a, b) {
+  const orderA = Number.isFinite(a?.categoryInfo?.order) ? a.categoryInfo.order : Number.POSITIVE_INFINITY;
+  const orderB = Number.isFinite(b?.categoryInfo?.order) ? b.categoryInfo.order : Number.POSITIVE_INFINITY;
+  if (orderA !== orderB) return orderA - orderB;
+  return String(a?.categoryInfo?.name || "").localeCompare(String(b?.categoryInfo?.name || ""), "es", { sensitivity: "base" });
+}
+
+function compareShoppingItems(a, b) {
+  const left = String(a?.canonicalName || a?.displayName || "");
+  const right = String(b?.canonicalName || b?.displayName || "");
+  return left.localeCompare(right, "es", { sensitivity: "base" });
+}
+
+function normalizeShoppingItemForResponse(item, purchaserById) {
+  const normalized = item.toObject ? item.toObject() : { ...item };
+  return {
+    ...normalized,
+    categoryId: normalized.categoryId || null,
+    storeId: normalized.storeId || null,
+    purchasedBy: normalized.purchasedBy || null,
+    purchasedAt: normalized.purchasedAt || null,
+    purchasedByName: normalized.purchasedBy && isValidObjectId(normalized.purchasedBy)
+      ? purchaserById.get(String(normalized.purchasedBy)) || "Usuario"
+      : null
+  };
+}
+
+async function getShoppingPayload(weekStartDate, effectiveHouseholdId) {
+  const list = await ensureShoppingList(weekStartDate, effectiveHouseholdId);
+
+  const fallbackCategory = await ensureDefaultCategory({
+    Category,
+    householdId: effectiveHouseholdId
+  });
+  await repairShoppingListItems(list, effectiveHouseholdId, {
+    fallbackCategory,
+    context: "getShoppingPayload"
+  });
+
+  const categories = await Category.find(buildCategoryVisibilityFilter(effectiveHouseholdId, { isArchived: { $ne: true } })).select(
+    "_id name slug colorBg colorText order"
+  );
+  const stores = sortStores(
+    await Store.find(buildStoreVisibilityFilter(effectiveHouseholdId, { active: true }))
+      .select("_id name order scope householdId")
+      .lean()
+  );
+
+  const storeById = new Map(stores.map((store) => [String(store._id), store.name]));
+  const categoryById = new Map(categories.map((category) => [String(category._id), category]));
+  const purchaserIds = Array.from(new Set(
+    list.items
+      .map((item) => item.purchasedBy)
+      .filter((value) => isValidObjectId(value))
+      .map((value) => String(value))
+  ));
+  const purchasers = purchaserIds.length
+    ? await KitchenUser.find(buildScopedFilter(effectiveHouseholdId, { _id: { $in: purchaserIds } })).select("_id displayName")
+    : [];
+  const purchaserById = new Map(purchasers.map((person) => [String(person._id), person.displayName]));
+
+  const pendingByCategory = list.items
+    .filter((item) => item.status === "pending")
+    .reduce((acc, item) => {
+      const key = item.categoryId ? String(item.categoryId) : "uncategorized";
+      const resolvedCategory = item.categoryId
+        ? categoryById.get(String(item.categoryId)) || null
+        : fallbackCategory || null;
+
+      if (!acc.has(key)) {
+        acc.set(key, {
+          categoryId: resolvedCategory?._id || item.categoryId || null,
+          categoryInfo: {
+            name: resolvedCategory?.name || DEFAULT_CATEGORY_NAME,
+            slug: resolvedCategory?.slug || DEFAULT_CATEGORY_SLUG,
+            colorBg: resolvedCategory?.colorBg || DEFAULT_CATEGORY_COLOR_BG,
+            colorText: resolvedCategory?.colorText || DEFAULT_CATEGORY_COLOR_TEXT,
+            order: Number.isFinite(resolvedCategory?.order) ? resolvedCategory.order : null
+          },
+          items: []
+        });
+      }
+      acc.get(key).items.push(normalizeShoppingItemForResponse(item, purchaserById));
+      return acc;
+    }, new Map());
+
+  const purchasedByStoreDay = list.items
+    .filter((item) => item.status === "purchased")
+    .reduce((acc, item) => {
+      const dateKey = toDateGroup(item.purchasedAt);
+      const storeKey = item.storeId ? String(item.storeId) : "no-store";
+      const key = `${dateKey}::${storeKey}`;
+      if (!acc.has(key)) {
+        const purchasedByName = item.purchasedBy && isValidObjectId(item.purchasedBy)
+          ? purchaserById.get(String(item.purchasedBy)) || "Usuario"
+          : "Usuario";
+        acc.set(key, {
+          storeId: item.storeId || null,
+          storeName: item.storeId ? storeById.get(String(item.storeId)) || "Supermercado no definido" : "Supermercado no definido",
+          purchasedDate: dateKey,
+          startedAt: item.purchasedAt,
+          purchasedByName,
+          items: []
+        });
+      }
+      acc.get(key).items.push(normalizeShoppingItemForResponse(item, purchaserById));
+      return acc;
+    }, new Map());
+
+  return {
+    list,
+    stores,
+    pendingByCategory: Array.from(pendingByCategory.values())
+      .map((group) => ({
+        ...group,
+        items: [...group.items].sort(compareShoppingItems)
+      }))
+      .sort(compareCategoryGroups),
+    purchasedByStoreDay: Array.from(purchasedByStoreDay.values()).sort(
+      (a, b) => new Date(b.startedAt || 0).getTime() - new Date(a.startedAt || 0).getTime()
+    ).map((group) => ({
+      ...group,
+      items: [...group.items].sort(compareShoppingItems)
+    }))
+  };
+}
+
+async function validateStoreSelection(storeId, effectiveHouseholdId) {
+  if (!storeId) return null;
+  const store = await Store.findOne(buildStoreVisibilityFilter(effectiveHouseholdId, { _id: storeId, active: true }))
+    .select("_id")
+    .lean();
+  return store ? store._id : null;
+}
+
+router.get("/:weekStart", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+
+    res.json({ ok: true, weekStart: formatDateISO(monday), ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    logShoppingError("get-list", error, { weekStart: req.params.weekStart, userId: String(req.kitchenUser?._id || "") });
+    return res.status(500).json({ ok: false, error: "No se pudo cargar la lista de compra." });
+  }
+});
+
+router.post("/:weekStart/rebuild", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    await rebuildShoppingList(monday, effectiveHouseholdId);
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+
+    res.json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    logShoppingError("rebuild", error, { weekStart: req.params.weekStart, userId: String(req.kitchenUser?._id || "") });
+    if (error?.name === "ValidationError" || error?.name === "CastError") {
+      return res.status(400).json({ ok: false, error: "Datos inválidos al reconstruir la lista." });
+    }
+    return res.status(500).json({ ok: false, error: "No se pudo reconstruir la lista de compra." });
+  }
+});
+
+
+router.post("/:weekStart/items/manual", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const { ingredientId, categoryId, storeId, occurrences } = req.body || {};
+    if (!ingredientId || !categoryId) {
+      return res.status(400).json({ ok: false, error: "Debes indicar ingrediente y categoría." });
+    }
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+
+    const ingredient = await KitchenIngredient.findOne({
+      _id: ingredientId,
+      isArchived: { $ne: true },
+      active: true,
+      $or: [
+        { scope: CATALOG_SCOPES.MASTER, householdId: null },
+        { scope: CATALOG_SCOPES.HOUSEHOLD, householdId: effectiveHouseholdId },
+        { scope: CATALOG_SCOPES.OVERRIDE, householdId: effectiveHouseholdId }
+      ]
+    }).select("_id name canonicalName categoryId");
+
+    if (!ingredient) {
+      return res.status(404).json({ ok: false, error: "Ingrediente no encontrado." });
+    }
+
+    const category = await Category.findOne(buildCategoryVisibilityFilter(effectiveHouseholdId, {
+      _id: categoryId,
+      active: true,
+      isArchived: { $ne: true }
+    })).select("_id");
+
+    if (!category) {
+      return res.status(404).json({ ok: false, error: "Categoría no encontrada." });
+    }
+
+    list.items.push({
+      ingredientId: ingredient._id,
+      categoryId: category._id,
+      displayName: ingredient.name,
+      canonicalName: normalizeIngredientName(ingredient.canonicalName || ingredient.name),
+      occurrences: Number.isFinite(Number(occurrences)) && Number(occurrences) > 0 ? Number(occurrences) : 1,
+      status: "pending",
+      storeId: await validateStoreSelection(storeId, effectiveHouseholdId),
+      fromDishes: []
+    });
+
+    await list.save();
+
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    return res.status(201).json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo añadir el item manual." });
+  }
+});
+
+router.put("/:weekStart/item", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const { canonicalName, status, ingredientId, storeId } = req.body;
+    if (!canonicalName && !ingredientId) {
+      return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
+    }
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+    await repairShoppingListItems(list, effectiveHouseholdId, {
+      context: "update-item"
+    });
+
+    const item = list.items.find((current) => {
+      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
+      return current.canonicalName === canonicalName;
+    });
+
+    if (!item) return res.status(404).json({ ok: false, error: "Ingrediente no encontrado en la lista." });
+
+    const normalizedStatus = status === "purchased" ? "purchased" : "pending";
+    item.status = normalizedStatus;
+    if (normalizedStatus === "purchased") {
+      const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
+      item.purchasedBy = req.kitchenUser._id;
+      item.purchasedAt = new Date();
+      item.storeId = validatedStoreId;
+    } else {
+      item.purchasedBy = null;
+      item.purchasedAt = null;
+      item.storeId = null;
+    }
+
+    await list.save();
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    res.json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar la lista de compra." });
+  }
+});
+
+router.put("/:weekStart/item/store", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const { canonicalName, ingredientId, storeId } = req.body;
+    if (!canonicalName && !ingredientId) {
+      return res.status(400).json({ ok: false, error: "Ingrediente inválido." });
+    }
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+    await repairShoppingListItems(list, effectiveHouseholdId, {
+      context: "update-item-store"
+    });
+
+    const item = list.items.find((current) => {
+      if (ingredientId && current.ingredientId) return String(current.ingredientId) === String(ingredientId);
+      return current.canonicalName === canonicalName;
+    });
+
+    if (!item || item.status !== "purchased") {
+      return res.status(404).json({ ok: false, error: "Ingrediente comprado no encontrado." });
+    }
+
+    item.storeId = await validateStoreSelection(storeId, effectiveHouseholdId);
+    await list.save();
+
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    return res.json({ ok: true, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar el supermercado." });
+  }
+});
+
+router.put("/:weekStart/items/status", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const normalizedStatus = req.body?.status === "purchased" ? "purchased" : req.body?.status === "pending" ? "pending" : null;
+    if (!normalizedStatus) {
+      return res.status(400).json({ ok: false, error: "Estado inválido." });
+    }
+
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+    await repairShoppingListItems(list, effectiveHouseholdId, {
+      context: "bulk-update-status"
+    });
+
+    let changed = false;
+    if (normalizedStatus === "purchased") {
+      const validatedStoreId = await validateStoreSelection(req.body?.storeId, effectiveHouseholdId);
+      const now = new Date();
+      for (const item of list.items) {
+        if (item.status !== "pending") continue;
+        item.status = "purchased";
+        item.purchasedBy = req.kitchenUser._id;
+        item.purchasedAt = now;
+        item.storeId = validatedStoreId;
+        changed = true;
+      }
+    } else {
+      for (const item of list.items) {
+        if (item.status !== "purchased") continue;
+        item.status = "pending";
+        item.purchasedBy = null;
+        item.purchasedAt = null;
+        item.storeId = null;
+        changed = true;
+      }
+    }
+
+    if (changed) {
+      await list.save();
+    }
+
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    return res.json({ ok: true, updated: changed, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo actualizar el estado en bloque." });
+  }
+});
+
+router.post("/:weekStart/purchased/assign-store", requireAuth, async (req, res) => {
+  try {
+    const weekStart = parseISODate(req.params.weekStart);
+    if (!weekStart) return res.status(400).json({ ok: false, error: "Fecha inválida." });
+
+    const { storeId } = req.body;
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const monday = getWeekStart(weekStart);
+    const list = await ensureShoppingList(monday, effectiveHouseholdId);
+    await repairShoppingListItems(list, effectiveHouseholdId, {
+      context: "assign-store"
+    });
+    const validatedStoreId = await validateStoreSelection(storeId, effectiveHouseholdId);
+
+    const today = new Date().toISOString().slice(0, 10);
+    let changed = false;
+    for (const item of list.items) {
+      if (item.status !== "purchased" || item.storeId || !item.purchasedAt) continue;
+      if (toDateGroup(item.purchasedAt) !== today) continue;
+      item.storeId = validatedStoreId;
+      changed = true;
+    }
+
+    if (changed) await list.save();
+
+    const payload = await getShoppingPayload(monday, effectiveHouseholdId);
+    return res.json({ ok: true, updated: changed, ...payload });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo asignar el supermercado." });
+  }
+});
+
+router.post("/stores", requireAuth, async (req, res) => {
+  try {
+    const effectiveHouseholdId = getEffectiveHouseholdId(req.user);
+    const name = String(req.body?.name || "").trim();
+    if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
+    const canonicalName = normalizeStoreName(name);
+
+    const store = await Store.findOneAndUpdate(
+      { scope: "household", householdId: effectiveHouseholdId, canonicalName },
+      { $setOnInsert: { scope: "household", householdId: effectiveHouseholdId, name, canonicalName } },
+      { new: true, upsert: true }
+    );
+
+    return res.status(201).json({ ok: true, store });
+  } catch (error) {
+    const handled = handleHouseholdError(res, error);
+    if (handled) return handled;
+    return res.status(500).json({ ok: false, error: "No se pudo crear la tienda." });
+  }
+});
+
+router.get("/stores/master", requireAuth, requireDiod, async (req, res) => {
+  const stores = sortStores(
+    await Store.find({ scope: "master", householdId: null }).select("_id name canonicalName active order scope")
+  );
+  return res.json({ ok: true, stores });
+});
+
+router.post("/stores/master", requireAuth, requireDiod, async (req, res) => {
+  const name = String(req.body?.name || "").trim();
+  if (!name) return res.status(400).json({ ok: false, error: "Debes indicar un nombre." });
+  const canonicalName = normalizeStoreName(name);
+  const requestedOrder = Number(req.body?.order);
+
+  const store = await Store.findOneAndUpdate(
+    { scope: "master", householdId: null, canonicalName },
+    {
+      $set: {
+        name,
+        canonicalName,
+        active: req.body?.active !== false,
+        order: Number.isFinite(requestedOrder) ? requestedOrder : null,
+        scope: "master",
+        householdId: null
+      }
+    },
+    { new: true, upsert: true }
+  );
+  return res.status(201).json({ ok: true, store });
+});
+
+router.put("/stores/master/:storeId", requireAuth, requireDiod, async (req, res) => {
+  const store = await Store.findOne({ _id: req.params.storeId, scope: "master", householdId: null });
+  if (!store) return res.status(404).json({ ok: false, error: "Supermercado no encontrado." });
+
+  if (req.body?.name !== undefined) {
+    const name = String(req.body.name || "").trim();
+    if (!name) return res.status(400).json({ ok: false, error: "Nombre inválido." });
+    store.name = name;
+    store.canonicalName = normalizeStoreName(name);
+  }
+  if (req.body?.active !== undefined) store.active = Boolean(req.body.active);
+  if (req.body?.order !== undefined) {
+    const requestedOrder = Number(req.body.order);
+    store.order = Number.isFinite(requestedOrder) ? requestedOrder : null;
+  }
+
+  await store.save();
+  return res.json({ ok: true, store });
+});
+
+router.delete("/stores/master/:storeId", requireAuth, requireDiod, async (req, res) => {
+  const store = await Store.findOne({ _id: req.params.storeId, scope: "master", householdId: null });
+  if (!store) return res.status(404).json({ ok: false, error: "Supermercado no encontrado." });
+  store.active = false;
+  await store.save();
+  return res.json({ ok: true, store });
+});
+
+export default router;
diff --git a/frontend/src/kitchen/components/DishModal.jsx b/frontend/src/kitchen/components/DishModal.jsx
index 991aea5e51b2d280267fa5eaf87e3a7bc54914f6..39164662eb05a3ec1e9d79406a695beef18c3cb5 100644
--- a/frontend/src/kitchen/components/DishModal.jsx
+++ b/frontend/src/kitchen/components/DishModal.jsx
@@ -1,42 +1,42 @@
 import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
 import { apiRequest } from "../api.js";
 import IngredientPicker from "./IngredientPicker.jsx";
 import { normalizeIngredientName } from "../utils/normalize.js";
 
-const EMPTY_FORM = { name: "", ingredients: [], sidedish: false };
+const EMPTY_FORM = { name: "", ingredients: [], sidedish: false };
 
 export default function DishModal({
   isOpen,
   onClose,
   onSaved,
   categories = [],
   onCategoryCreated,
   initialDish = null,
-  initialName = "",
-  initialSidedish = false,
-  scope = undefined
+  initialName = "",
+  initialSidedish = false,
+  scope = undefined
 }) {
   const [form, setForm] = useState(EMPTY_FORM);
   const [editingId, setEditingId] = useState(null);
   const [saving, setSaving] = useState(false);
   const [error, setError] = useState("");
   const [isCreatingIngredient, setIsCreatingIngredient] = useState(false);
   const ingredientCache = useRef(new Map());
 
   const fetchIngredientMatch = useCallback(async (canonicalName) => {
     if (!canonicalName) return null;
     if (ingredientCache.current.has(canonicalName)) {
       return ingredientCache.current.get(canonicalName);
     }
     try {
       const data = await apiRequest(`/api/kitchenIngredients?q=${encodeURIComponent(canonicalName)}`);
       const match = (data.ingredients || []).find((item) => item.canonicalName === canonicalName);
       ingredientCache.current.set(canonicalName, match || null);
       return match || null;
     } catch (err) {
       return null;
     }
   }, []);
 
   const resolveIngredients = useCallback(
     async (ingredients = []) => {
@@ -51,90 +51,90 @@ export default function DishModal({
           return {
             ingredientId,
             displayName,
             canonicalName,
             category: match?.categoryId || null,
             status: ingredientId ? "resolved" : "pending"
           };
         })
       );
       return resolved.filter((item) => item.displayName);
     },
     [fetchIngredientMatch]
   );
 
   useEffect(() => {
     if (!isOpen) return;
     let active = true;
     setError("");
     const setup = async () => {
       if (initialDish?._id) {
         const ingredients = await resolveIngredients(initialDish.ingredients || []);
         if (!active) return;
         setForm({
           name: initialDish.name || "",
           ingredients,
-          sidedish: Boolean(initialDish.sidedish)
+          sidedish: Boolean(initialDish.sidedish)
         });
         setEditingId(initialDish._id);
       } else {
         setForm({
           name: initialName || "",
           ingredients: [],
-          sidedish: Boolean(initialSidedish)
+          sidedish: Boolean(initialSidedish)
         });
         setEditingId(null);
       }
     };
     setup();
     return () => {
       active = false;
     };
-  }, [initialDish, initialName, initialSidedish, isOpen, resolveIngredients]);
+  }, [initialDish, initialName, initialSidedish, isOpen, resolveIngredients]);
 
   const pendingCount = useMemo(
     () => (form.ingredients || []).filter((item) => item.status === "pending").length,
     [form.ingredients]
   );
 
   const resetAndClose = () => {
     setForm(EMPTY_FORM);
     setEditingId(null);
     setError("");
     setIsCreatingIngredient(false);
     onClose?.();
   };
 
   const onSave = async (event) => {
     event.preventDefault();
     setError("");
     setSaving(true);
     try {
       const payload = {
         name: form.name,
-        sidedish: form.sidedish,
-        ...(scope ? { scope } : {}),
+        sidedish: form.sidedish,
+        ...(scope ? { scope } : {}),
         ingredients: (form.ingredients || []).map((item) => ({
           ingredientId: item.ingredientId,
           displayName: item.displayName,
           canonicalName: item.canonicalName || normalizeIngredientName(item.displayName)
         }))
       };
       let dish = null;
       if (editingId) {
         const data = await apiRequest(`/api/kitchen/dishes/${editingId}`, {
           method: "PUT",
           body: JSON.stringify(payload)
         });
         dish = data.dish;
       } else {
         const data = await apiRequest("/api/kitchen/dishes", {
           method: "POST",
           body: JSON.stringify(payload)
         });
         dish = data.dish;
       }
       if (dish) {
         await onSaved?.(dish);
       }
       resetAndClose();
     } catch (err) {
@@ -161,75 +161,76 @@ export default function DishModal({
             <p className="kitchen-muted">Selecciona ingredientes con búsqueda y añade nuevos al vuelo.</p>
           </div>
           <button className="kitchen-icon-button" type="button" onClick={resetAndClose} aria-label="Cerrar">
             <svg viewBox="0 0 24 24" aria-hidden="true">
               <path
                 d="M6 6l12 12M18 6l-12 12"
                 fill="none"
                 stroke="currentColor"
                 strokeWidth="1.5"
                 strokeLinecap="round"
               />
             </svg>
           </button>
         </div>
         <form onSubmit={onSave} className="kitchen-form">
           <label className="kitchen-field">
             <span className="kitchen-label">Nombre del plato</span>
             <input
               className="kitchen-input"
               value={form.name}
               onChange={(event) => setForm((prev) => ({ ...prev, name: event.target.value }))}
               required
               placeholder="Ej. Pollo al horno"
             />
           </label>
-          <div className="kitchen-field kitchen-toggle-field">
-            <div className="kitchen-toggle-row">
-              <span className="kitchen-label">Guarnición</span>
-              <label className="kitchen-toggle" htmlFor="dish-sideswitch">
-                <input
-                  id="dish-sideswitch"
-                  type="checkbox"
-                  className="kitchen-toggle-input"
-                  checked={form.sidedish}
-                  onChange={(event) =>
-                    setForm((prev) => ({ ...prev, sidedish: event.target.checked }))
-                  }
-                />
-                <span className="kitchen-toggle-track" aria-hidden="true" />
-              </label>
-            </div>
-          </div>
+          <div className="kitchen-field kitchen-toggle-field">
+            <div className="kitchen-toggle-row">
+              <span className="kitchen-label">Guarnición</span>
+              <label className="kitchen-toggle" htmlFor="dish-sideswitch">
+                <input
+                  id="dish-sideswitch"
+                  type="checkbox"
+                  className="kitchen-toggle-input"
+                  checked={form.sidedish}
+                  onChange={(event) =>
+                    setForm((prev) => ({ ...prev, sidedish: event.target.checked }))
+                  }
+                />
+                <span className="kitchen-toggle-track" aria-hidden="true" />
+              </label>
+            </div>
+          </div>
           <div className="kitchen-field kitchen-dish-ingredients">
             <span className="kitchen-label">Ingredientes</span>
             <IngredientPicker
               value={form.ingredients}
               onChange={(ingredients) => setForm((prev) => ({ ...prev, ingredients }))}
               categories={categories}
               onCategoryCreated={onCategoryCreated}
               onCreateStateChange={setIsCreatingIngredient}
+              mode="recipe"
             />
             {pendingCount ? (
               <p className="kitchen-inline-warning">
                 Hay {pendingCount} ingrediente{pendingCount > 1 ? "s" : ""} pendiente
                 {pendingCount > 1 ? "s" : ""} de vincular con el catálogo global.
               </p>
             ) : null}
           </div>
           {error ? <div className="kitchen-alert error">{error}</div> : null}
           <div className="kitchen-modal-actions">
             {isCreatingIngredient ? (
               <div className="kitchen-inline-warning">
                 Termina de crear el ingrediente para guardar el plato.
               </div>
             ) : (
               <button className="kitchen-button" type="submit" disabled={saving}>
                 {saving ? "Guardando..." : "Guardar"}
               </button>
             )}
             <button className="kitchen-button ghost" type="button" onClick={resetAndClose}>
               Cancelar
             </button>
           </div>
         </form>
       </div>
diff --git a/frontend/src/kitchen/components/IngredientPicker.jsx b/frontend/src/kitchen/components/IngredientPicker.jsx
index 4ba3e9d3a87e4949474507e58515642c11fcf1ff..169faa1b9ca3118277bc372ad4e3daecd5c6e20a 100644
--- a/frontend/src/kitchen/components/IngredientPicker.jsx
+++ b/frontend/src/kitchen/components/IngredientPicker.jsx
@@ -1,493 +1,494 @@
-import React, { useEffect, useMemo, useRef, useState } from "react";
+import React, { useEffect, useMemo, useRef, useState } from "react";
 import { apiRequest } from "../api.js";
 import CategoryChip from "./CategoryChip.jsx";
-import { emptyCategory, PASTEL_PALETTE, resolveCategoryColors } from "./categoryUtils.js";
+import { emptyCategory, PASTEL_PALETTE, resolveCategoryColors } from "./categoryUtils.js";
 import { normalizeIngredientName } from "../utils/normalize.js";
-
-export default function IngredientPicker({
-  value = [],
-  onChange,
-  categories = [],
-  onCategoryCreated,
-  onCreateStateChange
-}) {
+
+export default function IngredientPicker({
+  value = [],
+  onChange,
+  categories = [],
+  onCategoryCreated,
+  onCreateStateChange,
+  mode = "all"
+}) {
   const [query, setQuery] = useState("");
   const [suggestions, setSuggestions] = useState([]);
   const [searching, setSearching] = useState(false);
   const [searchError, setSearchError] = useState("");
   const [showCreate, setShowCreate] = useState(false);
   const [createName, setCreateName] = useState("");
   const [createError, setCreateError] = useState("");
   const [saving, setSaving] = useState(false);
   const [categoryQuery, setCategoryQuery] = useState("");
   const [selectedCategory, setSelectedCategory] = useState(null);
   const [lastUsedCategory, setLastUsedCategory] = useState(null);
   const [creatingCategory, setCreatingCategory] = useState(false);
-  const [showCategoryModal, setShowCategoryModal] = useState(false);
-  const [categoryDraftName, setCategoryDraftName] = useState("");
-  const [categoryColor, setCategoryColor] = useState(null);
+  const [showCategoryModal, setShowCategoryModal] = useState(false);
+  const [categoryDraftName, setCategoryDraftName] = useState("");
+  const [categoryColor, setCategoryColor] = useState(null);
   const [replaceItem, setReplaceItem] = useState(null);
-  const searchInputRef = useRef(null);
-  const createInputRef = useRef(null);
-  const categoryNameInputRef = useRef(null);
+  const searchInputRef = useRef(null);
+  const createInputRef = useRef(null);
+  const categoryNameInputRef = useRef(null);
+
+  useEffect(() => {
+    if (onCreateStateChange) {
+      onCreateStateChange(showCreate || showCategoryModal);
+    }
+  }, [onCreateStateChange, showCreate, showCategoryModal]);
+
+  useEffect(() => {
+    if (showCreate) {
+      requestAnimationFrame(() => {
+        createInputRef.current?.focus();
+      });
+    }
+  }, [showCreate]);
+
+  useEffect(() => {
+    if (showCategoryModal) {
+      requestAnimationFrame(() => {
+        categoryNameInputRef.current?.focus();
+      });
+    }
+  }, [showCategoryModal]);
 
-  useEffect(() => {
-    if (onCreateStateChange) {
-      onCreateStateChange(showCreate || showCategoryModal);
-    }
-  }, [onCreateStateChange, showCreate, showCategoryModal]);
-
-  useEffect(() => {
-    if (showCreate) {
-      requestAnimationFrame(() => {
-        createInputRef.current?.focus();
-      });
-    }
-  }, [showCreate]);
-
-  useEffect(() => {
-    if (showCategoryModal) {
-      requestAnimationFrame(() => {
-        categoryNameInputRef.current?.focus();
-      });
-    }
-  }, [showCategoryModal]);
-
   useEffect(() => {
     if (!query) {
       setSuggestions([]);
       setSearchError("");
       setSearching(false);
       return;
     }
 
     let active = true;
     setSearching(true);
     setSearchError("");
 
     const timeout = setTimeout(async () => {
       try {
-        if (import.meta.env.DEV) {
-          console.debug("[IngredientPicker] buscando", { query });
-        }
-        const data = await apiRequest(`/api/kitchenIngredients?q=${encodeURIComponent(query)}`);
+        if (import.meta.env.DEV) {
+          console.debug("[IngredientPicker] buscando", { query });
+        }
+        const data = await apiRequest(`/api/kitchenIngredients?q=${encodeURIComponent(query)}${mode === "recipe" ? "&mode=recipe" : ""}`);
         if (!active) return;
         setSuggestions(data.ingredients || []);
       } catch (err) {
         if (!active) return;
         setSearchError(err.message || "No se pudieron buscar ingredientes.");
       } finally {
         if (active) setSearching(false);
       }
     }, 250);
 
     return () => {
       active = false;
       clearTimeout(timeout);
     };
-  }, [query]);
+  }, [mode, query]);
+
+  const normalizedQuery = useMemo(() => normalizeIngredientName(query), [query]);
 
-  const normalizedQuery = useMemo(() => normalizeIngredientName(query), [query]);
-
   const filteredCategories = useMemo(() => {
     if (!categoryQuery) return categories;
     const lower = categoryQuery.toLowerCase();
     return categories.filter((category) => category.name.toLowerCase().includes(lower));
   }, [categories, categoryQuery]);
 
-  const normalizedCategoryQuery = useMemo(
-    () => normalizeIngredientName(categoryQuery),
-    [categoryQuery]
-  );
-
-  const hasExactCategory = useMemo(
-    () =>
-      Boolean(
-        normalizedCategoryQuery &&
-          categories.some(
-            (category) => normalizeIngredientName(category.name) === normalizedCategoryQuery
-          )
-      ),
-    [categories, normalizedCategoryQuery]
-  );
-
-  const visibleSuggestions = useMemo(() => {
-    if (!normalizedQuery) return suggestions;
-    return suggestions.filter((item) =>
-      normalizeIngredientName(item.name || "").includes(normalizedQuery)
-    );
-  }, [normalizedQuery, suggestions]);
-
+  const normalizedCategoryQuery = useMemo(
+    () => normalizeIngredientName(categoryQuery),
+    [categoryQuery]
+  );
+
+  const hasExactCategory = useMemo(
+    () =>
+      Boolean(
+        normalizedCategoryQuery &&
+          categories.some(
+            (category) => normalizeIngredientName(category.name) === normalizedCategoryQuery
+          )
+      ),
+    [categories, normalizedCategoryQuery]
+  );
+
+  const visibleSuggestions = useMemo(() => {
+    if (!normalizedQuery) return suggestions;
+    return suggestions.filter((item) =>
+      normalizeIngredientName(item.name || "").includes(normalizedQuery)
+    );
+  }, [normalizedQuery, suggestions]);
+
   const addIngredient = (ingredient, displayNameOverride, targetToReplace = null) => {
     const canonicalName = ingredient.canonicalName || normalizeIngredientName(displayNameOverride || ingredient.name);
     const ingredientId = ingredient._id || ingredient.ingredientId;
     const nextBase = targetToReplace ? value.filter((item) => item !== targetToReplace) : value;
     if (
       nextBase.some((item) => item.ingredientId === ingredientId || item.canonicalName === canonicalName)
     ) {
       return;
     }
     const next = [
       ...nextBase,
       {
         ingredientId,
         displayName: displayNameOverride || ingredient.name,
         canonicalName,
         category: ingredient.categoryId || ingredient.category || emptyCategory,
         status: "resolved"
       }
     ];
     onChange(next);
     setReplaceItem(null);
   };
 
   const handleSelectSuggestion = (ingredient) => {
     addIngredient(ingredient, ingredient.name);
     setQuery("");
     setSuggestions([]);
     setShowCreate(false);
     setCreateName("");
   };
 
   const openCreateFlow = (name, itemToReplace = null) => {
     setCreateName(name);
     setCreateError("");
     setShowCreate(true);
     setSelectedCategory(lastUsedCategory);
     setCategoryQuery("");
-    setShowCategoryModal(false);
-    setCategoryDraftName("");
-    setCategoryColor(null);
+    setShowCategoryModal(false);
+    setCategoryDraftName("");
+    setCategoryColor(null);
     setReplaceItem(itemToReplace);
   };
 
-  const closeCreateFlow = () => {
-    setShowCreate(false);
-    setCreateName("");
-    setCreateError("");
-    setCategoryQuery("");
-    setSelectedCategory(null);
-    setShowCategoryModal(false);
-    setCategoryDraftName("");
-    setCategoryColor(null);
-    setReplaceItem(null);
-    requestAnimationFrame(() => {
-      searchInputRef.current?.focus();
-    });
-  };
-
+  const closeCreateFlow = () => {
+    setShowCreate(false);
+    setCreateName("");
+    setCreateError("");
+    setCategoryQuery("");
+    setSelectedCategory(null);
+    setShowCategoryModal(false);
+    setCategoryDraftName("");
+    setCategoryColor(null);
+    setReplaceItem(null);
+    requestAnimationFrame(() => {
+      searchInputRef.current?.focus();
+    });
+  };
+
   const handleCreateIngredient = async () => {
     if (!createName.trim()) return;
     if (!selectedCategory?._id) {
       setCreateError("Selecciona una categoría para continuar.");
       return;
     }
     setSaving(true);
     setCreateError("");
     try {
-      if (import.meta.env.DEV) {
-        console.debug("[IngredientPicker] creando ingrediente", {
-          name: createName.trim(),
-          categoryId: selectedCategory?._id
-        });
-      }
+      if (import.meta.env.DEV) {
+        console.debug("[IngredientPicker] creando ingrediente", {
+          name: createName.trim(),
+          categoryId: selectedCategory?._id
+        });
+      }
       const data = await apiRequest("/api/kitchenIngredients", {
         method: "POST",
         body: JSON.stringify({ name: createName, categoryId: selectedCategory._id })
       });
       const ingredient = data.ingredient;
       addIngredient(ingredient, createName.trim(), replaceItem);
       setLastUsedCategory(selectedCategory);
       setQuery("");
-      closeCreateFlow();
+      closeCreateFlow();
     } catch (err) {
       setCreateError(err.message || "No se pudo crear el ingrediente.");
     } finally {
       setSaving(false);
     }
   };
 
   const handleCreateCategory = async () => {
     if (!onCategoryCreated) return;
-    if (!categoryDraftName.trim()) return;
+    if (!categoryDraftName.trim()) return;
     setCreatingCategory(true);
     try {
-      const category = await onCategoryCreated(categoryDraftName.trim(), categoryColor);
+      const category = await onCategoryCreated(categoryDraftName.trim(), categoryColor);
       setSelectedCategory(category);
       setCategoryQuery("");
-      setShowCategoryModal(false);
-      setCategoryDraftName("");
-      setCategoryColor(null);
+      setShowCategoryModal(false);
+      setCategoryDraftName("");
+      setCategoryColor(null);
     } catch (err) {
       setCreateError(err.message || "No se pudo crear la categoría.");
     } finally {
       setCreatingCategory(false);
     }
   };
 
   return (
     <div className="kitchen-ingredient-picker">
-      <div className="kitchen-field kitchen-ingredient-search">
-        <input
-          className="kitchen-input"
-          placeholder="Busca y añade ingredientes…"
-          value={query}
-          ref={searchInputRef}
-          onChange={(event) => {
-            setQuery(event.target.value);
-            setShowCreate(false);
-          }}
-        />
-        {searchError ? <span className="kitchen-inline-error">{searchError}</span> : null}
-        {query && !showCreate ? (
-          <div className="kitchen-suggestion-list">
-            {searching ? <div className="kitchen-muted">Buscando...</div> : null}
-            {!searching && visibleSuggestions.length === 0 ? (
-              <button className="kitchen-button ghost" type="button" onClick={() => openCreateFlow(query)}>
-                Crear “{query}”
-              </button>
-            ) : (
-              visibleSuggestions.map((item) => (
-                <button
-                  className="kitchen-suggestion"
-                  key={item._id}
-                  type="button"
-                  onClick={() => handleSelectSuggestion(item)}
-                >
-                  <span className="kitchen-suggestion-name">{item.name}</span>
-                </button>
-              ))
-            )}
-          </div>
-        ) : null}
-      </div>
-
+      <div className="kitchen-field kitchen-ingredient-search">
+        <input
+          className="kitchen-input"
+          placeholder="Busca y añade ingredientes…"
+          value={query}
+          ref={searchInputRef}
+          onChange={(event) => {
+            setQuery(event.target.value);
+            setShowCreate(false);
+          }}
+        />
+        {searchError ? <span className="kitchen-inline-error">{searchError}</span> : null}
+        {query && !showCreate ? (
+          <div className="kitchen-suggestion-list">
+            {searching ? <div className="kitchen-muted">Buscando...</div> : null}
+            {!searching && visibleSuggestions.length === 0 ? (
+              <button className="kitchen-button ghost" type="button" onClick={() => openCreateFlow(query)}>
+                Crear “{query}”
+              </button>
+            ) : (
+              visibleSuggestions.map((item) => (
+                <button
+                  className="kitchen-suggestion"
+                  key={item._id}
+                  type="button"
+                  onClick={() => handleSelectSuggestion(item)}
+                >
+                  <span className="kitchen-suggestion-name">{item.name}</span>
+                </button>
+              ))
+            )}
+          </div>
+        ) : null}
+      </div>
+
       <div className="kitchen-chip-list">
         {value.length === 0 ? (
           <span className="kitchen-muted">Sin ingredientes todavía.</span>
         ) : (
-          value.map((item) => {
-            const colors = resolveCategoryColors(item.category);
-            return (
-              <div className="kitchen-chip-item" key={`${item.ingredientId || item.canonicalName}`}>
-                <CategoryChip
-                  label={item.displayName}
-                  colorBg={colors.colorBg}
-                  colorText={colors.colorText}
-                  status={item.status === "pending" ? "pending" : ""}
-                  onRemove={() => onChange(value.filter((entry) => entry !== item))}
-                />
+          value.map((item) => {
+            const colors = resolveCategoryColors(item.category);
+            return (
+              <div className="kitchen-chip-item" key={`${item.ingredientId || item.canonicalName}`}>
+                <CategoryChip
+                  label={item.displayName}
+                  colorBg={colors.colorBg}
+                  colorText={colors.colorText}
+                  status={item.status === "pending" ? "pending" : ""}
+                  onRemove={() => onChange(value.filter((entry) => entry !== item))}
+                />
               {item.status === "pending" ? (
                 <button
                   className="kitchen-chip-action"
                   type="button"
                   onClick={() => openCreateFlow(item.displayName, item)}
                 >
                   Completar
                 </button>
               ) : null}
-              </div>
-            );
-          })
+              </div>
+            );
+          })
         )}
       </div>
 
       {showCreate ? (
-        <div className="kitchen-context-modal-backdrop" role="presentation" onClick={closeCreateFlow}>
-          <div
-            className="kitchen-context-modal"
-            role="dialog"
-            aria-modal="true"
-            aria-label="Crear ingrediente"
-            onClick={(event) => event.stopPropagation()}
-          >
-            <div className="kitchen-context-modal-header">
-              <div>
-                <h4>Crear ingrediente</h4>
-                <p className="kitchen-muted">Añade un ingrediente rápido y sigue sumando al plato.</p>
-              </div>
-              <button className="kitchen-icon-button" type="button" onClick={closeCreateFlow} aria-label="Cerrar">
-                <svg viewBox="0 0 24 24" aria-hidden="true">
-                  <path
-                    d="M6 6l12 12M18 6l-12 12"
-                    fill="none"
-                    stroke="currentColor"
-                    strokeWidth="1.5"
-                    strokeLinecap="round"
-                  />
-                </svg>
-              </button>
-            </div>
-            <div className="kitchen-context-modal-body">
-              <label className="kitchen-field">
-                <span className="kitchen-label">Nombre del ingrediente</span>
-                <input
-                  className="kitchen-input"
-                  value={createName}
-                  ref={createInputRef}
-                  onChange={(event) => setCreateName(event.target.value)}
-                />
-              </label>
-              <div className="kitchen-field">
-                <span className="kitchen-label">Categoría</span>
-                <input
-                  className="kitchen-input"
-                  placeholder="Busca una categoría…"
-                  value={categoryQuery}
-                  onChange={(event) => setCategoryQuery(event.target.value)}
-                />
-                <div className="kitchen-category-list">
-                  {filteredCategories.map((category) => {
-                    const colors = resolveCategoryColors(category);
-                    return (
-                      <button
-                        key={category._id}
-                        className={`kitchen-category-option ${
-                          selectedCategory?._id === category._id ? "selected" : ""
-                        }`}
-                        type="button"
-                        onClick={() => setSelectedCategory(category)}
-                      >
-                        <CategoryChip
-                          label={category.name}
-                          colorBg={colors.colorBg}
-                          colorText={colors.colorText}
-                        />
-                        {selectedCategory?._id === category._id ? (
-                          <span className="kitchen-category-check" aria-hidden="true">
-                            ✓
-                          </span>
-                        ) : null}
-                      </button>
-                    );
-                  })}
-                  {!hasExactCategory && categoryQuery ? (
-                    <button
-                      className="kitchen-button ghost"
-                      type="button"
-                      onClick={() => {
-                        setCategoryDraftName(categoryQuery.trim());
-                        setCreateError("");
-                        setShowCategoryModal(true);
-                      }}
-                    >
-                      Crear categoría “{categoryQuery}”
-                    </button>
-                  ) : null}
-                </div>
-              </div>
-              {createError ? <div className="kitchen-inline-error">{createError}</div> : null}
-            </div>
-            <div className="kitchen-context-modal-actions">
-              <button className="kitchen-button" type="button" onClick={handleCreateIngredient} disabled={saving}>
-                {saving ? "Guardando..." : "Crear ingrediente"}
-              </button>
-              <button className="kitchen-button secondary" type="button" onClick={closeCreateFlow}>
-                Cancelar
-              </button>
+        <div className="kitchen-context-modal-backdrop" role="presentation" onClick={closeCreateFlow}>
+          <div
+            className="kitchen-context-modal"
+            role="dialog"
+            aria-modal="true"
+            aria-label="Crear ingrediente"
+            onClick={(event) => event.stopPropagation()}
+          >
+            <div className="kitchen-context-modal-header">
+              <div>
+                <h4>Crear ingrediente</h4>
+                <p className="kitchen-muted">Añade un ingrediente rápido y sigue sumando al plato.</p>
+              </div>
+              <button className="kitchen-icon-button" type="button" onClick={closeCreateFlow} aria-label="Cerrar">
+                <svg viewBox="0 0 24 24" aria-hidden="true">
+                  <path
+                    d="M6 6l12 12M18 6l-12 12"
+                    fill="none"
+                    stroke="currentColor"
+                    strokeWidth="1.5"
+                    strokeLinecap="round"
+                  />
+                </svg>
+              </button>
+            </div>
+            <div className="kitchen-context-modal-body">
+              <label className="kitchen-field">
+                <span className="kitchen-label">Nombre del ingrediente</span>
+                <input
+                  className="kitchen-input"
+                  value={createName}
+                  ref={createInputRef}
+                  onChange={(event) => setCreateName(event.target.value)}
+                />
+              </label>
+              <div className="kitchen-field">
+                <span className="kitchen-label">Categoría</span>
+                <input
+                  className="kitchen-input"
+                  placeholder="Busca una categoría…"
+                  value={categoryQuery}
+                  onChange={(event) => setCategoryQuery(event.target.value)}
+                />
+                <div className="kitchen-category-list">
+                  {filteredCategories.map((category) => {
+                    const colors = resolveCategoryColors(category);
+                    return (
+                      <button
+                        key={category._id}
+                        className={`kitchen-category-option ${
+                          selectedCategory?._id === category._id ? "selected" : ""
+                        }`}
+                        type="button"
+                        onClick={() => setSelectedCategory(category)}
+                      >
+                        <CategoryChip
+                          label={category.name}
+                          colorBg={colors.colorBg}
+                          colorText={colors.colorText}
+                        />
+                        {selectedCategory?._id === category._id ? (
+                          <span className="kitchen-category-check" aria-hidden="true">
+                            ✓
+                          </span>
+                        ) : null}
+                      </button>
+                    );
+                  })}
+                  {!hasExactCategory && categoryQuery ? (
+                    <button
+                      className="kitchen-button ghost"
+                      type="button"
+                      onClick={() => {
+                        setCategoryDraftName(categoryQuery.trim());
+                        setCreateError("");
+                        setShowCategoryModal(true);
+                      }}
+                    >
+                      Crear categoría “{categoryQuery}”
+                    </button>
+                  ) : null}
+                </div>
+              </div>
+              {createError ? <div className="kitchen-inline-error">{createError}</div> : null}
+            </div>
+            <div className="kitchen-context-modal-actions">
+              <button className="kitchen-button" type="button" onClick={handleCreateIngredient} disabled={saving}>
+                {saving ? "Guardando..." : "Crear ingrediente"}
+              </button>
+              <button className="kitchen-button secondary" type="button" onClick={closeCreateFlow}>
+                Cancelar
+              </button>
             </div>
           </div>
-          {showCategoryModal ? (
-            <div
-              className="kitchen-context-modal-backdrop inner"
-              role="presentation"
-              onClick={(event) => {
-                event.stopPropagation();
-                setShowCategoryModal(false);
+          {showCategoryModal ? (
+            <div
+              className="kitchen-context-modal-backdrop inner"
+              role="presentation"
+              onClick={(event) => {
+                event.stopPropagation();
+                setShowCategoryModal(false);
               }}
             >
-              <div
-                className="kitchen-context-modal small"
-                role="dialog"
-                aria-modal="true"
-                aria-label="Crear categoría"
-                onClick={(event) => event.stopPropagation()}
-              >
-                <div className="kitchen-context-modal-header">
-                  <div>
-                    <h4>Crear categoría</h4>
-                    <p className="kitchen-muted">Define el nombre y elige un color si quieres.</p>
-                  </div>
-                  <button
-                    className="kitchen-icon-button"
-                    type="button"
-                    onClick={() => setShowCategoryModal(false)}
-                    aria-label="Cerrar"
-                  >
-                    <svg viewBox="0 0 24 24" aria-hidden="true">
-                      <path
-                        d="M6 6l12 12M18 6l-12 12"
-                        fill="none"
-                        stroke="currentColor"
-                        strokeWidth="1.5"
-                        strokeLinecap="round"
-                      />
-                    </svg>
-                  </button>
-                </div>
-                <div className="kitchen-context-modal-body">
-                  <label className="kitchen-field">
-                    <span className="kitchen-label">Nombre de categoría</span>
-                    <input
-                      className="kitchen-input"
-                      value={categoryDraftName}
-                      ref={categoryNameInputRef}
-                      onChange={(event) => setCategoryDraftName(event.target.value)}
-                    />
-                  </label>
-                  <div className="kitchen-field">
-                    <span className="kitchen-label">Color (opcional)</span>
-                    <div className="kitchen-color-grid">
-                      <button
-                        className={`kitchen-color-option ${categoryColor ? "" : "selected"}`}
-                        type="button"
-                        onClick={() => setCategoryColor(null)}
-                      >
-                        Automático
-                      </button>
-                      {PASTEL_PALETTE.map((palette) => (
-                        <button
-                          key={`${palette.colorBg}-${palette.colorText}`}
-                          className={`kitchen-color-option swatch ${
-                            categoryColor?.colorBg === palette.colorBg ? "selected" : ""
-                          }`}
-                          type="button"
-                          onClick={() => setCategoryColor(palette)}
-                          aria-label={`Color ${palette.colorBg}`}
-                          style={{
-                            background: palette.colorBg,
-                            color: palette.colorText
-                          }}
-                        >
-                          Aa
-                        </button>
-                      ))}
-                    </div>
-                  </div>
-                  {createError ? <div className="kitchen-inline-error">{createError}</div> : null}
-                </div>
-                <div className="kitchen-context-modal-actions">
-                  <button
-                    className="kitchen-button"
-                    type="button"
-                    onClick={handleCreateCategory}
-                    disabled={creatingCategory}
-                  >
-                    {creatingCategory ? "Guardando..." : "Guardar categoría"}
-                  </button>
-                  <button
-                    className="kitchen-button secondary"
-                    type="button"
-                    onClick={() => setShowCategoryModal(false)}
-                  >
-                    Cancelar
-                  </button>
-                </div>
-              </div>
-            </div>
-          ) : null}
+              <div
+                className="kitchen-context-modal small"
+                role="dialog"
+                aria-modal="true"
+                aria-label="Crear categoría"
+                onClick={(event) => event.stopPropagation()}
+              >
+                <div className="kitchen-context-modal-header">
+                  <div>
+                    <h4>Crear categoría</h4>
+                    <p className="kitchen-muted">Define el nombre y elige un color si quieres.</p>
+                  </div>
+                  <button
+                    className="kitchen-icon-button"
+                    type="button"
+                    onClick={() => setShowCategoryModal(false)}
+                    aria-label="Cerrar"
+                  >
+                    <svg viewBox="0 0 24 24" aria-hidden="true">
+                      <path
+                        d="M6 6l12 12M18 6l-12 12"
+                        fill="none"
+                        stroke="currentColor"
+                        strokeWidth="1.5"
+                        strokeLinecap="round"
+                      />
+                    </svg>
+                  </button>
+                </div>
+                <div className="kitchen-context-modal-body">
+                  <label className="kitchen-field">
+                    <span className="kitchen-label">Nombre de categoría</span>
+                    <input
+                      className="kitchen-input"
+                      value={categoryDraftName}
+                      ref={categoryNameInputRef}
+                      onChange={(event) => setCategoryDraftName(event.target.value)}
+                    />
+                  </label>
+                  <div className="kitchen-field">
+                    <span className="kitchen-label">Color (opcional)</span>
+                    <div className="kitchen-color-grid">
+                      <button
+                        className={`kitchen-color-option ${categoryColor ? "" : "selected"}`}
+                        type="button"
+                        onClick={() => setCategoryColor(null)}
+                      >
+                        Automático
+                      </button>
+                      {PASTEL_PALETTE.map((palette) => (
+                        <button
+                          key={`${palette.colorBg}-${palette.colorText}`}
+                          className={`kitchen-color-option swatch ${
+                            categoryColor?.colorBg === palette.colorBg ? "selected" : ""
+                          }`}
+                          type="button"
+                          onClick={() => setCategoryColor(palette)}
+                          aria-label={`Color ${palette.colorBg}`}
+                          style={{
+                            background: palette.colorBg,
+                            color: palette.colorText
+                          }}
+                        >
+                          Aa
+                        </button>
+                      ))}
+                    </div>
+                  </div>
+                  {createError ? <div className="kitchen-inline-error">{createError}</div> : null}
+                </div>
+                <div className="kitchen-context-modal-actions">
+                  <button
+                    className="kitchen-button"
+                    type="button"
+                    onClick={handleCreateCategory}
+                    disabled={creatingCategory}
+                  >
+                    {creatingCategory ? "Guardando..." : "Guardar categoría"}
+                  </button>
+                  <button
+                    className="kitchen-button secondary"
+                    type="button"
+                    onClick={() => setShowCategoryModal(false)}
+                  >
+                    Cancelar
+                  </button>
+                </div>
+              </div>
+            </div>
+          ) : null}
         </div>
       ) : null}
     </div>
   );
 }
diff --git a/frontend/src/kitchen/pages/SettingsPage.jsx b/frontend/src/kitchen/pages/SettingsPage.jsx
index c3dd51373a7af477ccf3cc488d83d4639b5bf978..ed3c8e5fa42e3ca89d3a28cc862ffb431e90ce7f 100644
--- a/frontend/src/kitchen/pages/SettingsPage.jsx
+++ b/frontend/src/kitchen/pages/SettingsPage.jsx
@@ -1,467 +1,491 @@
-import React, { useEffect, useMemo, useState } from "react";
-import { useNavigate } from "react-router-dom";
+import React, { useEffect, useMemo, useState } from "react";
+import { useNavigate } from "react-router-dom";
 import KitchenLayout from "../Layout.jsx";
-import { useAuth } from "../auth";
-import { apiRequest } from "../api.js";
+import { useAuth } from "../auth";
+import { apiRequest } from "../api.js";
 
 export default function SettingsPage() {
-  const { user, logout } = useAuth();
-  const navigate = useNavigate();
-  const [members, setMembers] = useState([]);
-  const [invitations, setInvitations] = useState([]);
-  const [inviteLink, setInviteLink] = useState("");
-  const [householdCode, setHouseholdCode] = useState("");
-  const [placeholderName, setPlaceholderName] = useState("");
-  const [loading, setLoading] = useState(true);
-  const [error, setError] = useState("");
-  const [success, setSuccess] = useState("");
-  const [categories, setCategories] = useState([]);
-  const [categoryName, setCategoryName] = useState("");
-  const [categoriesLoading, setCategoriesLoading] = useState(false);
-  const [masterStores, setMasterStores] = useState([]);
-  const [storesLoading, setStoresLoading] = useState(false);
-  const [storeName, setStoreName] = useState("");
-
-  const isOwner = user?.role === "owner" || user?.role === "admin";
-  const isDiod = user?.globalRole === "diod";
-  const isDiodGlobalMode = isDiod && !user?.activeHouseholdId;
-  const canManageCategories = isDiod || isOwner;
-  const canManageHousehold = isOwner && !isDiodGlobalMode;
-
-  const categoriesTitle = useMemo(() => (
-    isDiod ? "Categorías MASTER" : "Categorías del hogar"
-  ), [isDiod]);
-
-  const loadCategories = async () => {
-    if (!canManageCategories) {
-      setCategories([]);
-      return;
-    }
-    setCategoriesLoading(true);
-    try {
-      const data = await apiRequest("/api/categories");
-      setCategories(data.categories || []);
-    } catch (err) {
-      setError(err.message || "No se pudieron cargar las categorías.");
-    } finally {
-      setCategoriesLoading(false);
-    }
-  };
-
-  const loadMasterStores = async () => {
-    if (!isDiod) {
-      setMasterStores([]);
-      return;
-    }
-    setStoresLoading(true);
-    try {
-      const data = await apiRequest("/api/kitchen/shopping/stores/master");
-      setMasterStores(data.stores || []);
-    } catch (err) {
-      setError(err.message || "No se pudieron cargar los supermercados master.");
-    } finally {
-      setStoresLoading(false);
-    }
-  };
-
-  const loadData = async () => {
-    setLoading(true);
-    setError("");
-    try {
-      if (!isDiodGlobalMode) {
-        const membersResponse = await apiRequest("/api/kitchen/users/members");
-        setMembers(membersResponse.users || []);
-      } else {
-        setMembers([]);
-      }
-
-      if (canManageHousehold) {
-        const [inviteResponse, codeResponse] = await Promise.all([
-          apiRequest("/api/kitchen/household/invitations"),
-          apiRequest("/api/kitchen/household/invite-code")
-        ]);
-        setInvitations(inviteResponse.invitations || []);
-        setHouseholdCode(codeResponse.inviteCode || "");
-      } else {
-        setInvitations([]);
-        setHouseholdCode("");
-      }
-
-      await Promise.all([loadCategories(), loadMasterStores()]);
-    } catch (err) {
-      setError(err.message || "No se pudo cargar la configuración del hogar.");
-    } finally {
-      setLoading(false);
-    }
-  };
-
-  useEffect(() => {
-    void loadData();
-  }, [canManageHousehold, canManageCategories, isDiodGlobalMode]);
-
-  const handleLogout = async () => {
-    try {
-      await logout();
-    } finally {
-      navigate("/login", { replace: true });
-    }
-  };
-
-  const generateInvite = async () => {
-    setError("");
-    setSuccess("");
-    try {
-      const data = await apiRequest("/api/kitchen/household/invitations", { method: "POST" });
-      setInviteLink(data.inviteLink || "");
-      setSuccess("Enlace de invitación generado correctamente.");
-      await loadData();
-    } catch (err) {
-      setError(err.message || "No se pudo generar la invitación.");
-    }
-  };
-
-  const copyInvite = async () => {
-    if (!inviteLink) return;
-    try {
-      await navigator.clipboard.writeText(inviteLink);
-      setSuccess("Enlace copiado al portapapeles.");
-    } catch {
-      setError("No pudimos copiar el enlace automáticamente.");
-    }
-  };
-
-
-  const generateHouseholdCode = async () => {
-    setError("");
-    setSuccess("");
-    try {
-      const data = await apiRequest("/api/kitchen/household/invite-code", { method: "POST" });
-      setHouseholdCode(data.inviteCode || "");
-      setSuccess("Código de hogar generado correctamente.");
-    } catch (err) {
-      setError(err.message || "No se pudo generar el código del hogar.");
-    }
-  };
-
-  const copyHouseholdCode = async () => {
-    if (!householdCode) return;
-    try {
-      await navigator.clipboard.writeText(householdCode);
-      setSuccess("Código copiado al portapapeles.");
-    } catch {
-      setError("No pudimos copiar el código automáticamente.");
-    }
-  };
-
-  const createPlaceholder = async () => {
-    const safeName = placeholderName.trim();
-    if (!safeName) {
-      setError("Debes indicar un nombre para el comensal.");
-      return;
-    }
-
-    setError("");
-    setSuccess("");
-    try {
-      await apiRequest("/api/kitchen/household/placeholders", {
-        method: "POST",
-        body: JSON.stringify({ displayName: safeName })
-      });
-      setPlaceholderName("");
-      setSuccess("Comensal sin cuenta creado correctamente.");
-      await loadData();
-    } catch (err) {
-      setError(err.message || "No se pudo crear el comensal.");
-    }
-  };
-
-
-  const createCategory = async () => {
-    const safeName = categoryName.trim();
-    if (!safeName) return;
-    setError("");
-    setSuccess("");
-    try {
-      await apiRequest("/api/categories", {
-        method: "POST",
-        body: JSON.stringify({
-          name: safeName,
-          ...(isDiod ? { scope: "master" } : {})
-        })
-      });
-      setCategoryName("");
-      setSuccess("Categoría guardada correctamente.");
-      await Promise.all([loadCategories(), loadMasterStores()]);
-    } catch (err) {
-      setError(err.message || "No se pudo crear la categoría.");
-    }
-  };
-
-  const updateCategory = async (category) => {
-    const nextName = window.prompt("Nuevo nombre de la categoría", category.name || "");
-    if (!nextName || !nextName.trim()) return;
-    setError("");
-    setSuccess("");
-    try {
-      await apiRequest(`/api/categories/${category._id}`, {
-        method: "PUT",
-        body: JSON.stringify({
-          name: nextName.trim(),
-          colorBg: category.colorBg,
-          colorText: category.colorText,
-          active: category.active
-        })
-      });
-      setSuccess("Categoría actualizada correctamente.");
-      await Promise.all([loadCategories(), loadMasterStores()]);
-    } catch (err) {
-      setError(err.message || "No se pudo actualizar la categoría.");
-    }
-  };
-
-  const removeCategory = async (category) => {
-    const confirmed = window.confirm(`¿Eliminar la categoría “${category.name}”?`);
-    if (!confirmed) return;
-    setError("");
-    setSuccess("");
-    try {
-      await apiRequest(`/api/categories/${category._id}`, { method: "DELETE" });
-      setSuccess("Categoría eliminada correctamente.");
-      await Promise.all([loadCategories(), loadMasterStores()]);
-    } catch (err) {
-      setError(err.message || "No se pudo eliminar la categoría.");
-    }
-  };
-
-  const createMasterStore = async () => {
-    const safeName = storeName.trim();
-    if (!safeName) return;
-    setError("");
-    setSuccess("");
-    try {
-      await apiRequest("/api/kitchen/shopping/stores/master", {
-        method: "POST",
-        body: JSON.stringify({ name: safeName })
-      });
-      setStoreName("");
-      setSuccess("Supermercado master guardado.");
-      await loadMasterStores();
-    } catch (err) {
-      setError(err.message || "No se pudo guardar el supermercado master.");
-    }
-  };
-
-  const editMasterStore = async (store) => {
-    const nextName = window.prompt("Nombre del supermercado", store.name || "");
-    if (!nextName || !nextName.trim()) return;
-    setError("");
-    try {
-      await apiRequest(`/api/kitchen/shopping/stores/master/${store._id}`, {
-        method: "PUT",
-        body: JSON.stringify({ name: nextName.trim() })
-      });
-      await loadMasterStores();
-    } catch (err) {
-      setError(err.message || "No se pudo actualizar el supermercado.");
-    }
-  };
-
-  const archiveMasterStore = async (store) => {
-    if (!window.confirm(`¿Archivar ${store.name}?`)) return;
-    setError("");
-    try {
-      await apiRequest(`/api/kitchen/shopping/stores/master/${store._id}`, { method: "DELETE" });
-      await loadMasterStores();
-    } catch (err) {
-      setError(err.message || "No se pudo archivar el supermercado.");
-    }
-  };
-
-  const moveMasterStore = async (store, direction) => {
-    const sorted = [...masterStores];
-    const index = sorted.findIndex((item) => item._id === store._id);
-    const targetIndex = index + direction;
-    if (index < 0 || targetIndex < 0 || targetIndex >= sorted.length) return;
-    [sorted[index], sorted[targetIndex]] = [sorted[targetIndex], sorted[index]];
-    try {
-      await Promise.all(sorted.map((item, idx) => apiRequest(`/api/kitchen/shopping/stores/master/${item._id}`, {
-        method: "PUT",
-        body: JSON.stringify({ order: idx + 1 })
-      })));
-      await loadMasterStores();
-    } catch (err) {
-      setError(err.message || "No se pudo reordenar.");
-    }
-  };
-
+  const { user, logout } = useAuth();
+  const navigate = useNavigate();
+  const [members, setMembers] = useState([]);
+  const [invitations, setInvitations] = useState([]);
+  const [inviteLink, setInviteLink] = useState("");
+  const [householdCode, setHouseholdCode] = useState("");
+  const [placeholderName, setPlaceholderName] = useState("");
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState("");
+  const [success, setSuccess] = useState("");
+  const [categories, setCategories] = useState([]);
+  const [categoryName, setCategoryName] = useState("");
+  const [categoriesLoading, setCategoriesLoading] = useState(false);
+  const [masterStores, setMasterStores] = useState([]);
+  const [storesLoading, setStoresLoading] = useState(false);
+  const [storeName, setStoreName] = useState("");
+
+  const isOwner = user?.role === "owner" || user?.role === "admin";
+  const isDiod = user?.globalRole === "diod";
+  const isDiodGlobalMode = isDiod && !user?.activeHouseholdId;
+  const canManageCategories = isDiod || isOwner;
+  const canManageHousehold = isOwner && !isDiodGlobalMode;
+
+  const categoriesTitle = useMemo(() => (
+    isDiod ? "Categorías MASTER" : "Categorías del hogar"
+  ), [isDiod]);
+
+  const loadCategories = async () => {
+    if (!canManageCategories) {
+      setCategories([]);
+      return;
+    }
+    setCategoriesLoading(true);
+    try {
+      const data = await apiRequest("/api/categories");
+      setCategories(data.categories || []);
+    } catch (err) {
+      setError(err.message || "No se pudieron cargar las categorías.");
+    } finally {
+      setCategoriesLoading(false);
+    }
+  };
+
+  const loadMasterStores = async () => {
+    if (!isDiod) {
+      setMasterStores([]);
+      return;
+    }
+    setStoresLoading(true);
+    try {
+      const data = await apiRequest("/api/kitchen/shopping/stores/master");
+      setMasterStores(data.stores || []);
+    } catch (err) {
+      setError(err.message || "No se pudieron cargar los supermercados master.");
+    } finally {
+      setStoresLoading(false);
+    }
+  };
+
+  const loadData = async () => {
+    setLoading(true);
+    setError("");
+    try {
+      if (!isDiodGlobalMode) {
+        const membersResponse = await apiRequest("/api/kitchen/users/members");
+        setMembers(membersResponse.users || []);
+      } else {
+        setMembers([]);
+      }
+
+      if (canManageHousehold) {
+        const [inviteResponse, codeResponse] = await Promise.all([
+          apiRequest("/api/kitchen/household/invitations"),
+          apiRequest("/api/kitchen/household/invite-code")
+        ]);
+        setInvitations(inviteResponse.invitations || []);
+        setHouseholdCode(codeResponse.inviteCode || "");
+      } else {
+        setInvitations([]);
+        setHouseholdCode("");
+      }
+
+      await Promise.all([loadCategories(), loadMasterStores()]);
+    } catch (err) {
+      setError(err.message || "No se pudo cargar la configuración del hogar.");
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  useEffect(() => {
+    void loadData();
+  }, [canManageHousehold, canManageCategories, isDiodGlobalMode]);
+
+  const handleLogout = async () => {
+    try {
+      await logout();
+    } finally {
+      navigate("/login", { replace: true });
+    }
+  };
+
+  const generateInvite = async () => {
+    setError("");
+    setSuccess("");
+    try {
+      const data = await apiRequest("/api/kitchen/household/invitations", { method: "POST" });
+      setInviteLink(data.inviteLink || "");
+      setSuccess("Enlace de invitación generado correctamente.");
+      await loadData();
+    } catch (err) {
+      setError(err.message || "No se pudo generar la invitación.");
+    }
+  };
+
+  const copyInvite = async () => {
+    if (!inviteLink) return;
+    try {
+      await navigator.clipboard.writeText(inviteLink);
+      setSuccess("Enlace copiado al portapapeles.");
+    } catch {
+      setError("No pudimos copiar el enlace automáticamente.");
+    }
+  };
+
+
+  const generateHouseholdCode = async () => {
+    setError("");
+    setSuccess("");
+    try {
+      const data = await apiRequest("/api/kitchen/household/invite-code", { method: "POST" });
+      setHouseholdCode(data.inviteCode || "");
+      setSuccess("Código de hogar generado correctamente.");
+    } catch (err) {
+      setError(err.message || "No se pudo generar el código del hogar.");
+    }
+  };
+
+  const copyHouseholdCode = async () => {
+    if (!householdCode) return;
+    try {
+      await navigator.clipboard.writeText(householdCode);
+      setSuccess("Código copiado al portapapeles.");
+    } catch {
+      setError("No pudimos copiar el código automáticamente.");
+    }
+  };
+
+  const createPlaceholder = async () => {
+    const safeName = placeholderName.trim();
+    if (!safeName) {
+      setError("Debes indicar un nombre para el comensal.");
+      return;
+    }
+
+    setError("");
+    setSuccess("");
+    try {
+      await apiRequest("/api/kitchen/household/placeholders", {
+        method: "POST",
+        body: JSON.stringify({ displayName: safeName })
+      });
+      setPlaceholderName("");
+      setSuccess("Comensal sin cuenta creado correctamente.");
+      await loadData();
+    } catch (err) {
+      setError(err.message || "No se pudo crear el comensal.");
+    }
+  };
+
+
+  const createCategory = async () => {
+    const safeName = categoryName.trim();
+    if (!safeName) return;
+    setError("");
+    setSuccess("");
+    try {
+      await apiRequest("/api/categories", {
+        method: "POST",
+        body: JSON.stringify({
+          name: safeName,
+          ...(isDiod ? { scope: "master" } : {})
+        })
+      });
+      setCategoryName("");
+      setSuccess("Categoría guardada correctamente.");
+      await Promise.all([loadCategories(), loadMasterStores()]);
+    } catch (err) {
+      setError(err.message || "No se pudo crear la categoría.");
+    }
+  };
+
+  const updateCategory = async (category) => {
+    const nextName = window.prompt("Nuevo nombre de la categoría", category.name || "");
+    if (!nextName || !nextName.trim()) return;
+    setError("");
+    setSuccess("");
+    try {
+      await apiRequest(`/api/categories/${category._id}`, {
+        method: "PUT",
+        body: JSON.stringify({
+          name: nextName.trim(),
+          colorBg: category.colorBg,
+          colorText: category.colorText,
+          active: category.active
+        })
+      });
+      setSuccess("Categoría actualizada correctamente.");
+      await Promise.all([loadCategories(), loadMasterStores()]);
+    } catch (err) {
+      setError(err.message || "No se pudo actualizar la categoría.");
+    }
+  };
+
+  const toggleCategoryRecipe = async (category) => {
+    setError("");
+    setSuccess("");
+    try {
+      await apiRequest(`/api/categories/${category._id}`, {
+        method: "PUT",
+        body: JSON.stringify({
+          name: category.name,
+          colorBg: category.colorBg,
+          colorText: category.colorText,
+          active: category.active,
+          forRecipes: !category.forRecipes
+        })
+      });
+      setSuccess("Categoría actualizada correctamente.");
+      await Promise.all([loadCategories(), loadMasterStores()]);
+    } catch (err) {
+      setError(err.message || "No se pudo actualizar la categoría.");
+    }
+  };
+
+  const removeCategory = async (category) => {
+    const confirmed = window.confirm(`¿Eliminar la categoría “${category.name}”?`);
+    if (!confirmed) return;
+    setError("");
+    setSuccess("");
+    try {
+      await apiRequest(`/api/categories/${category._id}`, { method: "DELETE" });
+      setSuccess("Categoría eliminada correctamente.");
+      await Promise.all([loadCategories(), loadMasterStores()]);
+    } catch (err) {
+      setError(err.message || "No se pudo eliminar la categoría.");
+    }
+  };
+
+  const createMasterStore = async () => {
+    const safeName = storeName.trim();
+    if (!safeName) return;
+    setError("");
+    setSuccess("");
+    try {
+      await apiRequest("/api/kitchen/shopping/stores/master", {
+        method: "POST",
+        body: JSON.stringify({ name: safeName })
+      });
+      setStoreName("");
+      setSuccess("Supermercado master guardado.");
+      await loadMasterStores();
+    } catch (err) {
+      setError(err.message || "No se pudo guardar el supermercado master.");
+    }
+  };
+
+  const editMasterStore = async (store) => {
+    const nextName = window.prompt("Nombre del supermercado", store.name || "");
+    if (!nextName || !nextName.trim()) return;
+    setError("");
+    try {
+      await apiRequest(`/api/kitchen/shopping/stores/master/${store._id}`, {
+        method: "PUT",
+        body: JSON.stringify({ name: nextName.trim() })
+      });
+      await loadMasterStores();
+    } catch (err) {
+      setError(err.message || "No se pudo actualizar el supermercado.");
+    }
+  };
+
+  const archiveMasterStore = async (store) => {
+    if (!window.confirm(`¿Archivar ${store.name}?`)) return;
+    setError("");
+    try {
+      await apiRequest(`/api/kitchen/shopping/stores/master/${store._id}`, { method: "DELETE" });
+      await loadMasterStores();
+    } catch (err) {
+      setError(err.message || "No se pudo archivar el supermercado.");
+    }
+  };
+
+  const moveMasterStore = async (store, direction) => {
+    const sorted = [...masterStores];
+    const index = sorted.findIndex((item) => item._id === store._id);
+    const targetIndex = index + direction;
+    if (index < 0 || targetIndex < 0 || targetIndex >= sorted.length) return;
+    [sorted[index], sorted[targetIndex]] = [sorted[targetIndex], sorted[index]];
+    try {
+      await Promise.all(sorted.map((item, idx) => apiRequest(`/api/kitchen/shopping/stores/master/${item._id}`, {
+        method: "PUT",
+        body: JSON.stringify({ order: idx + 1 })
+      })));
+      await loadMasterStores();
+    } catch (err) {
+      setError(err.message || "No se pudo reordenar.");
+    }
+  };
+
   return (
     <KitchenLayout>
-      <div className="kitchen-card kitchen-block-gap">
+      <div className="kitchen-card kitchen-block-gap">
         <h2>Configuración</h2>
-        <p className="kitchen-muted">Gestiona tu hogar y tus miembros.</p>
-        {error ? <div className="kitchen-alert error">{error}</div> : null}
-        {success ? <div className="kitchen-alert success">{success}</div> : null}
-        {isDiodGlobalMode ? (
-          <div className="kitchen-alert">Modo global DIOD activo: selecciona un hogar para configuración de miembros e invitaciones.</div>
-        ) : null}
-
-        <h3>Mi Hogar</h3>
-        {loading ? <p className="kitchen-muted">Cargando miembros...</p> : null}
-        {!loading ? (
-          <ul className="kitchen-list">
-            {members.map((member) => (
-              <li key={member.id}>
-                <strong>{member.displayName}</strong>{" "}
-                {member.isPlaceholder ? "(comensal sin cuenta)" : member.email ? `(${member.email})` : ""}
-              </li>
-            ))}
-            {members.length === 0 ? <li className="kitchen-muted">Todavía no hay miembros.</li> : null}
-          </ul>
-        ) : null}
-
-        {canManageHousehold ? (
-          <>
-            <h3>Invitar miembros</h3>
-            <div className="kitchen-actions">
-              <button
-                type="button"
-                className="kitchen-button secondary"
-                onClick={copyHouseholdCode}
-                disabled={!householdCode}
-              >
-                Copiar código
-              </button>
-              <button type="button" className="kitchen-button" onClick={generateHouseholdCode}>
-                {householdCode ? "Regenerar código" : "Generar código"}
-              </button>
-            </div>
-            <p className="kitchen-muted">
-              Código del hogar: <strong>{householdCode || "No generado"}</strong>
-            </p>
-
-            <div className="kitchen-actions">
-              <button type="button" className="kitchen-button" onClick={generateInvite}>
-                Generar enlace
-              </button>
-              <button
-                type="button"
-                className="kitchen-button secondary"
-                onClick={copyInvite}
-                disabled={!inviteLink}
-              >
-                Copiar enlace
-              </button>
-            </div>
-            {inviteLink ? <p className="kitchen-muted">{inviteLink}</p> : null}
-
-            {invitations.length > 0 ? (
-              <ul className="kitchen-list">
-                {invitations.map((invitation) => (
-                  <li key={invitation.id}>
-                    Invitación activa hasta {new Date(invitation.expiresAt).toLocaleString()}
-                  </li>
-                ))}
-              </ul>
-            ) : null}
-
-            <h3>Añadir comensal (sin cuenta)</h3>
-            <div className="kitchen-actions">
-              <input
-                type="text"
-                className="kitchen-input"
-                placeholder="Nombre del comensal"
-                value={placeholderName}
-                onChange={(event) => setPlaceholderName(event.target.value)}
-              />
-              <button type="button" className="kitchen-button secondary" onClick={createPlaceholder}>
-                Añadir comensal sin cuenta
-              </button>
-            </div>
-          </>
-        ) : null}
-
-        {canManageCategories ? (
-          <>
-            <h3>{categoriesTitle}</h3>
-            <p className="kitchen-muted">
-              {isDiod
-                ? "Gestiona las categorías globales del catálogo MASTER."
-                : "Puedes crear categorías del hogar y sobrescribir las categorías master."}
-            </p>
-            <div className="kitchen-actions">
-              <input
-                type="text"
-                className="kitchen-input"
-                placeholder="Nombre de categoría"
-                value={categoryName}
-                onChange={(event) => setCategoryName(event.target.value)}
-              />
-              <button type="button" className="kitchen-button" onClick={createCategory} disabled={!categoryName.trim()}>
-                Añadir categoría
-              </button>
-            </div>
-            {categoriesLoading ? <p className="kitchen-muted">Cargando categorías...</p> : null}
-            {!categoriesLoading ? (
-              <ul className="kitchen-list">
-                {categories.map((category) => (
-                  <li key={category._id}>
-                    <strong>{category.name}</strong> <span className="kitchen-muted">({category.scope || "household"})</span>
-                    <div className="kitchen-actions" style={{ marginTop: 8 }}>
-                      <button type="button" className="kitchen-button secondary" onClick={() => updateCategory(category)}>
-                        Editar
-                      </button>
-                      <button type="button" className="kitchen-button secondary" onClick={() => removeCategory(category)}>
-                        Eliminar
-                      </button>
-                    </div>
-                  </li>
-                ))}
-                {categories.length === 0 ? <li className="kitchen-muted">No hay categorías disponibles.</li> : null}
-              </ul>
-            ) : null}
-          </>
-        ) : null}
-
-
-        {isDiod ? (
-          <>
-            <h3>Supermercados (master)</h3>
-            <div className="kitchen-actions">
-              <input
-                type="text"
-                className="kitchen-input"
-                placeholder="Nombre de supermercado"
-                value={storeName}
-                onChange={(event) => setStoreName(event.target.value)}
-              />
-              <button type="button" className="kitchen-button" onClick={createMasterStore} disabled={!storeName.trim()}>
-                Añadir supermercado
-              </button>
-            </div>
-            {storesLoading ? <p className="kitchen-muted">Cargando supermercados...</p> : null}
-            {!storesLoading ? (
-              <ul className="kitchen-list">
-                {masterStores.map((store) => (
-                  <li key={store._id}>
-                    <strong>{store.name}</strong> <span className="kitchen-muted">#{store.order ?? "-"} · {store.active ? "activo" : "archivado"}</span>
-                    <div className="kitchen-actions" style={{ marginTop: 8 }}>
-                      <button type="button" className="kitchen-button secondary" onClick={() => moveMasterStore(store, -1)}>↑</button>
-                      <button type="button" className="kitchen-button secondary" onClick={() => moveMasterStore(store, 1)}>↓</button>
-                      <button type="button" className="kitchen-button secondary" onClick={() => editMasterStore(store)}>Editar</button>
-                      <button type="button" className="kitchen-button secondary" onClick={() => archiveMasterStore(store)}>Archivar</button>
-                    </div>
-                  </li>
-                ))}
-                {masterStores.length === 0 ? <li className="kitchen-muted">No hay supermercados master.</li> : null}
-              </ul>
-            ) : null}
-          </>
-        ) : null}
-
-        <button type="button" className="kitchen-button secondary" onClick={handleLogout}>
-          Cerrar sesión
-        </button>
+        <p className="kitchen-muted">Gestiona tu hogar y tus miembros.</p>
+        {error ? <div className="kitchen-alert error">{error}</div> : null}
+        {success ? <div className="kitchen-alert success">{success}</div> : null}
+        {isDiodGlobalMode ? (
+          <div className="kitchen-alert">Modo global DIOD activo: selecciona un hogar para configuración de miembros e invitaciones.</div>
+        ) : null}
+
+        <h3>Mi Hogar</h3>
+        {loading ? <p className="kitchen-muted">Cargando miembros...</p> : null}
+        {!loading ? (
+          <ul className="kitchen-list">
+            {members.map((member) => (
+              <li key={member.id}>
+                <strong>{member.displayName}</strong>{" "}
+                {member.isPlaceholder ? "(comensal sin cuenta)" : member.email ? `(${member.email})` : ""}
+              </li>
+            ))}
+            {members.length === 0 ? <li className="kitchen-muted">Todavía no hay miembros.</li> : null}
+          </ul>
+        ) : null}
+
+        {canManageHousehold ? (
+          <>
+            <h3>Invitar miembros</h3>
+            <div className="kitchen-actions">
+              <button
+                type="button"
+                className="kitchen-button secondary"
+                onClick={copyHouseholdCode}
+                disabled={!householdCode}
+              >
+                Copiar código
+              </button>
+              <button type="button" className="kitchen-button" onClick={generateHouseholdCode}>
+                {householdCode ? "Regenerar código" : "Generar código"}
+              </button>
+            </div>
+            <p className="kitchen-muted">
+              Código del hogar: <strong>{householdCode || "No generado"}</strong>
+            </p>
+
+            <div className="kitchen-actions">
+              <button type="button" className="kitchen-button" onClick={generateInvite}>
+                Generar enlace
+              </button>
+              <button
+                type="button"
+                className="kitchen-button secondary"
+                onClick={copyInvite}
+                disabled={!inviteLink}
+              >
+                Copiar enlace
+              </button>
+            </div>
+            {inviteLink ? <p className="kitchen-muted">{inviteLink}</p> : null}
+
+            {invitations.length > 0 ? (
+              <ul className="kitchen-list">
+                {invitations.map((invitation) => (
+                  <li key={invitation.id}>
+                    Invitación activa hasta {new Date(invitation.expiresAt).toLocaleString()}
+                  </li>
+                ))}
+              </ul>
+            ) : null}
+
+            <h3>Añadir comensal (sin cuenta)</h3>
+            <div className="kitchen-actions">
+              <input
+                type="text"
+                className="kitchen-input"
+                placeholder="Nombre del comensal"
+                value={placeholderName}
+                onChange={(event) => setPlaceholderName(event.target.value)}
+              />
+              <button type="button" className="kitchen-button secondary" onClick={createPlaceholder}>
+                Añadir comensal sin cuenta
+              </button>
+            </div>
+          </>
+        ) : null}
+
+        {canManageCategories ? (
+          <>
+            <h3>{categoriesTitle}</h3>
+            <p className="kitchen-muted">
+              {isDiod
+                ? "Gestiona las categorías globales del catálogo MASTER."
+                : "Puedes crear categorías del hogar y sobrescribir las categorías master."}
+            </p>
+            <div className="kitchen-actions">
+              <input
+                type="text"
+                className="kitchen-input"
+                placeholder="Nombre de categoría"
+                value={categoryName}
+                onChange={(event) => setCategoryName(event.target.value)}
+              />
+              <button type="button" className="kitchen-button" onClick={createCategory} disabled={!categoryName.trim()}>
+                Añadir categoría
+              </button>
+            </div>
+            {categoriesLoading ? <p className="kitchen-muted">Cargando categorías...</p> : null}
+            {!categoriesLoading ? (
+              <ul className="kitchen-list">
+                {categories.map((category) => (
+                  <li key={category._id}>
+                    <strong>{category.name}</strong> <span className="kitchen-muted">({category.scope || "household"} · {category.forRecipes === false ? "no receta" : "receta"})</span>
+                    <div className="kitchen-actions" style={{ marginTop: 8 }}>
+                      <button type="button" className="kitchen-button secondary" onClick={() => updateCategory(category)}>
+                        Editar
+                      </button>
+                      <button type="button" className="kitchen-button secondary" onClick={() => toggleCategoryRecipe(category)}>
+                        {category.forRecipes === false ? "Usar en recetas" : "Excluir de recetas"}
+                      </button>
+                      <button type="button" className="kitchen-button secondary" onClick={() => removeCategory(category)}>
+                        Eliminar
+                      </button>
+                    </div>
+                  </li>
+                ))}
+                {categories.length === 0 ? <li className="kitchen-muted">No hay categorías disponibles.</li> : null}
+              </ul>
+            ) : null}
+          </>
+        ) : null}
+
+
+        {isDiod ? (
+          <>
+            <h3>Supermercados (master)</h3>
+            <div className="kitchen-actions">
+              <input
+                type="text"
+                className="kitchen-input"
+                placeholder="Nombre de supermercado"
+                value={storeName}
+                onChange={(event) => setStoreName(event.target.value)}
+              />
+              <button type="button" className="kitchen-button" onClick={createMasterStore} disabled={!storeName.trim()}>
+                Añadir supermercado
+              </button>
+            </div>
+            {storesLoading ? <p className="kitchen-muted">Cargando supermercados...</p> : null}
+            {!storesLoading ? (
+              <ul className="kitchen-list">
+                {masterStores.map((store) => (
+                  <li key={store._id}>
+                    <strong>{store.name}</strong> <span className="kitchen-muted">#{store.order ?? "-"} · {store.active ? "activo" : "archivado"}</span>
+                    <div className="kitchen-actions" style={{ marginTop: 8 }}>
+                      <button type="button" className="kitchen-button secondary" onClick={() => moveMasterStore(store, -1)}>↑</button>
+                      <button type="button" className="kitchen-button secondary" onClick={() => moveMasterStore(store, 1)}>↓</button>
+                      <button type="button" className="kitchen-button secondary" onClick={() => editMasterStore(store)}>Editar</button>
+                      <button type="button" className="kitchen-button secondary" onClick={() => archiveMasterStore(store)}>Archivar</button>
+                    </div>
+                  </li>
+                ))}
+                {masterStores.length === 0 ? <li className="kitchen-muted">No hay supermercados master.</li> : null}
+              </ul>
+            ) : null}
+          </>
+        ) : null}
+
+        <button type="button" className="kitchen-button secondary" onClick={handleLogout}>
+          Cerrar sesión
+        </button>
       </div>
     </KitchenLayout>
   );
 }
diff --git a/frontend/src/kitchen/pages/ShoppingPage.jsx b/frontend/src/kitchen/pages/ShoppingPage.jsx
index d44b32a02c0a686bab190ed519b60e4bf0898a7c..5e86ac46ff7988eac5bad3027cbe063f308f7899 100644
--- a/frontend/src/kitchen/pages/ShoppingPage.jsx
+++ b/frontend/src/kitchen/pages/ShoppingPage.jsx
@@ -1,410 +1,545 @@
-import React, { useEffect, useMemo, useRef, useState } from "react";
-import KitchenLayout from "../Layout.jsx";
-import { ApiRequestError, apiRequest } from "../api.js";
-import { useAuth } from "../auth";
-import { useActiveWeek } from "../weekContext.jsx";
-import WeekNavigator from "../components/ui/WeekNavigator.jsx";
-
-function RefreshIcon(props) {
-  return (
-    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
-      <path d="M20 12a8 8 0 1 1-2.343-5.657" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round"/>
-      <path d="M20 4v4h-4" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round"/>
-    </svg>
-  );
-}
-
-function EmptyStateIcon(props) {
-  return (
-    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
-      <path d="M4 7.5h16" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
-      <path d="M6.5 7.5V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1.5" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
-      <path d="M7.5 10.5h9l-.75 7.1a2 2 0 0 1-1.99 1.8H10.24a2 2 0 0 1-1.99-1.8z" stroke="currentColor" strokeWidth="1.8" strokeLinejoin="round" />
-    </svg>
-  );
-}
-
-function EmptyCheckIcon(props) {
-  return (
-    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
-      <path d="M7 12.5 10.5 16 17.5 9" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
-      <path d="M12 21a9 9 0 1 0-9-9" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
-    </svg>
-  );
-}
-
-function EmptyListIcon(props) {
-  return (
-    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
-      <path d="M8 7h10M8 12h10M8 17h10" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
-      <circle cx="5" cy="7" r="1" fill="currentColor" />
-      <circle cx="5" cy="12" r="1" fill="currentColor" />
-      <circle cx="5" cy="17" r="1" fill="currentColor" />
-    </svg>
-  );
-}
-
-function EmptyHistoryIcon(props) {
-  return (
-    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
-      <path d="M12 7.5v5l3 1.8" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
-      <path d="M3.8 12a8.2 8.2 0 1 0 2.4-5.8" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
-      <path d="M3.5 5.7v2.9h2.9" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
-    </svg>
-  );
-}
-
-function addDaysToISO(iso, days) {
-  const date = new Date(`${iso}T00:00:00Z`);
-  date.setUTCDate(date.getUTCDate() + days);
-  return date.toISOString().slice(0, 10);
-}
-
-function normalizeWeekStartInput(value) {
-  if (!value) return "";
-  const d = new Date(`${value}T00:00:00Z`);
-  const day = d.getUTCDay();
-  const diff = (day === 0 ? -6 : 1) - day;
-  d.setUTCDate(d.getUTCDate() + diff);
-  return d.toISOString().slice(0, 10);
-}
-
-function formatWeekTitle(iso) {
-  if (!iso) return "";
-  return new Date(`${iso}T00:00:00Z`).toLocaleDateString("es-ES", {
-    day: "2-digit",
-    month: "2-digit",
-    year: "numeric"
-  });
-}
-
-function formatTripDate(value) {
-  if (!value || value === "sin-fecha") return "Sin fecha";
-  return new Date(`${value}T00:00:00Z`).toLocaleDateString("es-ES", { day: "2-digit", month: "2-digit", year: "numeric" });
-}
-
-function slugColor(slug = "") {
-  const normalized = String(slug || "otros");
-  const seed = normalized.split("").reduce((acc, char) => acc + char.charCodeAt(0), 0);
-  const hue = seed % 360;
-  return {
-    colorBg: `hsl(${hue} 70% 95%)`,
-    colorText: `hsl(${hue} 55% 35%)`
-  };
-}
-
-function itemKey(item) {
-  return `${item.ingredientId || "no-id"}-${item.canonicalName}`;
-}
-
-export default function ShoppingPage() {
-  const { user } = useAuth();
-  const { activeWeek: weekStart, setActiveWeek: setWeekStart } = useActiveWeek();
-  const [tab, setTab] = useState("pending");
-  const [error, setError] = useState("");
-  const [success, setSuccess] = useState("");
-  const [isRefreshing, setIsRefreshing] = useState(false);
-  const [stores, setStores] = useState([]);
-  const [selectedStoreId, setSelectedStoreId] = useState("");
-  const selectedStoreRef = useRef("");
-  const [pendingByCategory, setPendingByCategory] = useState(null);
-  const [purchasedByStoreDay, setPurchasedByStoreDay] = useState(null);
-  const [transitioningItemKey, setTransitioningItemKey] = useState(null);
-  const [recentlyMovedItemKey, setRecentlyMovedItemKey] = useState(null);
-  const isDiodGlobalMode = user?.globalRole === "diod" && !user?.activeHouseholdId;
-
-  const applyPayload = (data) => {
-    setStores(data.stores || []);
-    setPendingByCategory(data.pendingByCategory || []);
-    setPurchasedByStoreDay(data.purchasedByStoreDay || []);
-  };
-
-  const logShoppingApiError = (context, endpoint, err) => {
-    if (err instanceof ApiRequestError) {
-      console.error(`[shopping] ${context} failed`, {
-        endpoint,
-        status: err.status,
-        body: err.body,
-        message: err.message
-      });
-      return;
-    }
-    console.error(`[shopping] ${context} failed`, { endpoint, message: err?.message || err });
-  };
-
-  const loadList = async ({ silent = false } = {}) => {
-    if (isDiodGlobalMode) return;
-    if (!silent) setIsRefreshing(true);
-    setError("");
-    try {
-      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}`);
-      applyPayload(data);
-    } catch (err) {
-      logShoppingApiError("loadList", `/api/kitchen/shopping/${weekStart}`, err);
-      setPendingByCategory(null);
-      setPurchasedByStoreDay(null);
-      setError(err.message || "No se pudo cargar la lista.");
-    } finally {
-      if (!silent) setIsRefreshing(false);
-    }
-  };
-
-  useEffect(() => {
-    void loadList();
-  }, [weekStart, isDiodGlobalMode]);
-
-  useEffect(() => {
-    if (!recentlyMovedItemKey) return undefined;
-    const timer = setTimeout(() => setRecentlyMovedItemKey(null), 650);
-    return () => clearTimeout(timer);
-  }, [recentlyMovedItemKey]);
-
-  const refreshList = async () => {
-    if (isDiodGlobalMode) return;
-    setIsRefreshing(true);
-    try {
-      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/rebuild`, { method: "POST" });
-      applyPayload(data);
-      setSuccess("Lista reconstruida");
-    } catch (err) {
-      logShoppingApiError("refreshList", `/api/kitchen/shopping/${weekStart}/rebuild`, err);
-      setError(err.message || "No se pudo refrescar la lista.");
-    } finally {
-      setIsRefreshing(false);
-    }
-  };
-
-  const setItemStatus = async (item, status) => {
-    if (isDiodGlobalMode) return;
-    const key = itemKey(item);
-    setTransitioningItemKey(key);
-    try {
-      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/item`, {
-        method: "PUT",
-        body: JSON.stringify({
-          canonicalName: item.canonicalName,
-          ingredientId: item.ingredientId,
-          status,
-          storeId: status === "purchased" ? selectedStoreRef.current || null : null
-        })
-      });
-      applyPayload(data);
-      setRecentlyMovedItemKey(key);
-    } catch (err) {
-      logShoppingApiError("setItemStatus", `/api/kitchen/shopping/${weekStart}/item`, err);
-      setError(err.message || "No se pudo actualizar.");
-    } finally {
-      setTransitioningItemKey(null);
-    }
-  };
-
-  const updatePurchasedItemStore = async (item, storeId) => {
-    try {
-      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/item/store`, {
-        method: "PUT",
-        body: JSON.stringify({ canonicalName: item.canonicalName, ingredientId: item.ingredientId, storeId: storeId || null })
-      });
-      applyPayload(data);
-    } catch (err) {
-      logShoppingApiError("updatePurchasedItemStore", `/api/kitchen/shopping/${weekStart}/item/store`, err);
-      setError(err.message || "No se pudo cambiar el supermercado.");
-    }
-  };
-
-  const setAllItemsStatus = async (status) => {
-    try {
-      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/items/status`, {
-        method: "PUT",
-        body: JSON.stringify({
-          status,
-          storeId: status === "purchased" ? selectedStoreId || null : null
-        })
-      });
-      applyPayload(data);
-      if (status === "purchased") {
-        setSuccess(data.updated ? "Todo marcado como comprado" : "No había elementos pendientes.");
-      } else {
-        setSuccess(data.updated ? "Todo volvió a pendiente" : "No había elementos comprados.");
-      }
-    } catch (err) {
-      logShoppingApiError("setAllItemsStatus", `/api/kitchen/shopping/${weekStart}/items/status`, err);
-      setError(err.message || "No se pudo actualizar en bloque.");
-    }
-  };
-
-  const createStoreFromDropdown = async () => {
-    const name = window.prompt("Nombre del supermercado");
-    if (!name || !name.trim()) return;
-    setError("");
-    try {
-      await apiRequest("/api/kitchen/shopping/stores", {
-        method: "POST",
-        body: JSON.stringify({ name: name.trim() })
-      });
-      await loadList({ silent: true });
-    } catch (err) {
-      logShoppingApiError("createStoreFromDropdown", "/api/kitchen/shopping/stores", err);
-      setError(err.message || "No se pudo crear el supermercado.");
-    }
-  };
-
-  const pendingCount = useMemo(() => {
-    if (!Array.isArray(pendingByCategory)) return null;
-    return pendingByCategory.reduce((acc, group) => acc + (group.items?.length || 0), 0);
-  }, [pendingByCategory]);
-
-  const purchasedCount = useMemo(() => {
-    if (!Array.isArray(purchasedByStoreDay)) return null;
-    return purchasedByStoreDay.reduce((acc, group) => acc + (group.items?.length || 0), 0);
-  }, [purchasedByStoreDay]);
-
-  if (isDiodGlobalMode) {
-    return (
-      <KitchenLayout>
-        <div className="kitchen-card">Selecciona un hogar activo para ver su lista de la compra.</div>
-      </KitchenLayout>
-    );
-  }
-
-  return (
-    <KitchenLayout>
-      <div className="shopping-page-shell">
-        <div className="kitchen-card shopping-main-card">
-          <div className="shopping-header-card">
-            <div className="shopping-header-row">
-              <div>
-                <h1>Lista de la compra · Semana {formatWeekTitle(weekStart)}</h1>
-              </div>
-              <button className="shopping-refresh-icon" type="button" onClick={refreshList} disabled={isRefreshing} aria-label="Reconstruir lista" title="Reconstruir lista">
-                <RefreshIcon className="shopping-week-arrow-icon" />
-              </button>
-            </div>
-
-            <WeekNavigator
-              className="shopping-week-nav"
-              value={weekStart}
-              onChange={(nextValue) => setWeekStart(normalizeWeekStartInput(nextValue))}
-              onPrevious={() => setWeekStart((prev) => addDaysToISO(prev, -7))}
-              onNext={() => setWeekStart((prev) => addDaysToISO(prev, 7))}
-            />
-
-          </div>
-
-          <div className="kitchen-dishes-tabs" role="tablist" aria-label="Estado de la compra">
-            <button className={`kitchen-tab-button ${tab === "pending" ? "is-active" : ""}`} onClick={() => setTab("pending")}>Pendiente ({pendingCount === null ? "—" : pendingCount})</button>
-            <button className={`kitchen-tab-button ${tab === "purchased" ? "is-active" : ""}`} onClick={() => setTab("purchased")}>Comprado</button>
-          </div>
-
-          {tab === "pending" ? (
-            <div className="shopping-toolbar">
-              <select
-                className="kitchen-select shopping-store-select"
-                value={selectedStoreId}
-                onChange={(event) => {
-                  const value = event.target.value;
-                  if (value === "__add__") {
-                    void createStoreFromDropdown();
-                    return;
-                  }
-                  selectedStoreRef.current = value;
-                  setSelectedStoreId(value);
-                }}
-              >
-                <option value="">Supermercado (opcional)</option>
-                {stores.map((store) => (
-                  <option key={store._id} value={store._id}>{store.name}</option>
-                ))}
-                <option value="__add__">Añadir supermercado…</option>
-              </select>
-            </div>
-          ) : null}
-
-          {(success || error) ? (
-            <div className="shopping-toolbar-alerts" aria-live="polite">
-              {success ? <div className="kitchen-alert success shopping-toolbar-alert">{success}</div> : null}
-              {error ? <div className="kitchen-alert error shopping-toolbar-alert">{error}</div> : null}
-            </div>
-          ) : null}
-
-          {tab === "pending" ? (
-            <div className="shopping-categories">
-              <div className="shopping-bulk-actions">
-                <button className="kitchen-button ghost shopping-bulk-button" type="button" onClick={() => setAllItemsStatus("purchased")}>Marcar todo como comprado</button>
-              </div>
-              {!Array.isArray(pendingByCategory) ? (
-                <div className="shopping-empty-state"><EmptyStateIcon /><h4>No se pudo cargar la lista.</h4></div>
-              ) : pendingByCategory.length === 0 ? (
-                <div className="shopping-empty-state">
-                  {purchasedCount ? <EmptyCheckIcon /> : <EmptyListIcon />}
-                  <h4>{purchasedCount ? "Todo comprado por esta semana." : "No hay nada por comprar todavía."}</h4>
-                </div>
-              ) : pendingByCategory.map((group) => {
-              const category = { name: group.categoryInfo?.name || "Sin categoría", ...slugColor(group.categoryInfo?.slug), ...group.categoryInfo };
-              return (
-                <div className="shopping-category-card" key={group.categoryId || group.categoryInfo?.slug || group.categoryInfo?.name} style={{ "--category-bg": category.colorBg, "--category-text": category.colorText }}>
-                  <div className="shopping-category-head"><h4>{category.name.toUpperCase()}</h4><span className="shopping-category-count">{group.items.length} items</span></div>
-                  <div className="shopping-items-list">
-                    {group.items.map((item) => {
-                      const key = itemKey(item);
-                      return (
-                        <div className={`shopping-item ${transitioningItemKey === key ? "is-leaving" : ""}`} key={key}>
-                          <button className="shopping-check" type="button" onClick={() => setItemStatus(item, "purchased")}><span className="shopping-check-dot">✓</span></button>
-                          <span className="shopping-item-text">{item.displayName}</span>
-                          {item.occurrences > 1 ? <span className="shopping-item-amount">x{item.occurrences}</span> : null}
-                        </div>
-                      );
-                    })}
-                  </div>
-                </div>
-              );
-              })}
-            </div>
-          ) : (
-            <div className="shopping-categories">
-              <div className="shopping-bulk-actions">
-                <button
-                  className="kitchen-button ghost shopping-bulk-button"
-                  type="button"
-                  onClick={() => {
-                    if (window.confirm("¿Desmarcar todo lo comprado de esta semana?")) {
-                      void setAllItemsStatus("pending");
-                    }
-                  }}
-                >
-                  Desmarcar todo
-                </button>
-              </div>
-              {!Array.isArray(purchasedByStoreDay) ? (
-                <div className="shopping-empty-state"><EmptyStateIcon /><h4>No se pudo cargar la lista.</h4></div>
-              ) : purchasedByStoreDay.length === 0 ? (
-                <div className="shopping-empty-state"><EmptyHistoryIcon /><h4>No hay nada comprado esta semana.</h4></div>
-              ) : purchasedByStoreDay.map((group) => (
-              <div className="shopping-category-card shopping-purchased-card" key={`${group.purchasedDate}-${group.storeId || "none"}`}>
-                <h4>Comprado por <span>{group.purchasedByName || "Usuario"}</span> · <em>{group.storeName || "Sin supermercado"}</em> · {formatTripDate(group.purchasedDate)}</h4>
-                <div className="shopping-items-list shopping-items-list-purchased">
-                  {group.items.map((item) => {
-                    const key = itemKey(item);
-                    return (
-                      <div className={`shopping-item purchased ${transitioningItemKey === key ? "is-leaving" : ""} ${recentlyMovedItemKey === key ? "is-entering" : ""}`} key={key}>
-                        <button className="shopping-check is-checked" type="button" onClick={() => setItemStatus(item, "pending")}><span className="shopping-check-dot">✓</span></button>
-                        <span className="shopping-item-text">{item.displayName}</span>
-                        {item.occurrences > 1 ? <span className="shopping-item-amount">x{item.occurrences}</span> : null}
-                        <select className="kitchen-select shopping-store-select-compact" value={item.storeId || ""} onChange={(event) => updatePurchasedItemStore(item, event.target.value)}>
-                          <option value="">Sin supermercado</option>
-                          {stores.map((store) => (
-                            <option key={store._id} value={store._id}>{store.name}</option>
-                          ))}
-                        </select>
-                      </div>
-                    );
-                  })}
-                </div>
-              </div>
-            ))}
-            </div>
-          )}
-        </div>
-      </div>
-    </KitchenLayout>
-  );
-}
+import React, { useEffect, useMemo, useRef, useState } from "react";
+import KitchenLayout from "../Layout.jsx";
+import { ApiRequestError, apiRequest } from "../api.js";
+import { useAuth } from "../auth";
+import { useActiveWeek } from "../weekContext.jsx";
+import WeekNavigator from "../components/ui/WeekNavigator.jsx";
+
+function RefreshIcon(props) {
+  return (
+    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
+      <path d="M20 12a8 8 0 1 1-2.343-5.657" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round"/>
+      <path d="M20 4v4h-4" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round"/>
+    </svg>
+  );
+}
+
+function EmptyStateIcon(props) {
+  return (
+    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
+      <path d="M4 7.5h16" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
+      <path d="M6.5 7.5V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1.5" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
+      <path d="M7.5 10.5h9l-.75 7.1a2 2 0 0 1-1.99 1.8H10.24a2 2 0 0 1-1.99-1.8z" stroke="currentColor" strokeWidth="1.8" strokeLinejoin="round" />
+    </svg>
+  );
+}
+
+function EmptyCheckIcon(props) {
+  return (
+    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
+      <path d="M7 12.5 10.5 16 17.5 9" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
+      <path d="M12 21a9 9 0 1 0-9-9" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
+    </svg>
+  );
+}
+
+function EmptyListIcon(props) {
+  return (
+    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
+      <path d="M8 7h10M8 12h10M8 17h10" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
+      <circle cx="5" cy="7" r="1" fill="currentColor" />
+      <circle cx="5" cy="12" r="1" fill="currentColor" />
+      <circle cx="5" cy="17" r="1" fill="currentColor" />
+    </svg>
+  );
+}
+
+function EmptyHistoryIcon(props) {
+  return (
+    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" {...props}>
+      <path d="M12 7.5v5l3 1.8" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
+      <path d="M3.8 12a8.2 8.2 0 1 0 2.4-5.8" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" />
+      <path d="M3.5 5.7v2.9h2.9" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
+    </svg>
+  );
+}
+
+function addDaysToISO(iso, days) {
+  const date = new Date(`${iso}T00:00:00Z`);
+  date.setUTCDate(date.getUTCDate() + days);
+  return date.toISOString().slice(0, 10);
+}
+
+function normalizeWeekStartInput(value) {
+  if (!value) return "";
+  const d = new Date(`${value}T00:00:00Z`);
+  const day = d.getUTCDay();
+  const diff = (day === 0 ? -6 : 1) - day;
+  d.setUTCDate(d.getUTCDate() + diff);
+  return d.toISOString().slice(0, 10);
+}
+
+function formatWeekTitle(iso) {
+  if (!iso) return "";
+  return new Date(`${iso}T00:00:00Z`).toLocaleDateString("es-ES", {
+    day: "2-digit",
+    month: "2-digit",
+    year: "numeric"
+  });
+}
+
+function formatTripDate(value) {
+  if (!value || value === "sin-fecha") return "Sin fecha";
+  return new Date(`${value}T00:00:00Z`).toLocaleDateString("es-ES", { day: "2-digit", month: "2-digit", year: "numeric" });
+}
+
+function slugColor(slug = "") {
+  const normalized = String(slug || "otros");
+  const seed = normalized.split("").reduce((acc, char) => acc + char.charCodeAt(0), 0);
+  const hue = seed % 360;
+  return {
+    colorBg: `hsl(${hue} 70% 95%)`,
+    colorText: `hsl(${hue} 55% 35%)`
+  };
+}
+
+function itemKey(item) {
+  return `${item.ingredientId || "no-id"}-${item.canonicalName}`;
+}
+
+function normalizeQuery(value = "") {
+  return String(value).trim().toLowerCase();
+}
+
+export default function ShoppingPage() {
+  const { user } = useAuth();
+  const { activeWeek: weekStart, setActiveWeek: setWeekStart } = useActiveWeek();
+  const [tab, setTab] = useState("pending");
+  const [error, setError] = useState("");
+  const [success, setSuccess] = useState("");
+  const [isRefreshing, setIsRefreshing] = useState(false);
+  const [stores, setStores] = useState([]);
+  const [selectedStoreId, setSelectedStoreId] = useState("");
+  const selectedStoreRef = useRef("");
+  const [pendingByCategory, setPendingByCategory] = useState(null);
+  const [purchasedByStoreDay, setPurchasedByStoreDay] = useState(null);
+  const [transitioningItemKey, setTransitioningItemKey] = useState(null);
+  const [recentlyMovedItemKey, setRecentlyMovedItemKey] = useState(null);
+  const [manualOpen, setManualOpen] = useState(false);
+  const [manualQuery, setManualQuery] = useState("");
+  const [manualSuggestions, setManualSuggestions] = useState([]);
+  const [manualCategories, setManualCategories] = useState([]);
+  const [manualIngredient, setManualIngredient] = useState(null);
+  const [manualCategoryId, setManualCategoryId] = useState("");
+  const [manualSaving, setManualSaving] = useState(false);
+  const isDiodGlobalMode = user?.globalRole === "diod" && !user?.activeHouseholdId;
+
+  const applyPayload = (data) => {
+    setStores(data.stores || []);
+    setPendingByCategory(data.pendingByCategory || []);
+    setPurchasedByStoreDay(data.purchasedByStoreDay || []);
+  };
+
+  const logShoppingApiError = (context, endpoint, err) => {
+    if (err instanceof ApiRequestError) {
+      console.error(`[shopping] ${context} failed`, {
+        endpoint,
+        status: err.status,
+        body: err.body,
+        message: err.message
+      });
+      return;
+    }
+    console.error(`[shopping] ${context} failed`, { endpoint, message: err?.message || err });
+  };
+
+  const loadList = async ({ silent = false } = {}) => {
+    if (isDiodGlobalMode) return;
+    if (!silent) setIsRefreshing(true);
+    setError("");
+    try {
+      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}`);
+      applyPayload(data);
+    } catch (err) {
+      logShoppingApiError("loadList", `/api/kitchen/shopping/${weekStart}`, err);
+      setPendingByCategory(null);
+      setPurchasedByStoreDay(null);
+      setError(err.message || "No se pudo cargar la lista.");
+    } finally {
+      if (!silent) setIsRefreshing(false);
+    }
+  };
+
+  useEffect(() => {
+    void loadList();
+  }, [weekStart, isDiodGlobalMode]);
+
+  useEffect(() => {
+    if (!recentlyMovedItemKey) return undefined;
+    const timer = setTimeout(() => setRecentlyMovedItemKey(null), 650);
+    return () => clearTimeout(timer);
+  }, [recentlyMovedItemKey]);
+
+  useEffect(() => {
+    if (!manualOpen) return;
+    let active = true;
+    const loadBase = async () => {
+      try {
+        const [categoriesData, ingredientsData] = await Promise.all([
+          apiRequest("/api/categories"),
+          apiRequest("/api/kitchenIngredients?limit=30")
+        ]);
+        if (!active) return;
+        setManualCategories(categoriesData.categories || []);
+        setManualSuggestions(ingredientsData.ingredients || []);
+      } catch (err) {
+        if (!active) return;
+        setError(err.message || "No se pudo preparar el alta manual.");
+      }
+    };
+    void loadBase();
+    return () => {
+      active = false;
+    };
+  }, [manualOpen]);
+
+  useEffect(() => {
+    if (!manualOpen) return;
+    let active = true;
+    const timer = setTimeout(async () => {
+      try {
+        const data = await apiRequest(`/api/kitchenIngredients?q=${encodeURIComponent(manualQuery)}&limit=30`);
+        if (!active) return;
+        setManualSuggestions(data.ingredients || []);
+      } catch {
+        if (!active) return;
+        setManualSuggestions([]);
+      }
+    }, 200);
+    return () => {
+      active = false;
+      clearTimeout(timer);
+    };
+  }, [manualOpen, manualQuery]);
+
+  const refreshList = async () => {
+    if (isDiodGlobalMode) return;
+    setIsRefreshing(true);
+    try {
+      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/rebuild`, { method: "POST" });
+      applyPayload(data);
+      setSuccess("Lista reconstruida");
+    } catch (err) {
+      logShoppingApiError("refreshList", `/api/kitchen/shopping/${weekStart}/rebuild`, err);
+      setError(err.message || "No se pudo refrescar la lista.");
+    } finally {
+      setIsRefreshing(false);
+    }
+  };
+
+  const setItemStatus = async (item, status) => {
+    if (isDiodGlobalMode) return;
+    const key = itemKey(item);
+    setTransitioningItemKey(key);
+    try {
+      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/item`, {
+        method: "PUT",
+        body: JSON.stringify({
+          canonicalName: item.canonicalName,
+          ingredientId: item.ingredientId,
+          status,
+          storeId: status === "purchased" ? selectedStoreRef.current || null : null
+        })
+      });
+      applyPayload(data);
+      setRecentlyMovedItemKey(key);
+    } catch (err) {
+      logShoppingApiError("setItemStatus", `/api/kitchen/shopping/${weekStart}/item`, err);
+      setError(err.message || "No se pudo actualizar.");
+    } finally {
+      setTransitioningItemKey(null);
+    }
+  };
+
+  const updatePurchasedItemStore = async (item, storeId) => {
+    try {
+      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/item/store`, {
+        method: "PUT",
+        body: JSON.stringify({ canonicalName: item.canonicalName, ingredientId: item.ingredientId, storeId: storeId || null })
+      });
+      applyPayload(data);
+    } catch (err) {
+      logShoppingApiError("updatePurchasedItemStore", `/api/kitchen/shopping/${weekStart}/item/store`, err);
+      setError(err.message || "No se pudo cambiar el supermercado.");
+    }
+  };
+
+  const setAllItemsStatus = async (status) => {
+    try {
+      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/items/status`, {
+        method: "PUT",
+        body: JSON.stringify({
+          status,
+          storeId: status === "purchased" ? selectedStoreId || null : null
+        })
+      });
+      applyPayload(data);
+      if (status === "purchased") {
+        setSuccess(data.updated ? "Todo marcado como comprado" : "No había elementos pendientes.");
+      } else {
+        setSuccess(data.updated ? "Todo volvió a pendiente" : "No había elementos comprados.");
+      }
+    } catch (err) {
+      logShoppingApiError("setAllItemsStatus", `/api/kitchen/shopping/${weekStart}/items/status`, err);
+      setError(err.message || "No se pudo actualizar en bloque.");
+    }
+  };
+
+  const createManualIngredient = async () => {
+    if (!manualQuery.trim() || !manualCategoryId) return null;
+    const data = await apiRequest("/api/kitchenIngredients", {
+      method: "POST",
+      body: JSON.stringify({
+        name: manualQuery.trim(),
+        categoryId: manualCategoryId,
+        scope: "household",
+        householdId: user?.activeHouseholdId || null
+      })
+    });
+    return data.ingredient || null;
+  };
+
+  const submitManualItem = async () => {
+    if (manualSaving) return;
+    setManualSaving(true);
+    setError("");
+    try {
+      let ingredient = manualIngredient;
+      if (!ingredient) {
+        ingredient = await createManualIngredient();
+      }
+      if (!ingredient?._id || !manualCategoryId) {
+        throw new Error("Selecciona ingrediente y categoría.");
+      }
+      const data = await apiRequest(`/api/kitchen/shopping/${weekStart}/items/manual`, {
+        method: "POST",
+        body: JSON.stringify({ ingredientId: ingredient._id, categoryId: manualCategoryId })
+      });
+      applyPayload(data);
+      setManualOpen(false);
+      setManualQuery("");
+      setManualIngredient(null);
+      setManualCategoryId("");
+      setSuccess("Item añadido a la lista.");
+    } catch (err) {
+      setError(err.message || "No se pudo añadir el item manual.");
+    } finally {
+      setManualSaving(false);
+    }
+  };
+
+  const createStoreFromDropdown = async () => {
+    const name = window.prompt("Nombre del supermercado");
+    if (!name || !name.trim()) return;
+    setError("");
+    try {
+      await apiRequest("/api/kitchen/shopping/stores", {
+        method: "POST",
+        body: JSON.stringify({ name: name.trim() })
+      });
+      await loadList({ silent: true });
+    } catch (err) {
+      logShoppingApiError("createStoreFromDropdown", "/api/kitchen/shopping/stores", err);
+      setError(err.message || "No se pudo crear el supermercado.");
+    }
+  };
+
+  const pendingCount = useMemo(() => {
+    if (!Array.isArray(pendingByCategory)) return null;
+    return pendingByCategory.reduce((acc, group) => acc + (group.items?.length || 0), 0);
+  }, [pendingByCategory]);
+
+  const purchasedCount = useMemo(() => {
+    if (!Array.isArray(purchasedByStoreDay)) return null;
+    return purchasedByStoreDay.reduce((acc, group) => acc + (group.items?.length || 0), 0);
+  }, [purchasedByStoreDay]);
+
+  if (isDiodGlobalMode) {
+    return (
+      <KitchenLayout>
+        <div className="kitchen-card">Selecciona un hogar activo para ver su lista de la compra.</div>
+      </KitchenLayout>
+    );
+  }
+
+  return (
+    <KitchenLayout>
+      <div className="shopping-page-shell">
+        <div className="kitchen-card shopping-main-card">
+          <div className="shopping-header-card">
+            <div className="shopping-header-row">
+              <div>
+                <h1>Lista de la compra · Semana {formatWeekTitle(weekStart)}</h1>
+              </div>
+              <div className="kitchen-actions">
+                <button className="kitchen-button" type="button" onClick={() => setManualOpen(true)}>+ Añadir</button>
+                <button className="shopping-refresh-icon" type="button" onClick={refreshList} disabled={isRefreshing} aria-label="Reconstruir lista" title="Reconstruir lista">
+                <RefreshIcon className="shopping-week-arrow-icon" />
+              </button>
+              </div>
+            </div>
+
+            <WeekNavigator
+              className="shopping-week-nav"
+              value={weekStart}
+              onChange={(nextValue) => setWeekStart(normalizeWeekStartInput(nextValue))}
+              onPrevious={() => setWeekStart((prev) => addDaysToISO(prev, -7))}
+              onNext={() => setWeekStart((prev) => addDaysToISO(prev, 7))}
+            />
+
+          </div>
+
+          <div className="kitchen-dishes-tabs" role="tablist" aria-label="Estado de la compra">
+            <button className={`kitchen-tab-button ${tab === "pending" ? "is-active" : ""}`} onClick={() => setTab("pending")}>Pendiente ({pendingCount === null ? "—" : pendingCount})</button>
+            <button className={`kitchen-tab-button ${tab === "purchased" ? "is-active" : ""}`} onClick={() => setTab("purchased")}>Comprado</button>
+          </div>
+
+          {tab === "pending" ? (
+            <div className="shopping-toolbar">
+              <select
+                className="kitchen-select shopping-store-select"
+                value={selectedStoreId}
+                onChange={(event) => {
+                  const value = event.target.value;
+                  if (value === "__add__") {
+                    void createStoreFromDropdown();
+                    return;
+                  }
+                  selectedStoreRef.current = value;
+                  setSelectedStoreId(value);
+                }}
+              >
+                <option value="">Supermercado (opcional)</option>
+                {stores.map((store) => (
+                  <option key={store._id} value={store._id}>{store.name}</option>
+                ))}
+                <option value="__add__">Añadir supermercado…</option>
+              </select>
+            </div>
+          ) : null}
+
+          {(success || error) ? (
+            <div className="shopping-toolbar-alerts" aria-live="polite">
+              {success ? <div className="kitchen-alert success shopping-toolbar-alert">{success}</div> : null}
+              {error ? <div className="kitchen-alert error shopping-toolbar-alert">{error}</div> : null}
+            </div>
+          ) : null}
+
+          {tab === "pending" ? (
+            <div className="shopping-categories">
+              <div className="shopping-bulk-actions">
+                <button className="kitchen-button ghost shopping-bulk-button" type="button" onClick={() => setAllItemsStatus("purchased")}>Marcar todo como comprado</button>
+              </div>
+              {!Array.isArray(pendingByCategory) ? (
+                <div className="shopping-empty-state"><EmptyStateIcon /><h4>No se pudo cargar la lista.</h4></div>
+              ) : pendingByCategory.length === 0 ? (
+                <div className="shopping-empty-state">
+                  {purchasedCount ? <EmptyCheckIcon /> : <EmptyListIcon />}
+                  <h4>{purchasedCount ? "Todo comprado por esta semana." : "No hay nada por comprar todavía."}</h4>
+                </div>
+              ) : pendingByCategory.map((group) => {
+              const category = { name: group.categoryInfo?.name || "Sin categoría", ...slugColor(group.categoryInfo?.slug), ...group.categoryInfo };
+              return (
+                <div className="shopping-category-card" key={group.categoryId || group.categoryInfo?.slug || group.categoryInfo?.name} style={{ "--category-bg": category.colorBg, "--category-text": category.colorText }}>
+                  <div className="shopping-category-head"><h4>{category.name.toUpperCase()}</h4><span className="shopping-category-count">{group.items.length} items</span></div>
+                  <div className="shopping-items-list">
+                    {group.items.map((item) => {
+                      const key = itemKey(item);
+                      return (
+                        <div className={`shopping-item ${transitioningItemKey === key ? "is-leaving" : ""}`} key={key}>
+                          <button className="shopping-check" type="button" onClick={() => setItemStatus(item, "purchased")}><span className="shopping-check-dot">✓</span></button>
+                          <span className="shopping-item-text">{item.displayName}</span>
+                          {item.occurrences > 1 ? <span className="shopping-item-amount">x{item.occurrences}</span> : null}
+                        </div>
+                      );
+                    })}
+                  </div>
+                </div>
+              );
+              })}
+            </div>
+          ) : (
+            <div className="shopping-categories">
+              <div className="shopping-bulk-actions">
+                <button
+                  className="kitchen-button ghost shopping-bulk-button"
+                  type="button"
+                  onClick={() => {
+                    if (window.confirm("¿Desmarcar todo lo comprado de esta semana?")) {
+                      void setAllItemsStatus("pending");
+                    }
+                  }}
+                >
+                  Desmarcar todo
+                </button>
+              </div>
+              {!Array.isArray(purchasedByStoreDay) ? (
+                <div className="shopping-empty-state"><EmptyStateIcon /><h4>No se pudo cargar la lista.</h4></div>
+              ) : purchasedByStoreDay.length === 0 ? (
+                <div className="shopping-empty-state"><EmptyHistoryIcon /><h4>No hay nada comprado esta semana.</h4></div>
+              ) : purchasedByStoreDay.map((group) => (
+              <div className="shopping-category-card shopping-purchased-card" key={`${group.purchasedDate}-${group.storeId || "none"}`}>
+                <h4>Comprado por <span>{group.purchasedByName || "Usuario"}</span> · <em>{group.storeName || "Sin supermercado"}</em> · {formatTripDate(group.purchasedDate)}</h4>
+                <div className="shopping-items-list shopping-items-list-purchased">
+                  {group.items.map((item) => {
+                    const key = itemKey(item);
+                    return (
+                      <div className={`shopping-item purchased ${transitioningItemKey === key ? "is-leaving" : ""} ${recentlyMovedItemKey === key ? "is-entering" : ""}`} key={key}>
+                        <button className="shopping-check is-checked" type="button" onClick={() => setItemStatus(item, "pending")}><span className="shopping-check-dot">✓</span></button>
+                        <span className="shopping-item-text">{item.displayName}</span>
+                        {item.occurrences > 1 ? <span className="shopping-item-amount">x{item.occurrences}</span> : null}
+                        <select className="kitchen-select shopping-store-select-compact" value={item.storeId || ""} onChange={(event) => updatePurchasedItemStore(item, event.target.value)}>
+                          <option value="">Sin supermercado</option>
+                          {stores.map((store) => (
+                            <option key={store._id} value={store._id}>{store.name}</option>
+                          ))}
+                        </select>
+                      </div>
+                    );
+                  })}
+                </div>
+              </div>
+            ))}
+            </div>
+          )}
+        </div>
+      </div>
+      {manualOpen ? (
+        <div className="kitchen-modal-backdrop" role="presentation" onClick={() => setManualOpen(false)}>
+          <div className="kitchen-modal" role="dialog" aria-modal="true" aria-label="Añadir item manual" onClick={(event) => event.stopPropagation()}>
+            <div className="kitchen-modal-header"><h3>Añadir item manual</h3></div>
+            <div className="kitchen-form">
+              <label className="kitchen-field">
+                <span className="kitchen-label">Ingrediente</span>
+                <input className="kitchen-input" value={manualQuery} onChange={(event) => { setManualQuery(event.target.value); setManualIngredient(null); }} placeholder="Buscar ingrediente..." />
+              </label>
+              <div className="kitchen-suggestion-list">
+                {(manualSuggestions || []).slice(0, 8).map((item) => (
+                  <button key={item._id} type="button" className="kitchen-suggestion" onClick={() => { setManualIngredient(item); setManualQuery(item.name || ""); setManualCategoryId(item.categoryId?._id || ""); }}>
+                    <span className="kitchen-suggestion-name">{item.name}</span>
+                  </button>
+                ))}
+              </div>
+              <label className="kitchen-field">
+                <span className="kitchen-label">Categoría</span>
+                <select className="kitchen-select" value={manualCategoryId} onChange={(event) => setManualCategoryId(event.target.value)}>
+                  <option value="">Selecciona categoría</option>
+                  {manualCategories.map((category) => (
+                    <option key={category._id} value={category._id}>{category.name}</option>
+                  ))}
+                </select>
+              </label>
+              {!manualIngredient && manualQuery.trim() && !manualSuggestions.some((item) => normalizeQuery(item.name) === normalizeQuery(manualQuery)) ? (
+                <div className="kitchen-muted">Se creará “{manualQuery.trim()}” en el hogar actual.</div>
+              ) : null}
+              <div className="kitchen-modal-actions">
+                <button className="kitchen-button" type="button" onClick={submitManualItem} disabled={manualSaving}>{manualSaving ? "Guardando..." : "Añadir"}</button>
+                <button className="kitchen-button ghost" type="button" onClick={() => setManualOpen(false)}>Cancelar</button>
+              </div>
+            </div>
+          </div>
+        </div>
+      ) : null}
+    </KitchenLayout>
+  );
+}
